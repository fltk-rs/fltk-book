<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>fltk book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Home.html"><strong aria-hidden="true">1.</strong> 开始</a></li><li class="chapter-item expanded "><a href="Setup.html"><strong aria-hidden="true">2.</strong> 配置</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Cross-Compiling.html"><strong aria-hidden="true">2.1.</strong> 交叉编译</a></li><li class="chapter-item expanded "><a href="Fluid.html"><strong aria-hidden="true">2.2.</strong> 使用 Fluid</a></li></ol></li><li class="chapter-item expanded "><a href="The-App-struct.html"><strong aria-hidden="true">3.</strong> App 结构</a></li><li class="chapter-item expanded "><a href="Windows.html"><strong aria-hidden="true">4.</strong> 窗口 Windows</a></li><li class="chapter-item expanded "><a href="Widgets.html"><strong aria-hidden="true">5.</strong> 组件 Widgets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Buttons.html"><strong aria-hidden="true">5.1.</strong> 按钮 Buttons</a></li><li class="chapter-item expanded "><a href="Labels.html"><strong aria-hidden="true">5.2.</strong> 标签 Labels</a></li><li class="chapter-item expanded "><a href="Group-widgets.html"><strong aria-hidden="true">5.3.</strong> 组控件 Group widgets</a></li><li class="chapter-item expanded "><a href="Menus.html"><strong aria-hidden="true">5.4.</strong> 菜单 Menus</a></li><li class="chapter-item expanded "><a href="Input-&-Output.html"><strong aria-hidden="true">5.5.</strong> 输入输出 Input & Output</a></li><li class="chapter-item expanded "><a href="Valuators.html"><strong aria-hidden="true">5.6.</strong> 估值器 Valuators</a></li><li class="chapter-item expanded "><a href="Text.html"><strong aria-hidden="true">5.7.</strong> 文字 Text</a></li><li class="chapter-item expanded "><a href="Browsers.html"><strong aria-hidden="true">5.8.</strong> 阅览器 Browsers</a></li><li class="chapter-item expanded "><a href="Trees.html"><strong aria-hidden="true">5.9.</strong> 树 Trees</a></li><li class="chapter-item expanded "><a href="Tables.html"><strong aria-hidden="true">5.10.</strong> 表格 Tables</a></li><li class="chapter-item expanded "><a href="Custom-Widgets.html"><strong aria-hidden="true">5.11.</strong> 自定义组件 Custom widgets</a></li></ol></li><li class="chapter-item expanded "><a href="Dialogs.html"><strong aria-hidden="true">6.</strong> 对话框 Dialogs</a></li><li class="chapter-item expanded "><a href="Images.html"><strong aria-hidden="true">7.</strong> 图像 Images</a></li><li class="chapter-item expanded "><a href="Events.html"><strong aria-hidden="true">8.</strong> 事件 Events</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Drag-&-Drop.html"><strong aria-hidden="true">8.1.</strong> Drag & Drop</a></li><li class="chapter-item expanded "><a href="State-Management.html"><strong aria-hidden="true">8.2.</strong> State Management</a></li></ol></li><li class="chapter-item expanded "><a href="Layouts.html"><strong aria-hidden="true">9.</strong> 布局 Layouts</a></li><li class="chapter-item expanded "><a href="Style.html"><strong aria-hidden="true">10.</strong> 样式 Style</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Colors.html"><strong aria-hidden="true">10.1.</strong> 颜色 Colors</a></li><li class="chapter-item expanded "><a href="FrameTypes.html"><strong aria-hidden="true">10.2.</strong> FrameTypes</a></li><li class="chapter-item expanded "><a href="Fonts.html"><strong aria-hidden="true">10.3.</strong> 字体 Fonts</a></li><li class="chapter-item expanded "><a href="Drawing.html"><strong aria-hidden="true">10.4.</strong> Drawing things</a></li><li class="chapter-item expanded "><a href="Styling.html"><strong aria-hidden="true">10.5.</strong> Styling</a></li></ol></li><li class="chapter-item expanded "><a href="Animations.html"><strong aria-hidden="true">11.</strong> 动画 Animations</a></li><li class="chapter-item expanded "><a href="FAQ.html"><strong aria-hidden="true">12.</strong> FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">fltk book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="开始"><a class="header" href="#开始">开始</a></h1>
<p>欢迎来到 <a href="https://github.com/fltk-rs/fltk-rs">fltk-rs</a> !</p>
<p>这是为 <a href="https://crates.io/crates/fltk">fltk crate</a> 而写的一本说明书。 其他资源有:</p>
<ul>
<li><a href="https://docs.rs/fltk">官方文档</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs#tutorials">视频</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/discussions">讨论、社区</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/tree/master/fltk/examples">示例</a></li>
<li><a href="https://github.com/fltk-rs/demos">示范</a></li>
<li><a href="https://github.com/tdryer/7guis-fltk-rs">7guis-fltk-rs</a></li>
<li><a href="https://github.com/wyhinton/FLTK-RS-Examples">FLTK-RS-Examples</a></li>
<li>Erco's FLTK cheat <a href="http://seriss.com/people/erco/fltk/">page</a>, which is an excellent FLTK C++ reference. </li>
</ul>
<p><a href="https://github.com/fltk/fltk">FLTK</a> 是一个跨平台的轻量级 gui库。
该库自身是使用 C++98编写的，具有高度可移植性。 fltk crate 则使用 rust实现，并使用FFI来调用 使用C89和C++11编写的FLTK封装器 <a href="https://github.com/MoAlyousef/cfltk">cfltk</a>。</p>
<p>该库的构造及其简洁，习惯使用面向对象gui库的开发者会感觉到很熟悉。封装器本身也遵循同样的模式，因为方法的名称与C++的名称相同或相似，这使得文档大大简化。同时也让参考FLTK的C++文档变得非常简单，因为这些方法基本上是相互对应的。</p>
<p>C++：</p>
<pre><code class="language-c++">int main() {
    auto wind = new Fl_Window(100, 100, 400, 300, &quot;My Window&quot;);
    wind-&gt;end();
    wind-&gt;show();
}
</code></pre>
<p>Rust：</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let wind = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    wind.end();
    wind.show();
}
</code></pre></pre>
<p>为什么选择 FLTK ？</p>
<ul>
<li>轻量。二进制文件简小，strip 后仅有大约1MB。 <a href="https://szibele.com/memory-footprint-of-gui-toolkits/">低内存占用</a>。</li>
<li>快速。安装快、构建快、启动快、运行快。</li>
<li>仅有一个运行文件。不需要配置DDL库。</li>
<li>向前兼容，支持旧架构。</li>
<li>FLTK的允许性许可证，允许闭源应用静态链接。</li>
<li>多主题 (4款默认支持的主题: Base, GTK, Plastic and Gleam)，以及 <a href="https://crates.io/crates/fltk-theme">fltk-theme</a> 中的其他主题。</li>
<li>提供了约80个可供自定义的 widget。</li>
<li>内置图像支持。</li>
</ul>
<h2 id="用法"><a class="header" href="#用法">用法</a></h2>
<p>将以下代码添加到你的 Cargo.toml 文件:</p>
<pre><code class="language-toml">[dependencies]
fltk = &quot;^1.2&quot;
</code></pre>
<p>使用捆绑的库（适用于 x64 windows (msvc &amp; gnu (msys2)), x64 linux &amp; macos）:</p>
<pre><code class="language-toml">[dependencies]
fltk = { version = &quot;^1.2&quot;, features = [&quot;fltk-bundled&quot;] }
</code></pre>
<p>该库会自动构建并静态链接到你的二进制文件中。</p>
<p>我们需要导入必要的 fltk 模块，以使我们的第一个rust代码示例工作：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, window::Window};
fn main() {
    let wind = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    wind.end();
    wind.show();
}
</code></pre></pre>
<p>如果你运行代码样本，你可能会发现什么都没有发生。实际上，我们还需要运行事件循环（event loop），这相当于在C++中使用<code>Fl::run()</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, prelude::*, window::Window};
fn main() {
    let a = app::App::default();
    let wind = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    wind.end();
    wind.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>我们实例化了 App 结构，它初始化了 runtime 和 styles，在main的最后，我们调用了 run() 函数。</p>
<h2 id="为本书做贡献"><a class="header" href="#为本书做贡献">为本书做贡献</a></h2>
<p>这本书是使用 <a href="https://github.com/rust-lang/mdBook">mdbook</a>，根据 <a href="https://github.com/fltk-rs/fltk-book">fltk-book</a> 仓库的内容生成的。本书的作者为 <strong>Mohammed Alyousef</strong>，由 <strong>Flatig L</strong> 翻译为中文</p>
<p>因此，你可能需要运行 <code>cargo install mdbook</code>. 更多说明可以在fltk-book的README文件和mdbook的 <a href="https://rust-lang.github.io/mdBook/">用户指南</a> 中找到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置"><a class="header" href="#配置">配置</a></h1>
<p>请确保 Rust (version &gt; 1.45)，CMake (version &gt; 3.11)，Git 和一个 C++11 编译器已安装并在 PATH 中配置，以此通过源代码构建跨平台程序。这个 crate 还在选定的平台上提供了fltk的捆绑形式，这可以使用fltk-bundle feature flag 来启用（这需要curl和tar来下载并解包捆绑的库）。如果你安装了 ninja-build ，你可以使用 &quot;use-ninja&quot; feature来启用它。这应该会大大加快构建时间。</p>
<ul>
<li>Windows: 
<ul>
<li>MSVC: Windows SDK</li>
<li>Gnu: 无依赖</li>
</ul>
</li>
<li>MacOS: 无依赖</li>
<li>Linux: 开发时需要安装 X11 and OpenGL 头文件。这些库本身可以在具有图形用户界面的Linux发行版上使用。</li>
</ul>
<p>基于 Debian 的Linux发行版，运行：</p>
<pre><code>sudo apt-get install libx11-dev libxext-dev libxft-dev libxinerama-dev libxcursor-dev libxrender-dev libxfixes-dev libpango1.0-dev libgl1-mesa-dev libglu1-mesa-dev
</code></pre>
<p>基于 RHEL的Linux发行版，运行：</p>
<pre><code>sudo yum groupinstall &quot;X Software Development&quot; &amp;&amp; yum install pango-devel libXinerama-devel
</code></pre>
<p>基于 Arch 的Linux发行版，运行：</p>
<pre><code>sudo pacman -S libx11 libxext libxft libxinerama libxcursor libxrender libxfixes pango cairo libgl mesa --needed
</code></pre>
<p>Alpine Linux：</p>
<pre><code>apk add pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
</code></pre>
<ul>
<li>Android： Android Studio，Android Sdk， Android Ndk。</li>
</ul>
<h2 id="具体配置细节"><a class="header" href="#具体配置细节">具体配置细节</a></h2>
<p>本节假设你甚至没有安装Rust，我们分几个不同的环境讨论：</p>
<h3 id="windows-msvc-toolchain"><a class="header" href="#windows-msvc-toolchain">Windows (MSVC toolchain)</a></h3>
<ul>
<li>访问rust语言官网的 <a href="https://www.rust-lang.org/learn/get-started">开始</a>。</li>
<li>按照 &quot;Visual Studio C++ build tools &quot;的链接，下载MSVC编译器和Windows sdk。</li>
<li>使用安装器安装：</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/37966791/116013495-2dff8800-a639-11eb-8e4c-8c6228e00abc.png" alt="image" /></p>
<p>确保选中这些：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/116013520-48d1fc80-a639-11eb-934a-fac6609135b4.png" alt="image" /></p>
<ul>
<li>你也需要在前面的列表中检查是否有CMake，或者点击这里直接下载 <a href="https://cmake.org/download/">Cmake</a>。</li>
<li>如果你还没有GIt，请点击下载 <a href="https://git-scm.com/downloads">Git</a>。</li>
<li>从 rust-lang.org 网站上，下载适合你的架构的正确的rustup安装程序。</li>
<li>一旦你都准备好了，你就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>作为依赖，然后开始构建你的应用程序。</li>
</ul>
<h3 id="windows-gnu-toolchain"><a class="header" href="#windows-gnu-toolchain">Windows (gnu toolchain)</a></h3>
<p>如果你还没有msys2，点击这里安装 <a href="https://www.msys2.org/">msys2</a>。</p>
<ul>
<li>你可以通过pacman软件包管理器获得Rust工具链，或者通过前面所说的rustup。然而，在安装过程中需要指定使用gnu工具链（而不是默认安装MSVC工具链）。
工具链也应该反映你的机器的结构。例如，一台64位机器应该安装x86_64-pc-windows-gnu工具链。
如果你决定通过软件包管理器来获得Rust，请确保你得到的是mingw的变体，并且有正确的MINGW_PACKAGE_PREFIX（对于64位机器，这个环境变量相当于mingw-w64-x86_64）。</li>
<li>假设你通过pacman安装了所有东西，打开mingw shell（不是msys2 shell，它可以在msys2安装目录下找到，或者通过<code>source shell mingw64</code>）并运行以下内容：</li>
</ul>
<pre><code>pacman -S curl tar git $MINGW_PACKAGE_PREFIX-rust $MINGW_PACKAGE_PREFIX-gcc $MINGW_PACKAGE_PREFIX-cmake $MINGW_PACKAGE_PREFIX-make --needed
</code></pre>
<p>如果你打算通过use-ninja使用ninja，你可以用$MINGW_PACKAGE_PREFIX-ninja替换$MINGW_PACKAGE_PREFIX-make。</p>
<ul>
<li>一旦你都准备好了，你就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>作为依赖，然后开始构建你的应用程序。</li>
</ul>
<h3 id="macos"><a class="header" href="#macos">MacOS</a></h3>
<ul>
<li>要获得Xcode命令行工具（它带有C++编译器），运行下列代码：</li>
</ul>
<pre><code>xcode-select --install
</code></pre>
<p>​	之后按照说明进行。或者，你也可以通过Homebrew安装clang或gcc：</p>
<ul>
<li>为了下载CMake，你可以点击这里下载<a href="https://cmake.org/download/">CMake</a>。</li>
</ul>
<p>或者，也可以跟上面一样使用Homebrew：</p>
<pre><code>brew install cmake
</code></pre>
<ul>
<li>安装Rust Toolchain：</li>
</ul>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>按照默认设置进行即可。</p>
<ul>
<li>一旦你都准备好了，你就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>作为依赖，然后开始构建你的应用程序。</li>
</ul>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<ul>
<li>使用你的软件包管理器安装一个C++编译器，还有CMake，make，git。
以Debian/Ubuntu 为例：</li>
</ul>
<pre><code>sudo apt-get install g++ cmake git make
</code></pre>
<ul>
<li>要获得FLTK的开发依赖项，你也可以使用你的软件包管理器。
对基于Debian的GUI发行版，运行下列代码：</li>
</ul>
<pre><code>sudo apt-get install libx11-dev libxext-dev libxft-dev libxinerama-dev libxcursor-dev libxrender-dev libxfixes-dev libpango1.0-dev libgl1-mesa-dev libglu1-mesa-dev
</code></pre>
<p>对于基于RHEL的GUI发行版，运行下列代码：</p>
<pre><code>sudo yum groupinstall &quot;X Software Development&quot; &amp;&amp; yum install pango-devel libXinerama-devel
</code></pre>
<p>对于基于Arch Linux的GUI发行版，运行下列代码：</p>
<pre><code>sudo pacman -S libx11 libxext libxft libxinerama libxcursor libxrender libxfixes pango cairo libgl mesa --needed
</code></pre>
<p>对于Alpine linux：</p>
<pre><code>apk add pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
</code></pre>
<ul>
<li>安装Rust Toolchain：</li>
</ul>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>按照默认设置进行即可。</p>
<ul>
<li>一旦你都准备好了，你就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>作为依赖，然后开始构建你的应用程序。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="交叉编译"><a class="header" href="#交叉编译">交叉编译</a></h1>
<h2 id="使用预置bundle"><a class="header" href="#使用预置bundle">使用预置Bundle</a></h2>
<p>如果你要为下列平台编译的话，很幸运，它们已经有一个预置包了：</p>
<ul>
<li>x86_64-pc-windows-gnu</li>
<li>x86_64-pc-windows-msvc</li>
<li>x86_64-apple-darwin</li>
<li>aarch64-apple-darwin</li>
<li>x86_64-unknown-linux-gnu</li>
<li>aarch64-unknown-linux-gnu</li>
</ul>
<p>通过rustup添加target，然后调用build：</p>
<pre><code>rustup target add &lt;your target&gt; # 使用上列目标平台替换target
cargo build --target=&lt;your target&gt; --features=fltk-bundled
</code></pre>
<p>对于arch64-unknonw-linux-gnu，你可能需要验证链接器：</p>
<pre><code>CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc cargo build --target=&lt;your target&gt; --features=fltk-bundled
</code></pre>
<h2 id="使用交叉编译-cc-toolchain"><a class="header" href="#使用交叉编译-cc-toolchain">使用交叉编译 C/C++ toolchain</a></h2>
<p>我们的想法是，你需要一个C/C++交叉编译器和一个正如前面的方案中提到的，通过<code>rustup target add</code>安装的Rust target。</p>
<p>对于Windows and MacOS，系统编译器已经支持为特定的架构为目标编译。例如，在MacOS上，如果你已经可以使用你的系统编译器构建fltk应用程序，你可以针对不同的架构使用下列命令进行编译（假设你有一个intel x86_64 mac）：</p>
<pre><code>rustup target add aarch64-apple-darwin
cargo build --target=arch64-apple-darwin
</code></pre>
<h3 id="linux-to-64-bit-windows"><a class="header" href="#linux-to-64-bit-windows">Linux to 64-bit Windows</a></h3>
<p>假设你想从Linux交叉编译到64位Windows，在此之前你已经能够在你的主机上进行编译。</p>
<ul>
<li>你需要使用下令命令添加Rust target：</li>
</ul>
<pre><code>rustup target add x86_64-pc-windows-gnu # 基于arch
</code></pre>
<ul>
<li>安装一个C/C++ 交叉编译器，比如Mingw toolchain。在基于Debian的发行部上，你可以运行：</li>
</ul>
<pre><code>apt-get install mingw-w64 # 或者 gcc-mingw-w64-x86-64
</code></pre>
<p>在基于RHEL的发行部上：</p>
<pre><code>dnf install mingw64-gcc
</code></pre>
<p>在Arch上：</p>
<pre><code>pacman -S mingw-w64-gcc
</code></pre>
<p>在Alpine上：</p>
<pre><code>apk add mingw-w64-gcc
</code></pre>
<ul>
<li>在你项目根目录添加一个<code>.cargo/config.toml</code> （如果你想全局设置的话，也可以是HOME目录）并指定交叉链接器和归档管理器：</li>
</ul>
<pre><code class="language-toml"># .cargo/config.toml
[target.x86_64-pc-windows-gnu]
linker = &quot;x86_64-w64-mingw32-gcc&quot;
ar = &quot;x86_64-w64-mingw32-gcc-ar&quot;
</code></pre>
<ul>
<li>运行build：</li>
</ul>
<pre><code>cargo build --target=x86_64-pc-windows-gnu
</code></pre>
<h3 id="x64-linux-gnu-to-aarch64-linux-gnu"><a class="header" href="#x64-linux-gnu-to-aarch64-linux-gnu">x64 linux-gnu to aarch64 linux-gnu</a></h3>
<p>另一个例子是，从基于x86_64 debian的发行版到基于arm64 debian的发行部：
假设你已经安装了cmake：</p>
<ul>
<li>你需要使用下列命令添加 rust target：</li>
</ul>
<pre><code>rustup target add aarch64-unknown-linux-gnu
</code></pre>
<ul>
<li>安装一个C/C++ 交叉编译器，比如Mingw toolchain。在基于Debian的发行版上，你可以运行：</li>
</ul>
<pre><code>apt-get install g++-aarch64-linux-gnu
</code></pre>
<ul>
<li>为你的系统添加需要的架构：</li>
</ul>
<pre><code>sudo dpkg --add-architecture arm64
</code></pre>
<ul>
<li>你可能需要将下列镜像添加到/etc/apt/sources.list：</li>
</ul>
<pre><code>sudo sed -i &quot;s/deb http/deb [arch=amd64] http/&quot; /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s) main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-security main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-backports main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-updates main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
</code></pre>
<p>第一条命令改变了当前的镜像， 以反映你当前的 amd64 系统。其他命令则将 arm64 的端口添加到 /etc/apt/sources.list 文件中。</p>
<ul>
<li>更新你的包管理器数据库：</li>
</ul>
<pre><code>sudo apt-get update
</code></pre>
<ul>
<li>为你的目标平台安装需要的依赖：</li>
</ul>
<pre><code>sudo apt-get install libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 libxinerama-dev:arm64 libxcursor-dev:arm64 libxrender-dev:arm64 libxfixes-dev:arm64 libpango1.0-dev:arm64 libgl1-mesa-dev:arm64 libglu1-mesa-dev:arm64 libasound2-dev:arm64
</code></pre>
<p>注意软件包名称中的<code>:arm64</code>后缀。</p>
<ul>
<li>运行build：</li>
</ul>
<pre><code>CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc cargo build --target=aarch64-unknown-linux-gnu
</code></pre>
<h2 id="使用cross"><a class="header" href="#使用cross">使用cross</a></h2>
<p>如果你已经安装了docker，你可以试试 <a href="https://github.com/cross-rs/cross">cross</a>：</p>
<pre><code>cargo install cross
cross build --target=x86_64-pc-windows-gnu # replace with your target, the Docker daemon has to be running, no need to add via rustup
</code></pre>
<p>如果你的target需要外部依赖，比如在Linux上，你将必须创建一个自定义的docker镜像，并通过Cross.toml文件将其用于交叉编译。例如，对于一个有如下结构的项目来说。</p>
<pre><code>myapp
     |_src
     |    |_main.rs    
     |
     |_Cargo.toml
     |
     |_Cross.toml
     |
     |_arm64-dockerfile
</code></pre>
<p>arm64-dockerfile（名称并不重要，只要确保Cross.toml指向该文件）的内容：</p>
<pre><code class="language-dockerfile">FROM ghcr.io/cross-rs/aarch64-unknown-linux-gnu:latest

RUN dpkg --add-architecture arm64 &amp;&amp; \
    apt-get update &amp;&amp; \
    apt-get install --assume-yes --no-install-recommends \
    libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 \
    libxinerama-dev:arm64 libxcursor-dev:arm64 \
    libxrender-dev:arm64  libxfixes-dev:arm64  libgl1-mesa-dev:arm64 \
    libglu1-mesa-dev:arm64 libasound2-dev:arm64 libpango1.0-dev:arm64
</code></pre>
<p>注意库包名称后面附加的架构，如：libx11-dev:arm64。</p>
<p>Cross.toml的内容：</p>
<pre><code class="language-toml">[target.aarch64-unknown-linux-gnu]
dockerfile = &quot;./arm64-dockerfile&quot;
</code></pre>
<p>最后运行cross：</p>
<pre><code>cross build --target=aarch64-unknown-linux-gnu
</code></pre>
<p>第一次运行可能会花较长时间</p>
<h2 id="使用docker"><a class="header" href="#使用docker">使用docker</a></h2>
<p>直接使用目标平台的docker镜像可以让你免去使用cross交叉编译到不同linux目标的麻烦。
你需要一个Docker文件，它可以拉出你想要的target，并安装Rust和C++工具链以及所需的依赖。
例如，为allpine linux构建：</p>
<pre><code class="language-dockerfile">FROM alpine:latest AS alpine_build
RUN apk add rust cargo git cmake make g++ pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
COPY . .
RUN cargo build --release

FROM scratch AS export-stage
COPY --from=alpine_build target/release/&lt;your binary name&gt; .
</code></pre>
<p>然后运行：</p>
<pre><code>DOCKER_BUILDKIT=1 docker build --file Dockerfile --output out .
</code></pre>
<p>你的二进制文件将在<code>./out</code>目录中。
注意在alpine上，如果你通过rustup安装Rust，你可能需要在你的dockerfile中把musl-gcc和musl-g++指向相应的工具链（在运行<code>cargo build</code>之前）。</p>
<pre><code class="language-dockerfile">RUN ln -s /usr/bin/x86_64-alpine-linux-musl-gcc /usr/bin/musl-gcc
RUN ln -s /usr/bin/x86_64-alpine-linux-musl-g++ /usr/bin/musl-g++
</code></pre>
<p>另一个例子是将 amd64 linux-gnu 编译成 arm64 linux-gnu：</p>
<pre><code class="language-dockerfile">FROM ubuntu:latest AS ubuntu_build

RUN apt-get update -qq
RUN	apt-get install -y --no-install-recommends lsb-release g++-aarch64-linux-gnu g++ cmake curl tar git 
RUN	dpkg --add-architecture arm64 
RUN sed -i &quot;s/deb http/deb [arch=amd64] http/&quot; /etc/apt/sources.list
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s) main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-security main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-backports main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-updates main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN	apt-get update -qq &amp;&amp; apt-get install -y --no-install-recommends libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 libxinerama-dev:arm64 libxcursor-dev:arm64 libxrender-dev:arm64 libxfixes-dev:arm64 libpango1.0-dev:arm64 libgl1-mesa-dev:arm64 libglu1-mesa-dev:arm64 libasound2-dev:arm64
RUN curl https://sh.rustup.rs -sSf | sh -s -- --default-toolchain stable --profile minimal -y

ENV PATH=/root/.cargo/bin:$PATH

RUN rustup target add aarch64-unknown-linux-gnu
# works around an include path issue in some debian versions
RUN apt-get install -y libharfbuzz-dev libpango1.0-dev --no-install-recommends &amp;&amp; cp /usr/include/harfbuzz/*.h /usr/include/aarch64-linux-gnu

COPY . .

RUN CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc cargo build --release --target=aarch64-unknown-linux-gnu

FROM scratch AS export-stage
COPY --from=ubuntu_build target/aarch64-unknown-linux-gnu/release/&lt;your binary 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fluid"><a class="header" href="#fluid">Fluid</a></h1>
<p>FLTK提供了一个名为FLUID的，所见即所得的快速GUI应用开发工具，用它可以创建GUI应用。
目前在youtube上有一个使用基于Rust使用它的视频教程。
<a href="https://www.youtube.com/watch?v=k_P0wG3-dNk">Use FLUID (RAD tool) with Rust</a></p>
<p>fl2rust crate将Fluid生成的.fl文件翻译成Rust代码，并编译进你的程序中。
要获取更多详细信息，请查看它的官方<a href="https://github.com/MoAlyousef/fl2rust">仓库</a>。</p>
<p>你可以使用cargo install 安装 fltk-fluid和fl2rust crates来获得FLUID。</p>
<pre><code>cargo install fltk-fluid
cargo install fl2rust
</code></pre>
<p>然后运行：</p>
<pre><code>fluid &amp;
</code></pre>
<p>你也可以通过你系统的包管理器获取Fluid，这样的话它将作为一个单独的包或fltk包的一部分。</p>
<p>目前，fl2rust并不能检查生成的Rust代码的正确性。它也只限于构造方法。</p>
<h2 id="用法-1"><a class="header" href="#用法-1">用法</a></h2>
<p>首先，你可以使用<code>cargo new app</code>创建一个新的Rust项目。
fl2rust将作为一个构建依赖项，被添加到你的项目中：</p>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
fltk = &quot;1&quot;

[build-dependencies]
fl2rust = &quot;0.4&quot;
</code></pre>
<p>然后就可以在build.rs文件中使用它（该文件在预编译时运行）来生成Rust代码。</p>
<pre><pre class="playground"><code class="language-rust edition2018">// build.rs
fn main() {
    use std::path::PathBuf;
    use std::env;
    println!(&quot;cargo:rerun-if-changed=src/myuifile.fl&quot;);
    let g = fl2rust::Generator::default();
    let out_path = PathBuf::from(env::var(&quot;OUT_DIR&quot;).unwrap());
    g.in_out(&quot;src/myuifile.fl&quot;, out_path.join(&quot;myuifile.rs&quot;).to_str().unwrap()).expect(&quot;Failed to generate rust from fl file!&quot;);
}
</code></pre></pre>
<p>我们将把fluid文件命名为myuifile.fl。我们告诉cargo，如果该文件被修改，就重新运行。我们将在我们的源代码目录创建文件，但如果你愿意，也可以为它创建自己的文件夹放进去。我们告诉生成器，让它接受fluid文件并生成一个myuifile.rs。这个文件是在OUT_DIR中生成的，所以你不会在你的src目录中看到它。
但是为了包含（include）它，你需要创建一个Rust源文件，它可以和我们输出的文件同名，并把它放在src目录中：</p>
<pre><code>touch src/myuifile.rs
</code></pre>
<p>我们将使用include！宏，从自动生成的文件中导入这些内容。</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/myuifile.rs
#![allow(unused_variables)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(clippy::needless_update)]

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/myuifile.rs&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>然后我们就可以使用main.rs中的内容了：</p>
<pre><pre class="playground"><code class="language-rust edition2018">// src/main.rs
use fltk::{prelude::*, *};
mod myuifile;

fn main() {
    let app = app::App::default();
    app.run().unwrap();
}
</code></pre></pre>
<p>现在到了gui部分。打开fluid：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fltk-fluid &amp; #or just fluid if installed from a package manager
<span class="boring">}
</span></code></pre></pre>
<p>“&amp;”符号让shell把它作为一个分离进程打开，所以我们仍然可以用我们的shell来编译我们的代码。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146925955-ac778726-1398-4ea2-8e46-a2f8fff89804.png" alt="image" /></p>
<p>我们第一眼看到的是一个空窗口和一个菜单栏。我们在这里的第一步是创建一个类：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926284-cd9f21ce-b4b1-4009-9766-32876a08de98.png" alt="image" /></p>
<p>这将弹出一个对话框，我们直接点击 &quot;OK &quot;让它使用默认的名称（UserInterface）。现在你会看到我们的类出现在列表中：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926505-545f26c1-ac7d-4f10-94a9-2d0c16875d4e.png" alt="image" /></p>
<p>(我们已经扩展了这个窗口)</p>
<p>接下来，再次按下new键，我们将为我们的类添加一个构造函数：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926749-9199bd23-0346-4286-993f-bfb7588ae420.png" alt="image" /></p>
<p>同样使用它的默认名称，即<code>make_window()</code>。</p>
<p>接下来我们将添加一个窗口：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926970-769ad7a1-9d03-457a-91f7-d6a18e2ba3b0.png" alt="image" /></p>
<p>现在弹出了一个新的窗口，我们可以拖动边框将其放大一些：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146927099-ff014e0d-8ea0-4f90-a500-882eb7b49bb2.png" alt="image" /></p>
<p>双击窗口会弹出一个对话框，我们可以改变窗口的gui属性（在GUI标签下）、风格（在Style标签下）和类属性（在C++标签下）。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146927520-c2ee18b1-0d17-43cd-93eb-edbf725ddf6c.png" alt="image" /></p>
<p>我们在GUI标签中给这个窗口一个<code>My Window</code>标签 ，然后在Style标签中把颜色改为白色：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146932899-6a4419ae-9c91-4b48-a363-d87c85b01778.png" alt="image" /></p>
<p>在C++标签下，我们给它一个变量名<code>my_win</code>。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146932794-7e1a2819-842d-45c7-88c8-be9fb728e805.png" alt="image" /></p>
<p>现在，我们的窗口可以通过<code>myuifile::UserInterface::my_win</code>访问。</p>
<p>现在左击窗口并添加一个Button（按钮）：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146928089-ad0454de-252e-4e81-9079-db0ef5c67c8f.png" alt="image" /></p>
<p>这将打开与之前相同的对话框，但这次我们选择按钮。在C++下，我们将给它一个变量名<code>btn</code>。在style下，我们将改变颜色和标签的颜色。然后在Gui下，我们将给它一个标签 &quot;click me&quot;。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146928419-a1a96e03-5b90-4aaa-8f70-9b17f76f9b9f.png" alt="image" /></p>
<p>可以拖动边框来调整大小，把按钮拖到任何想要的位置。Fluid有一个布局菜单，可以用它修改一些小部件（如果我们有很多按钮），使其具有相同的布局/大小...等。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146928654-43838e2a-aba8-4a24-8d70-1e25e1717c58.png" alt="image" /></p>
<p>我们现在点击<code>File/Save As...</code>将文件保存在src目录下，命名为srcmyuifile.fl。</p>
<p>现在可以运行<code>cargo run</code>来看看是否能编译通过，但我们还没有调用<code>make_window()</code>方法，所以暂时还不会看到任何东西。
现在你可以修改 src/main.rs 来显示窗口，并为我们的按钮添加一个回调。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};
mod myuifile;

fn main() {
    let app = app::App::default();
    let mut ui = myuifile::UserInterface::make_window();
    let mut win = ui.my_win.clone();
    ui.btn.set_callback(move |b| {
        b.set_label(&quot;clicked&quot;);
        win.set_label(&quot;Button clicked&quot;);
        println!(&quot;Works!&quot;);
    });
    app.run().unwrap();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-结构"><a class="header" href="#app-结构">App 结构</a></h1>
<p>crate在app模块中提供了一个App结构。初始化App结构可以初始化所有内部样式、字体和支持的图像类型。它还初始化了程序将要运行的多线程环境。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::*;

fn main() {
    let app = app::App::default();
    app.run().unwrap();
}
</code></pre></pre>
<p>run方法运行gui应用程序的事件循环（event loop）。
要对事件进行精细的控制，可以使用wait()方法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::*;

fn main() {
    let app = app::App::default();
    while app.wait() {
        // handle events
    }
}
</code></pre></pre>
<p>此外，App结构允许你使用with_scheme()初始器来设置程序的全局主题：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::*;

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);
    app.run().unwrap();
}
</code></pre></pre>
<p>这将使你的程序具有Gtk程序的样子。还有其他的内置方案，Basic、Plastic和Gleam。</p>
<p>App结构还负责在应用程序开始时使用load_system_fonts()方法加载系统字体。</p>
<p>一个典型的fltk-rs应用程序，将在创建任何部件和显示主窗口之前构建App结构。</p>
<p>任何在run()方法调用后添加的逻辑，将在事件循环结束后执行（通常是关闭应用程序的所有窗口时，或者调用quit()方法时）。该逻辑可能包括在必要时重启程序的逻辑。</p>
<p>除了App结构外，App模块本身还包含与你的程序的全局状态有关的结构和自由函数。其中包括设置背景和前景颜色、默认字体和大小等视觉效果、屏幕功能、剪贴板功能、全局处理器、应用事件、通道（channels）（发送器和接收器）和超时。</p>
<p>其中一些将在本书的其他部分讨论。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="窗口-windows"><a class="header" href="#窗口-windows">窗口 Windows</a></h1>
<p>FLTK会在它支持的系统平台上调用原生窗口，然后基本上通过自己的方法来绘制。它会在windows上调用HWND，在MacOS上调用NSWindow，在X11系统（linux, BSD）上调用XWindow。</p>
<p>Window 本身具有与FLTK提供的其他部件相同的接口，即WidgetExt trait，这将在下一页讨论。</p>
<p>让我们用到目前为止学到的东西来创建一个Window。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    my_window.end();
    my_window.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/100937363-f82ffa80-3503-11eb-8f3a-9afe34bdad59.jpg" alt="img1" /></p>
<p>调用new()函数需要五个参数：</p>
<ul>
<li><code>x</code> 以电脑屏幕最左侧为原点的水平距离。</li>
<li><code>y</code> 以电脑屏幕最左侧为原点的垂直距离。</li>
<li><code>width</code> window的宽度。</li>
<li><code>height</code> window的高度。</li>
<li><code>title</code> window标题。</li>
</ul>
<p>接下来注意对end()的调用。window，以及其他类型的widget，实现了GroupExt trait。实现该trait的这些部件将 持有 任何在call()和end()间创建的widget（通过new()创建串口时，隐式调用了begin()），或者作为其父widget。
下一个调用show()唤起了window，使其出现在显示屏上。</p>
<p>window可以被嵌入到其他window内：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut my_window2 = window::Window::new(10, 10, 380, 280, &quot;&quot;);
    my_window2.set_color(Color::Black);
    my_window2.end();
    my_window.end();
    my_window.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/100937446-139b0580-3504-11eb-8738-1e4161175d0b.jpg" alt="embed" /></p>
<p>在这里，第二个窗口，my_window2，被嵌入到第一个窗口，my_window里面。我们把它的颜色设为黑色，这样它才会被我们看到。注意，它的父窗口是第一个窗口。在父窗口之外创建第2个窗口才会创建两个独立的窗口，不要忘记还要调用show()：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    my_window.end();
    my_window.show();
    let mut my_window2 = window::Window::new(10, 10, 380, 280, &quot;&quot;);
    my_window2.end();
    my_window2.show();
    app.run().unwrap();
}
</code></pre></pre>
<p>可以使用my_window.set_border(false)方法实现无边框窗口：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/100937639-565cdd80-3504-11eb-8cf6-e135243c38b0.png" alt="image" /></p>
<p>set_border(bool)方法是WindowExt trait的一部分，除了WidgetExt和GroupExt trait外，FLTK中的所有窗口类型都实现了它。
所有trait的列表可以在crates的prelude module中找到：</p>
<p><a href="https://docs.rs/fltk/*/fltk/prelude/index.html">文档</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="组件-widgets"><a class="header" href="#组件-widgets">组件 Widgets</a></h1>
<p>FLTK提供了大约80个窗口组件。这些组件都实现了WidgetBase和WidgetExt的基本trait集。 我们已经遇到了我们的第一个组件，Window。
正如我们在Window小组件中所看到的，小组件也可以根据其功能实现其他trait。
在我们之前写的例子中添加一个按钮：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/100937814-adfb4900-3504-11eb-8a6b-f42a4fb4e470.png" alt="image" /></p>
<p>注意，这个按钮的父组件是my_window，因为它是在begin()和end()之间创建的。
另一种添加组件的方法是，使用实现了GroupExt trait的widget所提供的add(widget)方法。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    my_window.end();
    my_window.show();

    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.add(&amp;but);

    app.run().unwrap();
}
</code></pre></pre>
<p>另一件要注意的事情是按钮的初始化，它的构造函数基本上与Window相同，这是因为它实现了WidgetBase trait。注意，虽然Window的x和y坐标是相对于屏幕的，但按钮的x和y坐标却是相对于包含按钮的窗口的。你可能已经注意到，这也适用于我们在前一页的嵌入式窗口。</p>
<p>这个按钮也实现了ButtonExt trait，它提供了一些有用的方法，比如设置快捷键来触发我们的按钮以及其他方法。</p>
<p>构建组件也可以用构建器模式来完成：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let but1 = Button::new(10, 10, 80, 40, &quot;Button 1&quot;);
// OR
let but1 = Button::default()
    .with_pos(10, 10)
    .with_size(80, 40)
    .with_label(&quot;Button 1&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>这基本上有相同的效果。</p>
<p>目前，我们的程序显示了一个带有按钮的窗口，这个按钮是可以点击的，但什么也做不了！因此，在下一页中，我们将学习为它添加一些动作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="按钮-buttons"><a class="header" href="#按钮-buttons">按钮 Buttons</a></h1>
<p>Button widgets 有多种用途和多种形式：</p>
<ul>
<li>Button</li>
<li>RadioButton</li>
<li>ToggleButton</li>
<li>RoundButton</li>
<li>CheckButton</li>
<li>LightButton</li>
<li>RepeatButton</li>
<li>RadioLightButton</li>
<li>RadioRoundButton</li>
</ul>
<p>这些可以在可以在 button module 中找到。
其中最简单的就是Button，它在用户点击时产生一些行为。当然所有的按钮都会这样：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, button::Button, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();
    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, &quot;Click me!&quot;);
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label(&quot;Hello world&quot;));

    app.run().unwrap();
}
</code></pre></pre>
<p>然而其他按钮可以带有表示自己某些属性的其他值（value）：
例如CheckButton, ToggleButton, LightButton 拥有它们当前状态（比如，是否被选中）的信息。</p>
<p>单选按钮（RadioRoundButton、RadioLightButton和RadioButton）也带有它们的一些值，但在parent group（任何实现GroupExt的widget）中只有一个可以被切换。所以这些组件是知道其他按钮的值的：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    // only one can be toggled by the user at a time, the other will be automatically untoggled
    let btn1 = button::RadioRoundButton::default().with_label(&quot;Option 1&quot;);
    let btn2 = button::RadioRoundButton::default().with_label(&quot;Option 2&quot;); 
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>(可以用clear_visible_focus()方法<code>btn1.clear_visible_focus()</code>来删除焦点框）</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145727291-8be40de6-8ec6-4e57-bb29-fa0f0ac3b251.png" alt="image" /></p>
<p>其他可切换的按钮没有这个属性。</p>
<p>你可以使用ButtonExt::value()方法查询一个按钮是否被切换：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    let btn1 = button::CheckButton::default().with_label(&quot;Option 1&quot;);
    let btn2 = button::CheckButton::default().with_label(&quot;Option 2&quot;);
    let mut btn3 = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn3.set_callback(move |btn3| {
        if btn1.value() {
            println!(&quot;btn1 is checked&quot;);
        }
        if btn2.value() {
            println!(&quot;btn1 is checked&quot;);
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p>CheckButton还提供了一个方便的方法is_checked()，而radio buttons提供了一个is_toggled()：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145727325-7e5bb45f-674e-4bb2-81c8-27d0ee391d34.png" alt="image" /></p>
<p>默认情况下，可切换的按钮在创建时是不可切换的，然而这可以用set_value()，或者方便的方法set_checked()（对CheckButton使用）和set_toggled()（对radio buttons使用）来重写：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    let mut btn1 = button::CheckButton::default().with_label(&quot;Option 1&quot;);
    btn1.set_value(true);
    // Similarly you can use btn1.set_checked(true)
    let btn2 = button::CheckButton::default().with_label(&quot;Option 2&quot;);
    let mut btn3 = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn3.set_callback(move |btn3| {
        if btn1.value() {
            println!(&quot;btn1 is checked&quot;);
        }
        if btn2.value() {
            println!(&quot;btn2 is checked&quot;);
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727352-bf6dba5c-1a0c-4da4-8296-093e10470f0c.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标签-labels"><a class="header" href="#标签-labels">标签 Labels</a></h1>
<p>FLTK没有标签widget。因此，如果你要想显示文本，你可以使用一个Frame widget并给它一个label。</p>
<p>所有widge件都可以使用::new()构造函数，或者用with_label()或set_label()来获取一个标签。</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let btn = button::Button::new(160, 200, 80, 30, &quot;Click&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>这个按钮有一个显示 &quot;点击 &quot;文字的标签。</p>
<p>同样地，我们可以使用set_label()或with_label()：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let btn = button::Button::default().with_label(&quot;Click&quot;);
// or
let mut btn = button::Button::default();
btn.set_label(&quot;Click&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>然而，::new()构造函数实际上是把一个可选的 static str 带到了这里，所以下面的代码会失败：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let label = String::from(&quot;Click&quot;); // label is not a static str
let mut btn = button::Button::new(160, 200, 80, 30, &amp;label);
<span class="boring">}
</span></code></pre></pre>
<p>在这种情况下，你应该使用<code>btn.set_label(&amp;label);</code>。原因是FLTK期望的label是<code>const char *</code> 的，这相当于Rust的<code>&amp;'static str</code>。这些字符串存在于程序的二进制代码段中。如果你反汇编一个程序，会显示所有这些静态字符串。由于这些字符串有一个静态的生命周期，FLTK默认不会存储它们。而当使用set_label()和with_label()调用FLTK的Fl_Widget::copy_label()方法时，实际上是存储字符串。</p>
<p>你也不限于文字标签，FLTK有预定义的符号，可以转换成图像。</p>
<p><img src="https://www.fltk.org/doc-1.4/symbols.png" alt="symbols" /></p>
<p>@符号后面还可以加上以下可选的 &quot;格式化 &quot;字符，其顺序和规则如下：</p>
<ul>
<li>'#'强制进行方形缩放，而不是对小部件的形状进行扭曲。</li>
<li>+[1-9]或-[1-9]将缩放比例调大或调小一点。</li>
<li>$'水平翻转符号，'%'垂直翻转符号。</li>
<li>[0-9] - 旋转45度的倍数。5'和'6'不做旋转，而其他数字则指向数字键盘上的那个键的方向。'0'，后面还有四个数字，使符号按该度数旋转。</li>
</ul>
<p>因此，如果要显示一个非常大的指向下方的箭头，你可以使用标签字符串&quot;@+92-&gt;&quot;。</p>
<p>符号和文本可以结合在一个标签中，但是符号必须在文本的开头和/或结尾处。如果文本跨越了多行，那么符号将被放大以匹配所有行的高度：</p>
<p><img src="https://www.fltk.org/doc-1.4/symbol-examples.png" alt="ex" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="组控件-group-widgets"><a class="header" href="#组控件-group-widgets">组控件 Group widgets</a></h1>
<p>这些组件包括window类型和在group module中发现的其他部件：Group，Scroll，Pack，Tile，Flex ...等等。
实现GroupExt trait的部件具有一个特点，即必须调用<code>::end()</code>方法来关闭它们：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    let _btn = Button::new(160, 200, 80, 30, &quot;Click&quot;);
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>在上面的例子中，按钮 &quot;btn &quot;的父部件将是window。
在 <code>end</code>这样的GroupExt部件后，任何在 <code>end</code> 后实例化的其他widget，将在该部件外实例化。
但这些widget仍然可以使用<code>::add(&amp;other_widget)</code>方法来添加进去（或使用<code>::insert</code>）。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    win.end();
    win.show();

    let btn = Button::new(160, 200, 80, 30, &quot;Click&quot;);
    win.add(&amp;btn);
    
    a.run().unwrap();
}
</code></pre></pre>
<p>另一个选择是重新begin该widget：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    win.end();
    win.show();

    win.begin();
    let _btn = Button::new(160, 200, 80, 30, &quot;Click&quot;);
    win.end();

    a.run().unwrap();
}
</code></pre></pre>
<p>虽然大多数GroupExt widget需要手动布局，但有几个widget具有自动布局功能。Flex widget在 <a href="Layouts.html">布局 layout</a>中会讨论。Pack需要子widget的height，这取决于Pack的方向。</p>
<p>一个vertical pack只需要知道它的子widget的height：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(200, 300);
    let mut pack = group::Pack::default_fill();
    pack.set_spacing(5);
    for i in 0..2 {
        frame::Frame::default().with_size(0, 40).with_label(&amp;format!(&quot;field {}&quot;, i));
        input::Input::default().with_size(0, 40);
    }
    frame::Frame::default().with_size(0, 40); // a filler
    button::Button::default().with_size(0, 40).with_label(&quot;Submit&quot;);
    pack.end();
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727469-a7181ebf-a3a3-4675-af23-ec40d847a593.png" alt="image" /></p>
<p>对于一个horizontal pack，我们设置Pack type，然后我们只需要传递子widget的width：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(300, 100);
    let mut pack = group::Pack::default_fill().with_type(group::PackType::Horizontal);
    pack.set_spacing(5);
    for i in 0..2 {
        frame::Frame::default().with_size(40, 0).with_label(&amp;format!(&quot;field {}&quot;, i));
        input::Input::default().with_size(40, 0);
    }
    frame::Frame::default().with_size(40, 0); // a filler
    button::Button::default().with_size(40, 0).with_label(&quot;Submit&quot;);
    pack.end();
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="菜单-menus"><a class="header" href="#菜单-menus">菜单 Menus</a></h1>
<p>FLTK中的菜单是实现MenuExt trait的widget。Menu有下面这几种类型：</p>
<ul>
<li>MenuBar</li>
<li>MenuItem</li>
<li>Choice (dropdown list)</li>
<li>SysMenuBar (MacOS上则是出现在屏幕顶部的menu bar)</li>
</ul>
<p>Menu类型主要有两个方面的功能：
1- 使用add_choice()方法添加选项，然后在callback中处理用户的选择：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default().with_size(80, 30).center_of_parent().with_label(&quot;Select item&quot;);
    choice.add_choice(&quot;Choice 1&quot;);
    choice.add_choice(&quot;Choice 2&quot;);
    choice.add_choice(&quot;Choice 3&quot;);
    // You can also simply type choice.add_choice(&quot;Choice 1|Choice 2|Choice 3&quot;);
    wind.end();
    wind.show();

    choice.set_callback(|c| {
        match c.value() {
            0 =&gt; println!(&quot;choice 1 selected&quot;),
            1 =&gt; println!(&quot;choice 2 selected&quot;),
            2 =&gt; println!(&quot;choice 3 selected&quot;),
            _ =&gt; unreachable!(),
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727397-dd713782-9f8e-474b-b009-f2ebeb5170ea.png" alt="image" /></p>
<p>另外，你也可以获取所选项目的文本内容来操作：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default().with_size(80, 30).center_of_parent().with_label(&quot;Select item&quot;);
    choice.add_choice(&quot;Choice 1|Choice 2|Choice 3&quot;);
    wind.end();
    wind.show();

    choice.set_callback(|c| {
        if let Some(choice) = c.choice() {
            match choice.as_str() {
                &quot;Choice 1&quot; =&gt; println!(&quot;choice 1 selected&quot;),
                &quot;Choice 2&quot; =&gt; println!(&quot;choice 2 selected&quot;),
                &quot;Choice 3&quot; =&gt; println!(&quot;choice 3 selected&quot;),
                _ =&gt; unreachable!(),
            }
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>2- 通过add()方法添加选项，你要明确地传递每个选项的回调：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default()
        .with_size(80, 30)
        .center_of_parent()
        .with_label(&quot;Select item&quot;);

    choice.add(
        &quot;Choice 1&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!(&quot;choice 1 selected&quot;),
    );
    choice.add(
        &quot;Choice 2&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!(&quot;choice 2 selected&quot;),
    );
    choice.add(
        &quot;Choice 3&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!(&quot;choice 3 selected&quot;),
    );

    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>另外，正如在 <a href="Events">事件 Events</a>中提到的，你可以使用一个函数对象，而不必传递闭包：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::*, prelude::*, *};

fn menu_cb(m: &amp;mut impl MenuExt) {
    if let Some(choice) = m.choice() {
        match choice.as_str() {
            &quot;New\t&quot; =&gt; println!(&quot;New&quot;),
            &quot;Open\t&quot; =&gt; println!(&quot;Open&quot;),
            &quot;Third&quot; =&gt; println!(&quot;Third&quot;),
            &quot;Quit\t&quot; =&gt; {
                println!(&quot;Quitting&quot;);
                app::quit();
            },
            _ =&gt; println!(&quot;{}&quot;, choice),
        }
    }
}

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut menubar = menu::MenuBar::new(0, 0, 400, 40, &quot;rew&quot;);
    menubar.add(&quot;File/New\t&quot;, Shortcut::None, menu::MenuFlag::Normal, menu_cb);
    menubar.add(
        &quot;File/Open\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    let idx = menubar.add(
        &quot;File/Recent&quot;,
        Shortcut::None,
        menu::MenuFlag::Submenu,
        menu_cb,
    );
    menubar.add(
        &quot;File/Recent/First\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    menubar.add(
        &quot;File/Recent/Second\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    menubar.add(
        &quot;File/Quit\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    let mut btn1 = button::Button::new(160, 150, 80, 30, &quot;Modify 1&quot;);
    let mut btn2 = button::Button::new(160, 200, 80, 30, &quot;Modify 2&quot;);
    let mut clear = button::Button::new(160, 250, 80, 30, &quot;Clear&quot;);
    win.end();
    win.show();

    btn1.set_callback({
        let menubar = menubar.clone();
        move |_| {
            if let Some(mut item) = menubar.find_item(&quot;File/Recent&quot;) {
                item.add(
                    &quot;Recent/Third&quot;,
                    Shortcut::None,
                    menu::MenuFlag::Normal,
                    menu_cb,
                );
                item.add(
                    &quot;Recent/Fourth&quot;,
                    Shortcut::None,
                    menu::MenuFlag::Normal,
                    menu_cb,
                );
            }
        }
    });

    btn2.set_callback({
        let mut menubar = menubar.clone();
        move |_| {
            menubar.add(
                &quot;File/Recent/Fifth\t&quot;,
                Shortcut::None,
                menu::MenuFlag::Normal,
                menu_cb,
            );
            menubar.add(
                &quot;File/Recent/Sixth\t&quot;,
                Shortcut::None,
                menu::MenuFlag::Normal,
                menu_cb,
            );
        }
    });

    clear.set_callback(move |_| {
        menubar.clear_submenu(idx).unwrap();
    });

    a.run().unwrap();
}
</code></pre></pre>
<p>另外，你可以使用add_emit()来传递一个sender和一个message，而不必要传递回调：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

#[derive(Clone)]
enum Message {
    Choice1,
    Choice2,
    Choice3,
}

fn main() {
    let a = app::App::default();
    let (s, r) = app::channel();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default()
        .with_size(80, 30)
        .center_of_parent()
        .with_label(&quot;Select item&quot;);

    choice.add_emit(
        &quot;Choice 1&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s.clone(),
        Message::Choice1,
    );
    choice.add_emit(
        &quot;Choice 2&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s.clone(),
        Message::Choice2,
    );
    choice.add_emit(
        &quot;Choice 3&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s,
        Message::Choice3,
    );

    wind.end();
    wind.show();

    while a.wait() {
        if let Some(msg) = r.recv() {
            match msg {
                Message::Choice1 =&gt; println!(&quot;choice 1 selected&quot;),
                Message::Choice2 =&gt; println!(&quot;choice 2 selected&quot;),
                Message::Choice3 =&gt; println!(&quot;choice 3 selected&quot;),
            }
        }
    }
}
</code></pre></pre>
<p>你可能会问，为什么我们要从第一个例子中的几行代码，转到更复杂的方式。其实每种方法都有它的用途。
对于简单的下拉widget，建议用第一种方法。对于一个程序的菜单栏，用第二种方法。它允许你指定Shortcuts和MenuFlags，并且可以更好地解耦事件，所以你不必在菜单的回调中处理一切。使用add()方法处理子菜单也更容易，就像在<a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/editor.rs">编辑器例子</a>中那样：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let mut menu = menu::SysMenuBar::default().with_size(800, 35);
        menu.set_frame(FrameType::FlatBox);
        menu.add_emit(
            &quot;&amp;File/New...\t&quot;,
            Shortcut::Ctrl | 'n',
            menu::MenuFlag::Normal,
            *s,
            Message::New,
        );

        menu.add_emit(
            &quot;&amp;File/Open...\t&quot;,
            Shortcut::Ctrl | 'o',
            menu::MenuFlag::Normal,
            *s,
            Message::Open,
        );

        menu.add_emit(
            &quot;&amp;File/Save\t&quot;,
            Shortcut::Ctrl | 's',
            menu::MenuFlag::Normal,
            *s,
            Message::Save,
        );

        menu.add_emit(
            &quot;&amp;File/Save as...\t&quot;,
            Shortcut::Ctrl | 'w',
            menu::MenuFlag::Normal,
            *s,
            Message::SaveAs,
        );

        menu.add_emit(
            &quot;&amp;File/Print...\t&quot;,
            Shortcut::Ctrl | 'p',
            menu::MenuFlag::MenuDivider,
            *s,
            Message::Print,
        );

        menu.add_emit(
            &quot;&amp;File/Quit\t&quot;,
            Shortcut::Ctrl | 'q',
            menu::MenuFlag::Normal,
            *s,
            Message::Quit,
        );

        menu.add_emit(
            &quot;&amp;Edit/Cut\t&quot;,
            Shortcut::Ctrl | 'x',
            menu::MenuFlag::Normal,
            *s,
            Message::Cut,
        );

        menu.add_emit(
            &quot;&amp;Edit/Copy\t&quot;,
            Shortcut::Ctrl | 'c',
            menu::MenuFlag::Normal,
            *s,
            Message::Copy,
        );

        menu.add_emit(
            &quot;&amp;Edit/Paste\t&quot;,
            Shortcut::Ctrl | 'v',
            menu::MenuFlag::Normal,
            *s,
            Message::Paste,
        );

        menu.add_emit(
            &quot;&amp;Help/About\t&quot;,
            Shortcut::None,
            menu::MenuFlag::Normal,
            *s,
            Message::About,
        );

        if let Some(mut item) = menu.find_item(&quot;&amp;File/Quit\t&quot;) {
            item.set_label_color(Color::Red);
        }
<span class="boring">}
</span></code></pre></pre>
<p>注意到最后一个调用，它使用find_item()在menu中找到一个item，然后我们将其标签颜色设置为红色：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145727434-d66c6d55-018d-4341-9570-7c2864b5bf29.png" alt="image" /></p>
<h2 id="系统菜单栏"><a class="header" href="#系统菜单栏">系统菜单栏</a></h2>
<p>在MacOS上，你可能更喜欢使用系统菜单栏，它通常出现在屏幕的顶部。为此，你可以使用一个SysMenuBar widget。它与所有实现MenuExt trait的widget具有相同的api，当程序为MacOS以外的其他目标平台编译时，它将转化为一个普通的MenuBar。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="输入输出-input--output"><a class="header" href="#输入输出-input--output">输入输出 Input &amp; Output</a></h1>
<p>输入和输出 widget 实现了InputExt trait。在input&amp;output modules中还可以找到这些：</p>
<ul>
<li>Input</li>
<li>IntInput</li>
<li>FloatInput</li>
<li>MultilineInput</li>
<li>SecretInput</li>
<li>FileInput</li>
<li>Output</li>
<li>MultilineOutput</li>
</ul>
<p>这种trait的特点是，这些widget会带有一个文本值，可以用value()方法查询，用set_value()方法改变：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 100).column().center_of_parent();
    let label = frame::Frame::default().with_label(&quot;Enter age&quot;);
    let input = input::IntInput::default();
    let mut btn = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn.set_callback(move |btn| {
        println!(&quot;your age is {}&quot;, input.value());
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727249-2fa4d384-2bd3-41fd-bbae-61a3a33b12f6.png" alt="image" /></p>
<p>请注意，我们使用了一个IntInput来限制输入整数值。虽然用户不能输入字符串，但就开发者而言，value()的返回值仍然是一个String。</p>
<p>输出部件不允许用户修改其数值：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(200, 50).column().center_of_parent();
    let label = frame::Frame::default().with_label(&quot;Check this text:&quot;);
    let mut output = output::Output::default();
    output.set_value(&quot;You can't edit this!&quot;);
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727261-88ec533f-200b-4df7-a570-76ebd2ba520a.png" alt="image" /></p>
<p>输入部件也可以使用 InputExt::set_readonly(bool) 方法变成只读：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 100).column().center_of_parent();
    let label = frame::Frame::default().with_label(&quot;Enter age&quot;);
    let mut input = input::IntInput::default();
    let mut btn = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn.set_callback(move |btn| {
        println!(&quot;your age is {}&quot;, input.value());
        input.set_readonly(true);
    });

    a.run().unwrap();
}
</code></pre></pre>
<p>这使我们的输入在用户点击按钮后成为只读。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="估值器-valuators"><a class="header" href="#估值器-valuators">估值器 Valuators</a></h1>
<p>估值器widget实现了ValuatorExt trait。这些widget跟踪（以图形和内部方式）跟踪steps，ranges和bounds。
你可能熟悉滚动条和滑块（scrollbars and sliders）这种估值器。可以在valuator模块中找到fltk提供的这些估值器：</p>
<ul>
<li>Slider</li>
<li>NiceSlider</li>
<li>ValueSlider</li>
<li>Dial</li>
<li>LineDial</li>
<li>Counter</li>
<li>Scrollbar</li>
<li>Roller</li>
<li>Adjuster</li>
<li>ValueInput</li>
<li>ValueOutput</li>
<li>FillSlider</li>
<li>FillDial</li>
<li>HorSlider (Horizontal slider)</li>
<li>HorFillSlider</li>
<li>HorNiceSlider</li>
<li>HorValueSlider</li>
</ul>
<p>在gui中改变valuator的值会触发其回调。Valuator的当前值可以通过value()方法来查询。它也可以用set_value()来为它设置一个值。range和step也可以根据你的使用情况进行查询和改变：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut slider = valuator::HorNiceSlider::default().with_size(400, 20).center_of_parent();
    slider.set_minimum(0.);
    slider.set_maximum(100.);
    slider.set_step(1., 1); // 每一step增长10
    slider.set_value(50.); // 从中间开始
    win.end();
    win.show();

    slider.set_callback(|s| {
        println!(&quot;slider at {}&quot;, s.value());
    });
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727188-4ac06d45-7fd1-44f7-9adc-366d9bb79d8f.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文字-text"><a class="header" href="#文字-text">文字 Text</a></h1>
<p>Text widget实现了DisplayExt trait，共有3个，可以在text module中找到：</p>
<ul>
<li>TextDisplay</li>
<li>TextEditor</li>
<li>SimpleTerminal</li>
</ul>
<p>这些部件的主要目的是显示/编辑文本。前两个部件需要一个TextBuffer，而SimpleTerminal有一个内部缓冲器：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextEditor::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf.clone());
    win.end();
    win.show();

    buf.set_text(&quot;Hello world!&quot;);
    buf.append(&quot;\n&quot;);
    buf.append(&quot;This is a text editor!&quot;);

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727101-175fe355-1383-4789-ae40-2945ef0c63e2.png" alt="image" /></p>
<p>大多数操作是通过TextBuffer完成的。可以用append()来追加文本，也可以用set_text()来设置其全部内容。
你可以使用DisplayExt::buffer()方法取回缓冲区的clone（reference type）：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let buf = text::TextBuffer::default();

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextEditor::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf);
    win.end();
    win.show();

    let mut my_buf = txt.buffer().unwrap();

    my_buf.set_text(&quot;Hello world!&quot;);
    my_buf.append(&quot;\n&quot;);
    my_buf.append(&quot;This is a text editor!&quot;);

    a.run().unwrap();
}
</code></pre></pre>
<p>DisplayExt提供了其他方法来管理文本属性，wrapping，cursor position，font，color，size...等。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::Color, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();
    buf.set_text(&quot;Hello world!&quot;);
    buf.append(&quot;\n&quot;);
    buf.append(&quot;This is a text editor!&quot;);

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextDisplay::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf);
    txt.wrap_mode(text::WrapMode::AtBounds, 0); // bounds don't require the second argument, unlike AtPixel and AtColumn
    txt.set_text_color(Color::Red);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727121-8396c77e-836d-4406-abd1-92af32ff7242.png" alt="image" /></p>
<p>TextBuffer还有第二个用途，那就是提供一个样式缓冲区（style buffer）。样式缓冲区反映了你的文本缓冲区，并使用一个样式表（包含字体、颜色和大小）来为你的文本添加细粒度的样式，样式表本身是有索引的，具体说是使用相应的字母：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    enums::{Color, Font},
    prelude::*,
    *,
};

const STYLES: &amp;[text::StyleTableEntry] = &amp;[
    text::StyleTableEntry {
        color: Color::Green,
        font: Font::Courier,
        size: 16,
    },
    text::StyleTableEntry {
        color: Color::Red,
        font: Font::Courier,
        size: 16,
    },
    text::StyleTableEntry {
        color: Color::from_u32(0x8000ff),
        font: Font::Courier,
        size: 16,
    },
];

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();
    let mut sbuf = text::TextBuffer::default();
    buf.set_text(&quot;Hello world!&quot;);
    sbuf.set_text(&amp;&quot;A&quot;.repeat(&quot;Hello world!&quot;.len())); // A represents the first entry in the table, repeated for every letter
    buf.append(&quot;\n&quot;); 
    sbuf.append(&quot;B&quot;); // Although a new line and the style might not apply, but it's needed to avoid messing out subsequent entries
    buf.append(&quot;This is a text editor!&quot;);
    sbuf.append(&amp;&quot;C&quot;.repeat(&quot;This is a text editor!&quot;.len()));

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextDisplay::default()
        .with_size(390, 290)
        .center_of_parent();
    txt.set_buffer(buf);
    txt.set_highlight_data(sbuf, STYLES.to_vec());
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727157-be992344-763d-41f9-b3d8-2dfa13fbaab1.png" alt="image" /></p>
<p>Terminal的例子使用了SimpleTerminal和一个有样式的TextBuffer，你可以在 <a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/terminal.rs">这儿</a> 找到</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阅览器-browsers"><a class="header" href="#阅览器-browsers">阅览器 Browsers</a></h1>
<p>Browser widgets 实现了 BrowserExt trait：</p>
<ul>
<li>Browser</li>
<li>SelectBrowser</li>
<li>HoldBrowser</li>
<li>MultiBrowser</li>
<li>FileBrowser</li>
<li>CheckBrowser</li>
</ul>
<p>这些可以在 browser module中找到。</p>
<p>为了实例化一个browser，需要提供每一项的列宽column widths，以及在add()方法中用于将item分成几列的分隔符column char：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default().with_size(900, 300);
    let mut b = browser::Browser::new(10, 10, 900 - 20, 300 - 20, &quot;&quot;);
    let widths = &amp;[50, 50, 50, 70, 70, 40, 40, 70, 70, 50];
    b.set_column_widths(widths);
    b.set_column_char('\t');
    // we can now use the '\t' char in our add method.
    b.add(&quot;USER\tPID\t%CPU\t%MEM\tVSZ\tRSS\tTTY\tSTAT\tSTART\tTIME\tCOMMAND&quot;);
    b.add(&quot;root\t2888\t0.0\t0.0\t1352\t0\ttty3\tSW\tAug15\t0:00\t@b@f/sbin/mingetty tty3&quot;);
    b.add(&quot;erco\t2889\t0.0\t13.0\t221352\t0\ttty3\tR\tAug15\t1:34\t@b@f/usr/local/bin/render a35 0004&quot;);
    b.add(&quot;uucp\t2892\t0.0\t0.0\t1352\t0\tttyS0\tSW\tAug15\t0:00\t@b@f/sbin/agetty -h 19200 ttyS0 vt100&quot;);
    b.add(&quot;root\t13115\t0.0\t0.0\t1352\t0\ttty2\tSW\tAug30\t0:00\t@b@f/sbin/mingetty tty2&quot;);
    b.add(
        &quot;root\t13464\t0.0\t0.0\t1352\t0\ttty1\tSW\tAug30\t0:00\t@b@f/sbin/mingetty tty1 --noclear&quot;,
    );
    win.end();
    win.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145733437-e3061015-12fa-4f2e-a1e3-01f59c4b189d.png" alt="image" /></p>
<p>可以使用特殊字符<code>@</code>来实现其他丰富的格式化效果，我们需要后面跟一个格式化指定符：</p>
<ul>
<li>'@.' 打印其余行，且不会再寻找其他的'@'符号</li>
<li>'@@' 打印其余以'@'开头的行</li>
<li>'@l'  使用大号字体(24 point) </li>
<li>'@m' 使用中号字体(18 point)</li>
<li>'@s' 使用小号字体(11 point)</li>
<li>'@b' 使用宽字体(adds FL_BOLD to font)</li>
<li>'@i' 使用斜体(adds FL_ITALIC to font)</li>
<li>'@f' 或 '@t' 使用等距字体 (sets font to FL_COURIER)</li>
<li>'@c' 水平居中</li>
<li>'@r' 向右对齐文本</li>
<li>'@B0', '@B1', ... '@B255' 使用fl_color(n)填充背景</li>
<li>'@C0', '@C1', ... '@C255' 使用fl_color(n) 渲染文本</li>
<li>'@F0', '@F1', ... 使用 fl_font(n) 渲染文本</li>
<li>'@S1', '@S2', ... 使用相应的尺寸来渲染文本</li>
<li>'@u' or '@_' 字体添加下划线</li>
<li>'@-' 字体中间添加修改线</li>
</ul>
<p>在下面的例子中，我们在%CPU前面加上@C88，将其渲染成红色：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default().with_size(900, 300);
    let mut b = browser::Browser::new(10, 10, 900 - 20, 300 - 20, &quot;&quot;);
    let widths = &amp;[50, 50, 50, 70, 70, 40, 40, 70, 70, 50];
    b.set_column_widths(widths);
    b.set_column_char('\t');
    b.add(&quot;USER\tPID\t@C88%CPU\t%MEM\tVSZ\tRSS\tTTY\tSTAT\tSTART\tTIME\tCOMMAND&quot;);
    win.end();
    win.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145733713-2fe3207d-25f7-4acd-ae91-754679c5696a.png" alt="image" /></p>
<p>这些颜色遵循FLTK的颜色映射，可以从0到255进行索引。</p>
<p><img src="https://www.fltk.org/doc-1.4/fltk-colormap.png" alt="colormap" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树-trees"><a class="header" href="#树-trees">树 Trees</a></h1>
<p>Tree widgets 让你可以以树状的形式显示一些元素。这里并没有 tree trait，所有方法来自 Tree type。可以使用add方法添加元素：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726958-f1f2a095-39c5-496f-b772-18d024dd609d.png" alt="image" /></p>
<p>子项目可以使用正斜线分隔符来添加：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727026-bfcff44f-2b01-4679-937b-3e7d441dfdf0.png" alt="image" /></p>
<p>如果你试试上面的代码，你会发现根项标签总是 &quot;ROOT &quot;。可以通过set_root_label()方法来改变根标签：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_root_label(&quot;My Tree&quot;);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727045-a25be6bc-a514-4b4a-b7b9-0a7ee2e359b4.png" alt="image" /></p>
<p>甚至可以使用set_show_root(false)方法隐藏根标签。</p>
<p>树中的元素可以使用first_selected_item()方法进行查询：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_show_root(false);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(item) = t.first_selected_item() {
            println!(&quot;{} selected&quot;, item.label().unwrap());
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727072-8596cf09-100c-4cb6-a427-0d3c66702b39.png" alt="image" /></p>
<p>目前我们的树只允许单选，让我们把它改成多选（我们也要改变连接器connecter的样式）：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_select_mode(tree::TreeSelect::Multi);
    tree.set_connector_style(tree::TreeConnectorStyle::Solid);
    tree.set_connector_color(enums::Color::Red.inactive());
    tree.set_show_root(false);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(item) = t.first_selected_item() {
            println!(&quot;{} selected&quot;, item.label().unwrap());
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p>现在的问题是，我们需要得到所有的选项，而不只是第一个被选中的项目，这里我们使用get_selected_items()方法，该方法返回一个可选的Vec，而不是只得到标签，我们将得到item的整个路径。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_select_mode(tree::TreeSelect::Multi);
    tree.set_connector_style(tree::TreeConnectorStyle::Solid);
    tree.set_connector_color(enums::Color::Red.inactive());
    tree.set_show_root(false);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(items) = t.get_selected_items() {
            for i in items {
                println!(&quot;{} selected&quot;, t.item_pathname(&amp;i).unwrap());
            }
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727000-4b881896-309d-465d-8305-9a7e0a92eaea.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表格-tables"><a class="header" href="#表格-tables">表格 Tables</a></h1>
<p>fltk提供了table widget，其使用代码可以在例子中找到。然而，使用<a href="https://crates.io/crates/fltk-table">fltk-table crate</a>将需要更少的模板代码，并且还提供了一个更简单、更直观的界面。</p>
<pre><pre class="playground"><code class="language-rust edition2018">extern crate fltk_table;

use fltk::{
    app, enums,
    prelude::{GroupExt, WidgetExt},
    window,
};
use fltk_table::{SmartTable, TableOpts};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut wind = window::Window::default().with_size(800, 600);

    /// 我们通过 TableOpts 域传递行和列
    let mut table = SmartTable::default()
    .with_size(790, 590)
    .center_of_parent()
    .with_opts(TableOpts {
        rows: 30,
        cols: 15,
        editable: true,
        ..Default::default()
    });
    
    wind.end();
    wind.show();

    // 用一些值填充
    for i in 0..30 {
        for j in 0..15 {
            table.set_cell_value(i, j, &amp;(i + j).to_string());
        }
    }

    // 把行列为4，5的单元设置为&quot;another&quot;, 注意索引是从0开始的
    table.set_cell_value(3, 4, &quot;another&quot;);

    assert_eq!(table.cell_value(3, 4), &quot;another&quot;);

    // 防治点击空格键的时候关闭窗口
    wind.set_callback(move |_| {
        if app::event() == enums::Event::Close {
            app.quit();
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-table/raw/HEAD/screenshots/styled.jpg" alt="fltk-table" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义组件-custom-widgets"><a class="header" href="#自定义组件-custom-widgets">自定义组件 Custom widgets</a></h1>
<p>fltk-rs允许你创建自定义widget。我们需要定义一个struct，它需要扩展一个已经存在的widget和widget type。最基本的widget type是widget::Widget。
1- 定义你的struct和任何其他需要存储在其中的内部数据：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, *};
use std::cell::RefCell;
use std::rc::Rc;

struct MyCustomButton {
    inner: widget::Widget,
    num_clicks: Rc&lt;RefCell&lt;i32&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>你会注意到两件事，我们正在使用一个Rc RefCell来存储数据。这在一般情况下是没有必要的，但是，由于我们需要将这些数据所有权move到一个回调中，同时在我们修改它之后仍然可以访问它，我们将把它包装在一个Rc RefCell中。我们已经导入了必要的模块。</p>
<p>2- 定义结构的impl。其中最重要的是构造函数，因为我们要通过它来初始化内部数据：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyCustomButton {
    // 我们定义的结构体
    pub fn new(radius: i32, label: &amp;str) -&gt; Self {
        let mut inner = widget::Widget::default()
            .with_size(radius * 2, radius * 2)
            .with_label(label)
            .center_of_parent();
        inner.set_frame(enums::FrameType::OFlatBox);
        let num_clicks = 0;
        let num_clicks = Rc::from(RefCell::from(num_clicks));
        let clicks = num_clicks.clone();
        inner.draw(|i| { // 我们需要一个绘图的实现 draw implementation
            draw::draw_box(i.frame(), i.x(), i.y(), i.w(), i.h(), i.color());
            draw::set_draw_color(enums::Color::Black); // 设置文字颜色
            draw::set_font(enums::Font::Helvetica, app::font_size());
            draw::draw_text2(&amp;i.label(), i.x(), i.y(), i.w(), i.h(), i.align());
        });
        inner.handle(move |i, ev| match ev {
            enums::Event::Push =&gt; {
                *clicks.borrow_mut() += 1; // 递增 num_clicks
                i.do_callback(); // 使用 set_callback() 时设置的回调
                true
            }
            _ =&gt; false,
        });
        Self {
            inner,
            num_clicks,
        }
    }

    // 获得我们的按钮被点击的次数
    pub fn num_clicks(&amp;self) -&gt; i32 {
        *self.num_clicks.borrow()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>3- 对我们的struct应用widget_extends！宏，该宏需要基本类型，已经我们通过该成员扩展的自定义类型。这是通过实现Deref和DerefMut trait实现的。该宏还添加了其他方便的构造函数和锚定方法（anchoring methods）：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 通过成员`inner`扩展widget::Widget，并添加其他初始化器和构造函数
widget_extends!(MyCustomButton, widget::Widget, inner);
<span class="boring">}
</span></code></pre></pre>
<p>现在来试一试我们的struct：</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    app::background(255, 255, 255); // 设置白色背景
    let mut wind = window::Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);
    
    let mut btn = MyCustomButton::new(50, &quot;Click&quot;);
    // 注意，set_color和set_callback已经自动为我们实现了
    btn.set_color(enums::Color::Cyan);
    btn.set_callback(|_| println!(&quot;Clicked&quot;));
    
    wind.end();
    wind.show();

    app.run().unwrap();
    
    // 打印我们的按钮被点击的数字，退出
    println!(&quot;Our button was clicked {} times&quot;, btn.num_clicks());
}
</code></pre></pre>
<p>全部代码：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};
use std::cell::RefCell;
use std::rc::Rc;

struct MyCustomButton {
    inner: widget::Widget,
    num_clicks: Rc&lt;RefCell&lt;i32&gt;&gt;,
}

impl MyCustomButton {
    // 我们定义的结构体
    pub fn new(radius: i32, label: &amp;str) -&gt; Self {
        let mut inner = widget::Widget::default()
            .with_size(radius * 2, radius * 2)
            .with_label(label)
            .center_of_parent();
        inner.set_frame(enums::FrameType::OFlatBox);
        let num_clicks = 0;
        let num_clicks = Rc::from(RefCell::from(num_clicks));
        let clicks = num_clicks.clone();
        inner.draw(|i| { // 我们需要一个绘图的实现 draw implementation
            draw::draw_box(i.frame(), i.x(), i.y(), i.w(), i.h(), i.color());
            draw::set_draw_color(enums::Color::Black); // 设置文字颜色
            draw::set_font(enums::Font::Helvetica, app::font_size());
            draw::draw_text2(&amp;i.label(), i.x(), i.y(), i.w(), i.h(), i.align());
        });
        inner.handle(move |i, ev| match ev {
            enums::Event::Push =&gt; {
                *clicks.borrow_mut() += 1; // 递增 num_clicks
                i.do_callback(); // 使用 set_callback() 时设置的回调
                true
            }
            _ =&gt; false,
        });
        Self {
            inner,
            num_clicks,
        }
    }

    // 获得我们的按钮被点击的次数
    pub fn num_clicks(&amp;self) -&gt; i32 {
        *self.num_clicks.borrow()
    }
}

// 通过成员`inner`扩展widget::Widget，并添加其他初始化器和构造函数
widget_extends!(MyCustomButton, widget::Widget, inner);

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    app::background(255, 255, 255); // 设置白色背景
    let mut wind = window::Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);
    let mut btn = MyCustomButton::new(50, &quot;Click&quot;);
    btn.set_color(enums::Color::Cyan);
    btn.set_callback(|_| println!(&quot;Clicked&quot;));
    wind.end();
    wind.show();

    app.run().unwrap();
    
    // 打印我们的按钮被点击的数字，退出
    println!(&quot;Our button was clicked {} times&quot;, btn.num_clicks());
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727718-fd0ee71f-f0c2-4438-a038-9b6950638a35.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="对话框-dialogs"><a class="header" href="#对话框-dialogs">对话框 Dialogs</a></h1>
<p>fltk提供了几种对话框类型，有文件对话框和其他一些。</p>
<h2 id="文件对话框-file-dialogs"><a class="header" href="#文件对话框-file-dialogs">文件对话框 File dialogs</a></h2>
<p>有2种类型，原生文件对话框和FLTK自己的文件对话框。原生对话框只是显示操作系统自己的对话框。对于windows来说，那是win32对话框，对于MacOS来说，那是Cocoa对话框，而对于其他posix系统来说，取决于你正在运行什么。在GNOME和其他基于gtk的桌面上，它显示gtk对话框，在KDE上它显示kdialog。</p>
<h3 id="原生对话框-native-dialogs"><a class="header" href="#原生对话框-native-dialogs">原生对话框 Native dialogs</a></h3>
<p>唤起一个原生对话框：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(80, 30)
        .with_label(&quot;Select file&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseFile);
        dialog.show();
        println!(&quot;{:?}&quot;, dialog.filename());
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/146625105-94b11a5d-0938-4962-96d1-aaff5424ffe8.png" alt="image" /></p>
<p>这将打印出所选文件的路径。有几种类型可以作为NativeFileChooserType被传递，这里我们浏览文件，你可以选择BrowseDir来代替，也可以启用多文件/目录选择。如果你选择了多个文件，你可以使用filenames()方法得到一个Vec：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Select files&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseMultiFile);
        dialog.show();
        println!(&quot;{:?}&quot;, dialog.filenames());
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>你也可以选择添加过滤器来有选择地选取文件：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseMultiFile);
        dialog.set_filter(&quot;*.{txt,rs,toml}&quot;);
        dialog.show();
        println!(&quot;{:?}&quot;, dialog.filenames());
    });
<span class="boring">}
</span></code></pre></pre>
<p>这将只显示.txt、.rs和.toml文件。</p>
<h3 id="fltl提供的文件选择器-fltks-own-file-chooser"><a class="header" href="#fltl提供的文件选择器-fltks-own-file-chooser">FLTL提供的文件选择器 FLTK's own file chooser</a></h3>
<p>FLTK也提供了自己的文件选择器：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Select file&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::FileChooser::new(
            /*start dir*/ &quot;.&quot;,
            /*pattern*/ &quot;*.{txt,rs,toml}&quot;,
            /*type*/ dialog::FileChooserType::Multi,
            /*title*/ &quot;Select file:&quot;,
        );
        dialog.show();
        while dialog.shown() {
            app::wait();
        }
        if dialog.count() &gt; 1 {
            for i in 1..=dialog.count() { // values start at 1
                println!(&quot; VALUE[{}]: '{}'&quot;, i, dialog.value(i).unwrap());
            }
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726912-600e4c58-32b7-4a1b-8e6a-44e640549722.png" alt="image" /></p>
<p>用file_chooser()和dir_chooser()函数提供了一个方便的函数：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Select file&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let file = dialog::file_chooser(
            &quot;Choose File&quot;,
            &quot;*.rs&quot;,
            /*start dir*/ &quot;.&quot;,
            /*relative*/ true,
        );
        if let Some(file) = file {
            println!(&quot;{}&quot;, file);
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<h3 id="帮助对话框-help-dialog"><a class="header" href="#帮助对话框-help-dialog">帮助对话框 Help dialog</a></h3>
<p>FLTK提供了一个帮助对话框，可以显示html 2文档：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut help = dialog::HelpDialog::new(100, 100, 400, 300);
        help.set_value(&quot;&lt;h2&gt;Hello world&lt;/h2&gt;&quot;); // this takes html
        help.show();
        while help.shown() {
            app::wait();
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>html文件也可以用HelpDialog::load(path_to_html_file)方法加载：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145726889-442d0453-e1d0-4b41-8717-f121fdf860fa.png" alt="image" /></p>
<h3 id="提示对话框-alert-dialogs"><a class="header" href="#提示对话框-alert-dialogs">提示对话框 Alert dialogs</a></h3>
<p>FLTK还提供了几种对话框类型，可以使用自由函数方便地显示：</p>
<ul>
<li>message</li>
<li>alert</li>
<li>choice</li>
<li>input</li>
<li>password (类似于input，但不显示输入内容)</li>
</ul>
<p>显示一个简单的message对话框：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        dialog::message_default(&quot;Message&quot;);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>这将在默认的位置（基本上在指针附近）显示一个message。如果你想手动输入坐标，你可以使用 message() 函数：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    btn.set_callback(|_| {
        dialog::message(100, 100, &quot;Message&quot;);
    });
<span class="boring">}
</span></code></pre></pre>
<p>前面提到的所有函数都有变体，一个有_default()后缀，不需要坐标，另一个没有，需要坐标。
有些对话框会返回一个值，比如choice，input，and password。input和password返回输入的文本，而choice则返回选择值的索引：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        // 密码和输入也需要第二个参数，这是默认值
        let pass = dialog::password_default(&quot;Enter password:&quot;, &quot;&quot;);
        if let Some(pass) = pass {
            println!(&quot;{}&quot;, pass);
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726850-61fc17e4-cd6e-4821-a9b5-396203806066.png" alt="image" /></p>
<p>使用choice的一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let choice = dialog::choice_default(&quot;Would you like to save&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Cancel&quot;);
        println!(&quot;{}&quot;, choice);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>这将打印索引，即选择No将打印0，Yes将打印1，Cancel将打印2。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145726775-d000a807-8bf5-439b-a991-8bf25fcd5049.png" alt="image" /></p>
<p>你已经注意到，所有这些对话框都没有一个。你也可以在对话框前调用函数来添加一个title：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        dialog::message_title(&quot;Exit!&quot;);
        let choice = dialog::choice_default(&quot;Would you like to save&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Cancel&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>你也可以使用 dialog::message_title_default() 来设置所有这些对话框的默认标题，你要在你的程序的开始部分这样做：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    dialog::message_title_default(&quot;My App!&quot;);
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let choice = dialog::choice_default(&quot;Would you like to save&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Cancel&quot;);
        println!(&quot;{}&quot;, choice);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726685-f086bde2-db63-4fa8-a579-954dbacbe44d.png" alt="image" /></p>
<h2 id="自定义对话框-custom-dialogs"><a class="header" href="#自定义对话框-custom-dialogs">自定义对话框 Custom dialogs</a></h2>
<p>所有这些对话框与你的程序设想的样子可能不相符合，特别是关于颜色和字体。如果你有一个深度定制的程序，你可能也会想要定制对话框。对话框基本上是一个在应用程序中生成的模式窗口。它可以与你的应用程序的其他部分具有相同的风格：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app, button,
    enums::{Color, Font, FrameType},
    frame, group, input,
    prelude::*,
    window,
};

fn style_button(btn: &amp;mut button::Button) {
    btn.set_color(Color::Cyan);
    btn.set_frame(FrameType::RFlatBox);
    btn.clear_visible_focus();
}

pub fn show_dialog() -&gt; MyDialog {
    MyDialog::default()
}

pub struct MyDialog {
    inp: input::Input,
}

impl MyDialog {
    pub fn default() -&gt; Self {
        let mut win = window::Window::default()
            .with_size(400, 100)
            .with_label(&quot;My Dialog&quot;);
        win.set_color(Color::from_rgb(240, 240, 240));
        let mut pack = group::Pack::default()
            .with_size(300, 30)
            .center_of_parent()
            .with_type(group::PackType::Horizontal);
        pack.set_spacing(20);
        frame::Frame::default()
            .with_size(80, 0)
            .with_label(&quot;Enter name:&quot;);
        let mut inp = input::Input::default().with_size(100, 0);
        inp.set_frame(FrameType::FlatBox);
        let mut ok = button::Button::default().with_size(80, 0).with_label(&quot;Ok&quot;);
        style_button(&amp;mut ok);
        pack.end();
        win.end();
        win.make_modal(true);
        win.show();
        ok.set_callback({
            let mut win = win.clone();
            move |_| {
                win.hide();
            }
        });
        while win.shown() {
            app::wait();
        }
        Self { inp }
    }
    pub fn value(&amp;self) -&gt; String {
        self.inp.value()
    }
}

fn main() {
    let a = app::App::default();
    app::set_font(Font::Times);
    let mut win = window::Window::default().with_size(600, 400);
    win.set_color(Color::from_rgb(240, 240, 240));
    let mut btn = button::Button::default()
        .with_size(80, 30)
        .with_label(&quot;Click&quot;)
        .center_of_parent();
    style_button(&amp;mut btn);
    let mut frame = frame::Frame::new(btn.x() - 40, btn.y() - 100, btn.w() + 80, 30, None);
    frame.set_frame(FrameType::BorderBox);
    frame.set_color(Color::Red.inactive());
    win.end();
    win.show();
    btn.set_callback(move |_| {
        let d = show_dialog();
        frame.set_label(&amp;d.value());
    });
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726727-a0018457-1d87-4519-9d6e-08d8f8030d1a.png" alt="image" /></p>
<h2 id="打印机话框-printer-dialog"><a class="header" href="#打印机话框-printer-dialog">打印机话框 Printer dialog</a></h2>
<p>FLTK还提供了一个打印机对话框，它使用你的系统平台的本地打印机对话框：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, *};
let mut but = button::Button::default();
but.set_callback(|widget| {
    let mut printer = printer::Printer::default();
    if printer.begin_job(1).is_ok() {
        printer.begin_page().ok();
        let (width, height) = printer.printable_rect();
        draw::set_draw_color(enums::Color::Black);
        draw::set_line_style(draw::LineStyle::Solid, 2);
        draw::draw_rect(0, 0, width, height);
        draw::set_font(enums::Font::Courier, 12);
        printer.set_origin(width / 2, height / 2);
        printer.print_widget(widget, -widget.width() / 2, -widget.height() / 2);
        printer.end_page().ok();
        printer.end_job();
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>这里只是打印按钮的图像并指定它在纸上显示的位置。你可以传递任何widget（主要是像TextEditor widget）作为打印widget。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="images"><a class="header" href="#images">Images</a></h1>
<p>FLTK supports vector and raster graphics, and out of the box offers several image types, namely:</p>
<ul>
<li>BmpImage</li>
<li>JpegImage</li>
<li>GifImage</li>
<li>PngImage</li>
<li>SvgImage</li>
<li>Pixmap</li>
<li>RgbImage</li>
<li>XpmImage</li>
<li>XbmImage</li>
<li>PnmImage</li>
</ul>
<p>It also defines 2 more helper types:</p>
<ul>
<li>SharedImage: which wraps all the previous types so you don't need to specify the image type.</li>
<li>TiledImage: which offers a tiled image of any of the concrete types.</li>
</ul>
<p>Image types implement the ImageExt trait which offers methods to allow scaling, and retrieving image metadata. 
Images can be constructed by passing a path to the image's load() constructor, or for some types, by using a from_data() constructor which accepts image data.</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Takes a path
let image = image::SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();

/// Takes data
let image= image::SvgImage::from_data(&amp;data).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Images can be used with widgets either via the WidgetExt::set_image()/set_image_scaled() or set_deimage()/set_deimage_scaled() (for deactivated/grayed image):</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();
    image.scale(200, 200, true, true);
    frame.set_image(Some(image));

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>Or via WidgetExt::draw() method:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();
    frame.draw(move |f| {
        image.scale(f.w(), f.h(), true, true);
        image.draw(f.x() + 40, f.y(), f.w(), f.h());
    });

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/hello.jpg" alt="svg" /></p>
<p>Using images in your app for icons and backgrounds also helps in giving your app its style.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>In the previously mentioned examples, you have seen callbacks mostly, and although that is one way of handling events, FLTK offers multiple ways to handle events:</p>
<ul>
<li>We can use the set_callback() method, which is automatically triggered with a click to our button.</li>
<li>We can use the handle() method for fine-grained event handling.</li>
<li>We can use the emit() method which takes a sender and a message, this allows us to handle events in the event loop.</li>
<li>We can define our own event, which can be handled within another widget's handle method.</li>
</ul>
<h3 id="setting-the-callback"><a class="header" href="#setting-the-callback">Setting the callback</a></h3>
<p>Part of the WidgetExt trait is the set_callback method:</p>
<h4 id="using-closures"><a class="header" href="#using-closures">Using closures</a></h4>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(|_| println!(&quot;The button was clicked!&quot;));
    app.run().unwrap();
}
</code></pre></pre>
<p>The capture argument is the <code>&amp;mut Self</code> of the widget for which the callback is set:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(|b| b.set_label(&quot;Clicked!&quot;));
    app.run().unwrap();
}
</code></pre></pre>
<p>The set_callback() methods have default triggers varying by the type of the widget. For buttons it's clicking or pressing enter when the button has focus.
This can be changed using the set_trigger() method. For buttons this might not make much sense, however for input widgets, the trigger can be set to &quot;CallbackTrigger::Changed&quot; and this will cause changes in the input widget to trigger the callback.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut inp = input::Input::default()
        .with_size(160, 30)
        .center_of_parent();
    win.end();
    win.show();
    inp.set_trigger(enums::CallbackTrigger::Changed);
    inp.set_callback(|i| println!(&quot;{}&quot;, i.value()));
    a.run().unwrap();
}
</code></pre></pre>
<p>This will print on every character input by the user.</p>
<p>The advanatage of using closures is the ability to &quot;close&quot; on scope arguments, i.e. you can also pass variables from the surrounding scope into the closure:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(move |_| {
        my_window.set_label(&quot;button was pressed&quot;);
    });
    app.run().unwrap();
}
</code></pre></pre>
<p>You will notice in the <a href="Menus">Menus section</a> that the handling is done on a per MenuItem basis.</p>
<h4 id="using-function-objects"><a class="header" href="#using-function-objects">Using function objects</a></h4>
<p>You can also use function objects directly if you prefer:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn button_cb(w: &amp;mut impl WidgetExt) {
    w.set_label(&quot;Clicked&quot;);
}

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(button_cb);
    app.run().unwrap();
}
</code></pre></pre>
<p>We use <code>&amp;mut impl WidgetExt</code> to be able to reuse the function object with multiple different widget types, otherwise, you can use <code>&amp;mut button::Button</code> for the button.
A disadvantage to this approach, is that to handle state, you would have to manage global state.</p>
<pre><pre class="playground"><code class="language-rust edition2018">extern crate lazy_static;

use fltk::{prelude::*, *};
use std::sync::Mutex;

#[derive(Default)]
struct State {
    count: i32,
}

impl State {
    fn increment(&amp;mut self) {
        self.count += 1;
    }
}

lazy_static::lazy_static! {
    static ref STATE: Mutex&lt;State&gt; = Mutex::new(State::default());
}


fn button_cb(_w: &amp;mut button::Button) {
    let mut state = STATE.lock().unwrap();
    state.increment();
}

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Increment!&quot;);
    my_window.end();
    my_window.show();
    
    but.set_callback(button_cb);
    
    app.run().unwrap();
}
</code></pre></pre>
<p>Here we use lazy_static, there are also other crates to facilitate state management.</p>
<p>Similary for menus, we can use <code>&amp;mut impl MenuExt</code> to be able to set the callback for menu widgets and menu items, in the <code>MenuExt::add()/insert()</code> or <code>MenuItem::add()/insert()</code> methods.</p>
<h3 id="using-the-handle-method"><a class="header" href="#using-the-handle-method">Using the handle method</a></h3>
<p>The handle method takes a closure whose parameter is an Event, and returns a bool for handled events. The bool lets FLTK know whether the event was handled or not.
The call looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();

    but.handle(|_, event| {
        println!(&quot;The event: {:?}&quot;, event);
        false
    });
    
    app.run().unwrap();
}
</code></pre></pre>
<p>This prints the event, and doesn't handle it since we return false. Obviously we would like to do something useful, so change the handle call to:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    but.handle(|_, event| match event {
        Event::Push =&gt; {
            println!(&quot;I was pushed!&quot;);
            true
        },
        _ =&gt; false,
    });
<span class="boring">}
</span></code></pre></pre>
<p>Here we handle the Push event by doing something useful then  returning true, all other events are ignored and we return false.</p>
<p>Another example:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    but.handle(|b, event| match event {
        Event::Push =&gt; {
            b.set_label(&quot;Pushed&quot;);
            true
        },
        _ =&gt; false,
    });
<span class="boring">}
</span></code></pre></pre>
<h3 id="using-messages"><a class="header" href="#using-messages">Using messages</a></h3>
<p>This allows us to create channels and a Sender and Receiver structs, we can then emit messages (which have to be Send + Sync safe) to be handled in our event loop. The advantage is that we avoid having to wrap our types in smart pointers when we need to pass them into closures or into spawned threads.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();

    let (s, r) = app::channel();
    
    but.emit(s, true);
    // This is equivalent to calling but.set_callback(move |_| s.send(true)); 

    while app.wait() {
        if let Some(msg) = r.recv() {
            match msg {
                true =&gt; println!(&quot;Clicked&quot;),
                false =&gt; (), // Here we basically do nothing
            }
        }
    }
}
</code></pre></pre>
<p>Messages can be received in the event loop like in the previous example, otherwise you can receive messages in a background thread or in app::add_idle()' s callback:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    app::add_idle(move || {
        if let Some(msg) = r.recv() {
            match msg {
                true =&gt; println!(&quot;Clicked&quot;),
                false =&gt; (), // Here we basically do nothing
            }
        }
    });
<span class="boring">}
</span></code></pre></pre>
<p>You're also not limited to using fltk channels, you can use any channel. For example, this uses the std channel:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (s, r) = std::sync::mpsc::channel::&lt;Message&gt;();
btn.set_callback(move |_| {
    s.send(Message::SomeMessage).unwrap();
});
<span class="boring">}
</span></code></pre></pre>
<p>You can also define a method which applies to all widgets, similar to the emit() method:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::sync::mpsc::Sender;

pub trait SenderWidget&lt;W, T&gt;
where
    W: WidgetExt,
    T: Send + Sync + Clone + 'static,
{
    fn send(&amp;mut self, sender: Sender&lt;T&gt;, msg: T);
}

impl&lt;W, T&gt; SenderWidget&lt;W, T&gt; for W
where
    W: WidgetExt,
    T: Send + Sync + Clone + 'static,
{
    fn send(&amp;mut self, sender: Sender&lt;T&gt;, msg: T) {
        self.set_callback(move |_| {
            sender.send(msg.clone()).unwrap();
        });
    }
}

fn main() {
    let btn = button::Button::default();
    let (s, r) = std::sync::mpsc::channel::&lt;Message&gt;();
    btn.send(s.clone(), Message::SomeMessage);
}
</code></pre></pre>
<h3 id="creating-our-own-events"><a class="header" href="#creating-our-own-events">Creating our own events</a></h3>
<p>FLTK recognizes 29 events which are listed in enums::Event. However it allows us to create our own events using the app::handle(impl Into<i32>, window) call. The handle function takes an arbitrary i32 (&gt; 30) value as a signal, ideally the values should be predefined, which can be handled within another widget's handle() method, the other widget needs to be within the window that was passed to app::handle.
In the following example, we create a window with a frame and a button. The button's callback sends a CHANGED Event through the app::handle_main function. The CHANGED signal is queried in the frame's handle method.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, button::*, enums::*, frame::*, group::*, prelude::*, window::*};
use std::cell::RefCell;
use std::rc::Rc;

pub struct MyEvent;

impl MyEvent {
    const CHANGED: i32 = 40;
}

#[derive(Clone)]
pub struct Counter {
    count: Rc&lt;RefCell&lt;i32&gt;&gt;,
}

impl Counter {
    pub fn new(val: i32) -&gt; Self {
        Counter {
            count: Rc::from(RefCell::from(val)),
        }
    }

    pub fn increment(&amp;mut self) {
        *self.count.borrow_mut() += 1;
        app::handle_main(MyEvent::CHANGED).unwrap();
    }

    pub fn decrement(&amp;mut self) {
        *self.count.borrow_mut() -= 1;
        app::handle_main(MyEvent::CHANGED).unwrap();
    }

    pub fn value(&amp;self) -&gt; i32 {
        *self.count.borrow()
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = app::App::default();
    let counter = Counter::new(0);
    let mut wind = Window::default().with_size(160, 200).with_label(&quot;Counter&quot;);
    let mut pack = Pack::default().with_size(120, 140).center_of(&amp;wind);
    pack.set_spacing(10);
    let mut but_inc = Button::default().with_size(0, 40).with_label(&quot;+&quot;);
    let mut frame = Frame::default()
        .with_size(0, 40)
        .with_label(&amp;counter.clone().value().to_string());
    let mut but_dec = Button::default().with_size(0, 40).with_label(&quot;-&quot;);
    pack.end();
    wind.end();
    wind.show();

    but_inc.set_callback({
        let mut c = counter.clone();
        move |_| c.increment()
    });

    but_dec.set_callback({
        let mut c = counter.clone();
        move |_| c.decrement()
    });
    
    frame.handle(move |f, ev| {
        if ev == MyEvent::CHANGED.into() {
            f.set_label(&amp;counter.clone().value().to_string());
            true
        } else {
            false
        }
    });

    Ok(app.run()?)
}
</code></pre></pre>
<p>The sent i32 signal can be created on the fly, or added to a const local or global, or within an enum. </p>
<h4 id="advantages"><a class="header" href="#advantages">Advantages:</a></h4>
<ul>
<li>No overhead.</li>
<li>The signal is dealt with like any fltk event.</li>
<li>the app::handle function returns a bool which indicates whether the event was handled or not.</li>
<li>Allows handling of custom signals/events outside the event loop.</li>
<li>Allows an MVC or SVU architecture to your application.</li>
</ul>
<h4 id="disadvantages"><a class="header" href="#disadvantages">Disadvantages:</a></h4>
<ul>
<li>The signal can only be handled in a widget's handle method.</li>
<li>The signal is inaccessible within the event loop (for that, you might want to use WidgetExt::emit or channels described previously in this page). </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drag--drop"><a class="header" href="#drag--drop">Drag &amp; Drop</a></h1>
<p>Drag and Drop are Event types supported by FLTK. You can drag widgets around if you implement these events, and you can drag outside files into an FLTK application. You might also want to implement drawing over widgets which would require handling Event::Drag at least.</p>
<h2 id="dragging-widgets"><a class="header" href="#dragging-widgets">Dragging widgets</a></h2>
<p>Here we'll implement dragging for the window itself. We'll create a window without a border. Normally you can drag windows around using the border:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 400);
    wind.set_color(enums::Color::White);
    wind.set_border(false);
    wind.end();
    wind.show();

    wind.handle({
        let mut x = 0;
        let mut y = 0;
        move |w, ev| match ev {
            enums::Event::Push =&gt; {
                let coords = app::event_coords();
                x = coords.0;
                y = coords.1;
                true
            }
            enums::Event::Drag =&gt; {
                w.set_pos(app::event_x_root() - x, app::event_y_root() - y);
                true
            }
            _ =&gt; false,
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<h2 id="dragging-files"><a class="header" href="#dragging-files">Dragging Files</a></h2>
<p>Dragging a file into an application basically invokes the Paste event, and fills the app::event_text() with the path of the file. So when we handle dragging, we want to capture the path in Event::Paste, check if the file exists, read its content and fill our text widget:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, enums::Event, *};

fn main() {
    let app = app::App::default();
    let buf = text::TextBuffer::default();
    let mut wind = window::Window::default().with_size(400, 400);
    let mut disp = text::TextDisplay::default_fill();
    wind.end();
    wind.show();

    disp.set_buffer(buf.clone());
    disp.handle({
        let mut dnd = false;
        let mut released = false;
        let buf = buf.clone();
        move |_, ev| match ev {
            Event::DndEnter =&gt; {
                dnd = true;
                true
            }
            Event::DndDrag =&gt; true,
            Event::DndRelease =&gt; {
                released = true;
                true
            }
            Event::Paste =&gt; {
                if dnd &amp;&amp; released {
                    let path = app::event_text();
                    let path = path.trim();
                    let path = path.replace(&quot;file://&quot;, &quot;&quot;);
                    let path = std::path::PathBuf::from(&amp;path);
                    if path.exists() {
                        // we use a timeout to avoid pasting the path into the buffer
                        app::add_timeout3(0.0, {
                            let mut buf = buf.clone();
                            move |_| {
                                buf.load_file(&amp;path).unwrap();
                            }
                        });
                    }
                    dnd = false;
                    released = false;
                    true
                } else {
                    false
                }
            }
            Event::DndLeave =&gt; {
                dnd = false;
                released = false;
                true
            }
            _ =&gt; false,
        }
    });
    app.run().unwrap();
}
</code></pre></pre>
<p>If you're not interested in the contents of the file, you can just take the path and show it to the user:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, enums::Event, *};

fn main() {
    let app = app::App::default();
    let buf = text::TextBuffer::default();
    let mut wind = window::Window::default().with_size(400, 400);
    let mut disp = text::TextDisplay::default_fill();
    wind.end();
    wind.show();

    disp.set_buffer(buf.clone());
    disp.handle({
        let mut dnd = false;
        let mut released = false;
        let mut buf = buf.clone();
        move |_, ev| match ev {
            Event::DndEnter =&gt; {
                dnd = true;
                true
            }
            Event::DndDrag =&gt; true,
            Event::DndRelease =&gt; {
                released = true;
                true
            }
            Event::Paste =&gt; {
                if dnd &amp;&amp; released {
                    let path = app::event_text();
                    buf.append(&amp;path);
                    dnd = false;
                    released = false;
                    true
                } else {
                    false
                }
            }
            Event::DndLeave =&gt; {
                dnd = false;
                released = false;
                true
            }
            _ =&gt; false,
        }
    });
    app.run().unwrap();
}
</code></pre></pre>
<h2 id="dragging-to-draw"><a class="header" href="#dragging-to-draw">Dragging to draw</a></h2>
<p>You can draw inside events, but you'll want to use offscreen drawing. In the widgets draw method, you just copy the offscreen content into the widget. A more detailed example can be seen here in the Offscreen drawing section in the <a href="Drawing.html#offscreen-drawing">Drawing page</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-management"><a class="header" href="#state-management">State management</a></h1>
<p>FLTK doesn't impose a certain form of state management or app architecture. This is left to the user. All the examples in the fltk-rs repo and this book already use either callbacks or messages, you'll find many examples of both methods.
Those were discussed in the <a href="Events.html">events page</a>.</p>
<p>Also all the examples might appear to handle everything in the main function, this is only for simplicity. You can create your own App struct, include the main window in it and the state of your app:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

#[derive(Copy, Clone)]
enum Message {
    Inc,
    Dec,
}

struct MyApp {
    app: app::App,
    main_win: window::Window,
    frame: frame::Frame,
    count: i32,
    receiver: app::Receiver&lt;Message&gt;,
}

impl MyApp {
    pub fn new() -&gt; Self {
        let count = 0;
        let app = app::App::default();
        let (s, receiver) = app::channel();
        let mut main_win = window::Window::default().with_size(400, 300);
        let col = group::Flex::default()
            .with_size(100, 200)
            .column()
            .center_of_parent();
        let mut inc = button::Button::default().with_label(&quot;+&quot;);
        inc.emit(s, Message::Inc);
        let frame = frame::Frame::default().with_label(&amp;count.to_string());
        let mut dec = button::Button::default().with_label(&quot;-&quot;);
        dec.emit(s, Message::Dec);
        col.end();
        main_win.end();
        main_win.show();
        Self {
            app,
            main_win,
            frame,
            count,
            receiver,
        }
    }

    pub fn run(mut self) {
        while self.app.wait() {
            if let Some(msg) = self.receiver.recv() {
                match msg {
                    Message::Inc =&gt; self.count += 1,
                    Message::Dec =&gt; self.count -= 1,
                }
                self.frame.set_label(&amp;self.count.to_string());
            }
        }
    }
}

fn main() {
    let a = MyApp::new();
    a.run();
}
</code></pre></pre>
<h2 id="helper-crates"><a class="header" href="#helper-crates">Helper crates</a></h2>
<p>The crates ecosystem offers many crates which provide state management. Also there are 2 crates under the fltk-rs org which offer means of architecting your app and managing its state:</p>
<ul>
<li><a href="https://github.com/fltk-rs/flemish">flemish</a>:</li>
</ul>
<p>Offers an Elm like SVU architecture. This is reactive, immutable in essence, and tears down the view which each Message.</p>
<ul>
<li><a href="https://github.com/fltk-rs/fltk-evented">fltk-evented</a>:</li>
</ul>
<p>This resembles immediate-mode guis in that all events are handled in the event loop. In reality it's also reactive but mutable and stateless. This doesn't cause a redraw with triggers.</p>
<p>Both crates avoid the use of callbacks since these can be a pain in Rust in terms of lifetimes and borrowing. You need to use shared smart pointers with interior mutability to be able to borrow into a callback.</p>
<p>You can take a look at both crates for inspiration.</p>
<p>A sample counter in both:</p>
<h2 id="flemish"><a class="header" href="#flemish">Flemish</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">use flemish::{
    button::Button, color_themes, frame::Frame, group::Flex, prelude::*, OnEvent, Sandbox, Settings,
};

pub fn main() {
    Counter::new().run(Settings {
        size: (300, 100),
        resizable: true,
        color_map: Some(color_themes::BLACK_THEME),
        ..Default::default()
    })
}

#[derive(Default)]
struct Counter {
    value: i32,
}

#[derive(Debug, Clone, Copy)]
enum Message {
    IncrementPressed,
    DecrementPressed,
}

impl Sandbox for Counter {
    type Message = Message;

    fn new() -&gt; Self {
        Self::default()
    }

    fn title(&amp;self) -&gt; String {
        String::from(&quot;Counter - fltk-rs&quot;)
    }

    fn update(&amp;mut self, message: Message) {
        match message {
            Message::IncrementPressed =&gt; {
                self.value += 1;
            }
            Message::DecrementPressed =&gt; {
                self.value -= 1;
            }
        }
    }

    fn view(&amp;mut self) {
        let col = Flex::default_fill().column();
        Button::default()
            .with_label(&quot;Increment&quot;)
            .on_event(Message::IncrementPressed);
        Frame::default().with_label(&amp;self.value.to_string());
        Button::default()
            .with_label(&quot;Decrement&quot;)
            .on_event(Message::DecrementPressed);
        col.end();
    }
}
</code></pre></pre>
<h2 id="fltk-evented"><a class="header" href="#fltk-evented">fltk-evented</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, button::Button, frame::Frame, group::Flex, prelude::*, window::Window};
use fltk_evented::Listener;

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    app::set_font_size(20);

    let mut wind = Window::default()
        .with_size(160, 200)
        .center_screen()
        .with_label(&quot;Counter&quot;);
    let flex = Flex::default()
        .with_size(120, 160)
        .center_of_parent()
        .column();
    let but_inc: Listener&lt;_&gt; = Button::default().with_label(&quot;+&quot;).into();
    let mut frame = Frame::default();
    let but_dec: Listener&lt;_&gt; = Button::default().with_label(&quot;-&quot;).into();
    flex.end();
    wind.end();
    wind.show();

    let mut val = 0;
    frame.set_label(&amp;val.to_string());

    while a.wait() {
        if but_inc.triggered() {
            val += 1;
            frame.set_label(&amp;val.to_string());
        }

        if but_dec.triggered() {
            val -= 1;
            frame.set_label(&amp;val.to_string());
        }
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layouts"><a class="header" href="#layouts">Layouts</a></h1>
<p>Out of the box, fltk-rs offers:</p>
<ul>
<li>A Flex widget</li>
<li>Pack</li>
<li>Grid</li>
<li>Widget relative positioning.</li>
</ul>
<h3 id="flex"><a class="header" href="#flex">Flex</a></h3>
<p>The Flex widget allows flexbox layouts. It's in group module and implements the GroupExt trait. There are 2 forms of Flex widgets, which can be specified using the set_type or with_type methods. These are the column and row:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut win = window::Window::default().with_size(400, 300);
    let mut flex = Flex::new(0, 0, 400, 300, None);
    flex.set_type(group::FlexType::Column);
    let expanding = button::Button::default().with_label(&quot;Expanding&quot;);
    let mut normal = button::Button::default().with_label(&quot;Normal&quot;);
    flex.set_size(&amp;mut normal, 30);
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>The set_size method takes another widget and fixes its size to the value passed, in the example it's 30. Since this is a column, the 30 represents the height of the widget to be set.
The other widget will be expandable since no size is set for it. A full example can be found here:</p>
<p><a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/flex.rs">Flex example</a></p>
<p><img src="https://github.com/osen/FL_Flex/raw/main/doc/login.png" alt="image" /></p>
<h3 id="packs"><a class="header" href="#packs">Packs</a></h3>
<p>The Pack widget (in the group module) also implement the GroupExt trait. There are 2 forms of packs, Vertical and Horizontal packs, Vertical being the default. Vertical packs only require the height of its children widgets, while horizontal packs only require the width of its children widgets, like in the example below:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::default().with_size(400, 300);
    let mut hpack = group::Pack::default().with_size(190, 40).center_of(&amp;my_window);
    hpack.set_type(group::PackType::Horizontal);
    hpack.set_spacing(30);
    let _but1 = button::Button::default().with_size(80, 0).with_label(&quot;Button1&quot;);
    let _but2 = button::Button::default().with_size(80, 0).with_label(&quot;Button2&quot;);
    hpack.end();
    my_window.end();
    my_window.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>This creates a pack widget inside the window, and fills it with 2 buttons. Notice that the x and y coordinates are no longer needed for the buttons. You can also embed packs inside packs like in the calculator example in the repo. 
You can also use the Pack::auto_layout() method:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::default().with_size(400, 300);
    let mut hpack = group::Pack::new(0, 200, 400, 100, &quot;&quot;);
    hpack.set_type(group::PackType::Horizontal);
    hpack.set_spacing(30);
    let _but1 = button::Button::default().with_label(&quot;Button1&quot;);
    let _but2 = button::Button::default().with_label(&quot;Button2&quot;);
    hpack.end();
    hpack.auto_layout();
    my_window.end();
    my_window.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>In which case we don't even need the size of the buttons.</p>
<p><img src="https://user-images.githubusercontent.com/37966791/100937983-ef8bf400-3504-11eb-9da1-09c5ac1aade4.png" alt="image" /></p>
<h3 id="grid"><a class="header" href="#grid">Grid</a></h3>
<p><a href="https://github.com/fltk-rs/fltk-grid">Grid</a> is implemented currently in an external crate. It requires a layout which is set using <code>Grid::set_layout(&amp;mut self, rows, columns)</code>. Then widgets are inserted via the <code>Grid::insert(&amp;mut self, row, column)</code> or <code>Grid::insert_ext(&amp;mut self, row, column, row_span, column_span)</code> methods:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};
use fltk_grid::Grid;

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut win = window::Window::default().with_size(500, 300);
    let mut grid = Grid::default_fill();
    // set to true to show cell outlines and numbers
    grid.debug(false); 
    // 5 rows, 5 columns
    grid.set_layout(5, 5); 
    // widget, row, col
    grid.insert(&amp;mut button::Button::default().with_label(&quot;Click&quot;), 0, 1); 
    // widget, row, col, row_span, col_span
    grid.insert_ext(&amp;mut button::Button::default().with_label(&quot;Button 2&quot;), 2, 1, 3, 1); 
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p><a href="https://github.com/fltk-rs/fltk-grid/blob/main/examples/form.rs">Grid example</a></p>
<p><img src="https://user-images.githubusercontent.com/37966791/160347418-b8b54408-3dc9-4fc4-93e8-fb6c1c0282e9.png" alt="image" /></p>
<h3 id="relative-positioning"><a class="header" href="#relative-positioning">Relative positioning</a></h3>
<p>The WidgetExt trait offers several constructor methods which allow us to construct widgets relative to other widgets size and position. This is similar to Qml's anchoring.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default()
        .with_size(160, 200)
        .center_screen()
        .with_label(&quot;Counter&quot;);
    let mut frame = frame::Frame::default()
        .with_size(100, 40)
        .center_of(&amp;wind)
        .with_label(&quot;0&quot;);
    let mut but_inc = button::Button::default()
        .size_of(&amp;frame)
        .above_of(&amp;frame, 0)
        .with_label(&quot;+&quot;);
    let mut but_dec = button::Button::default()
        .size_of(&amp;frame)
        .below_of(&amp;frame, 0)
        .with_label(&quot;-&quot;);
    wind.end();
    wind.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/counter.jpg" alt="counter" /></p>
<p>(With some skipped theming)</p>
<p>These methods are namely:</p>
<ul>
<li><code>above_of(&amp;widget, padding)</code>: places the widget above the passed widget</li>
<li><code>below_of(&amp;widget, padding)</code>: places the widget below the passed widget</li>
<li><code>right_of(&amp;widget, padding)</code>: places the widget right of the passed widget</li>
<li><code>left_of(&amp;widget, padding)</code>: places the widget left of the passed widget</li>
<li><code>center_of(&amp;widget)</code>: places the widget at the center (both x and y axes) of the passed widget.</li>
<li><code>center_of_parent()</code>: places the widget at the center (both x and y axes) of the parent.</li>
<li><code>center_x(&amp;widget)</code>: places the widget at the center (x-axis) of the passed widget.</li>
<li><code>center_y(&amp;widget)</code>: places the widget at the center (y-axis) of the passed widget.</li>
<li><code>size_of(&amp;widget)</code>: constructs the widget with the same size of the passed widget.</li>
<li><code>size_of_parent()</code>: constructs the widget with the same size of its parent.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style"><a class="header" href="#style">Style</a></h1>
<p>FLTK offers extensive custom styling options for your application, from changing the app's general scheme, to customizing colors, fonts, frame types, custom drawing...etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="colors"><a class="header" href="#colors">Colors</a></h1>
<p>FLTK can handle <a href="https://en.wikipedia.org/wiki/Color_depth#True_color_(24-bit)">true color</a>. Some convenience colors are made available in the enums::Color enum:</p>
<ul>
<li>Black</li>
<li>White</li>
<li>Red</li>
<li>Blue</li>
<li>Cyan
...etc.</li>
</ul>
<p>You can also construct your colors using Color methods:</p>
<ul>
<li>by_index(). This uses fltk's colormap. Values range from 0 to 255:</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let red = Color::by_index(88);
<span class="boring">}
</span></code></pre></pre>
<p><img src="https://www.fltk.org/doc-1.3/fltk-colormap.png" alt="colormap" /></p>
<ul>
<li>from_hex(). This takes a 24-bit hex value in the form RGB:</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RED: Color = Color::from_hex(0xff0000); // notice it's a const functions
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>from_rgb(). This takes 3 values r, g, b:</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RED: Color = Color::from_rgb(255, 0, 0); // notice it's a const functions
<span class="boring">}
</span></code></pre></pre>
<p>The Color enum also offers some convenience methods to generate different shades of the chosen color, using .darker(), .lighter(), .inactive() methods and others:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let col = Color::from_rgb(176, 100, 50).lighter();
<span class="boring">}
</span></code></pre></pre>
<p>If you prefer html hex string colors, you can use the from_hex_str() method:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let col = Color::from_hex_str(&quot;#ff0000&quot;);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frametypes"><a class="header" href="#frametypes">FrameTypes</a></h1>
<p>FLTK has a wide range of frame types. These can be found under the enums module:
<img src="https://github.com/fltk-rs/fltk-rs/raw/master/screenshots/frames.jpg" alt="image" /></p>
<p>These can be set using WidgetExt::set_frame(). Some widgets/traits also support set_down_frame():</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();
    image.scale(200, 200, true, true);
    frame.set_image(Some(image));

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-rs/raw/master/screenshots/hello.jpg" alt="image" />
Here we set the frame's FrameType to EngravedBox, which you can see around the image.</p>
<p>ButtonExt supports set_down_frame():</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>btn1.set_frame(enums::FrameType::RFlatBox);
btn1.set_down_frame(enums::FrameType::RFlatBox);
<span class="boring">}
</span></code></pre></pre>
<p>Furthermore, we can change the draw routine for our FrameTypes using app::set_frame_type_cb():</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    enums::{Color, FrameType},
    prelude::*,
    *
};

fn down_box(x: i32, y: i32, w: i32, h: i32, c: Color) {
    draw::draw_box(FrameType::RFlatBox, x, y, w, h, Color::BackGround2);
    draw::draw_box(FrameType::RoundedFrame, x - 10, y, w + 20, h, c);
}

fn main() {
    let app = app::App::default();
    app::set_frame_type_cb(FrameType::DownBox, down_box, 0, 0, 0, 0);
    let mut w = window::Window::default().with_size(480, 230).with_label(&quot;Gui&quot;);
    w.set_color(Color::from_u32(0xf5f5f5));

    let mut txf = input::Input::default().with_size(160, 30).center_of_parent();    
    txf.set_color(Color::Cyan.darker());

    w.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/146932070-ae63fd63-3f37-4d97-978e-4604d2bc0e4b.png" alt="image" /></p>
<p>This changes the default DownBox with a custom down_box routine. We can also ImageExt::draw() inside our draw routines to draw images (Like svg images to get scalable rounded borders).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fonts"><a class="header" href="#fonts">Fonts</a></h1>
<p>FLTK has already 16 fonts which can be found in enums::Font:</p>
<ul>
<li>Helvetica</li>
<li>HelveticaBold</li>
<li>HelveticaItalic</li>
<li>HelveticaBoldItalic</li>
<li>Courier</li>
<li>CourierBold</li>
<li>CourierItalic</li>
<li>CourierBoldItalic</li>
<li>Times</li>
<li>TimesBold</li>
<li>TimesItalic </li>
<li>TimesBoldItalic </li>
<li>Symbol </li>
<li>Screen </li>
<li>ScreenBold </li>
<li>Zapfdingbats</li>
</ul>
<p>It also allows loading system and bundled fonts.</p>
<p>System fonts depend on the system, and are not loaded by default. These can be loaded using the App::load_system_fonts() method.
The fonts can then be acquired using the app::fonts() function or be queried using the app::font_count(), app::font_name() and app::font_index() functions.
And then can be used using the Font::by_index() or Font::by_name() methods.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default().load_system_fonts();
    // To load a font by path, check the App::load_font() method
    let fonts = app::fonts();
    // println!(&quot;{:?}&quot;, fonts);
    let mut wind = window::Window::default().with_size(400, 300);
    let mut frame = frame::Frame::default().size_of(&amp;wind);
    frame.set_label_size(30);
    wind.set_color(enums::Color::White);
    wind.end();
    wind.show();
    println!(&quot;The system has {} fonts!\nStarting slideshow!&quot;, fonts.len());
    let mut i = 0;
    while app.wait() {
        if i == fonts.len() {
            i = 0;
        }
        frame.set_label(&amp;format!(&quot;[{}]&quot;, fonts[i]));
        frame.set_label_font(enums::Font::by_index(i));
        app::sleep(0.5);
        i += 1;
    }
}
</code></pre></pre>
<p>If you would like to load a bundled font without it being in the system, you can alternatively use Font::load_font() and Font::set_font(), this allows you to replace one of FLTK's predefined fonts with a custom font:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, enums::Font, button::Button, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();

    let font = Font::load_font(&quot;angelina.ttf&quot;).unwrap();
    Font::set_font(Font::Helvetica, &amp;font);
    app::set_font_size(24);

    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, &quot;Click me!&quot;);
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label(&quot;Hello world&quot;));

    app.run().unwrap();
}
</code></pre></pre>
<p>load_font() loads the font from the .ttf file, set_font() replaces Font::Helvetica (FLTK's default font) with our loaded font.</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145735197-130f7dd6-a31f-4bc6-a362-90a13493a556.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawing-things"><a class="header" href="#drawing-things">Drawing things</a></h1>
<p>fltk-rs provides free functions in the draw module which allow you to draw custom elements. The drawing works only if the calls are done in a context which allows drawing, such as in the WidgetBase::draw() method or in an Offscreen context:</p>
<h2 id="drawing-in-widgets"><a class="header" href="#drawing-in-widgets">Drawing in widgets</a></h2>
<p>Notice we use the draw calls inside our widget's draw method:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.end();
    win.show();

    win.draw(|w| {
        use draw::*;
        // fill the window white
        draw_rect_fill(0, 0, w.w(), w.h(), enums::Color::White);
        // draw a blue pie
        set_draw_color(enums::Color::Blue.inactive());
        draw_pie(w.w() / 2 - 50, w.h() / 2 - 50, 100, 100, 0.0, 360.0);
        // draw angled red text
        set_draw_color(enums::Color::Red);
        set_font(enums::Font::Courier, 16);
        draw_text_angled(45, &quot;Hello World&quot;, w.w() / 2, w.h() / 2);
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145693473-defb2298-fc6b-4d2f-8a0c-3d4902b39dd3.jpg" alt="draw" /></p>
<p>We've used the whole window as our canvas, but it can be any widget as well. Other available functions allow drawing lines, rects, arcs, pies, loops, polygons, even images.</p>
<h2 id="offscreen-drawing"><a class="header" href="#offscreen-drawing">Offscreen drawing</a></h2>
<p>Sometimes you would like to draw things in response to events, such as when the patients pushes and drags the cursor. In this case, you can use a draw::Offscreen to do that. In that case, we use the widget's draw method to just copy the Offscreen contents, while we do our drawing in the widget's handle method:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app,
    draw::{
        draw_line, draw_point, draw_rect_fill, set_draw_color, set_line_style, LineStyle, Offscreen,
    },
    enums::{Color, Event, FrameType},
    frame::Frame,
    prelude::*,
    window::Window,
};
use std::cell::RefCell;
use std::rc::Rc;

const WIDTH: i32 = 800;
const HEIGHT: i32 = 600;

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);

    let mut wind = Window::default()
        .with_size(WIDTH, HEIGHT)
        .with_label(&quot;RustyPainter&quot;);
    let mut frame = Frame::default()
        .with_size(WIDTH - 10, HEIGHT - 10)
        .center_of(&amp;wind);
    frame.set_color(Color::White);
    frame.set_frame(FrameType::DownBox);

    wind.end();
    wind.show();

    // We fill our offscreen with white
    let offs = Offscreen::new(frame.width(), frame.height()).unwrap();
    #[cfg(not(target_os = &quot;macos&quot;))]
    {
        offs.begin();
        draw_rect_fill(0, 0, WIDTH - 10, HEIGHT - 10, Color::White);
        offs.end();
    }

    let offs = Rc::from(RefCell::from(offs));

    frame.draw({
        let offs = offs.clone();
        move |_| {
            let mut offs = offs.borrow_mut();
            if offs.is_valid() {
                offs.rescale();
                offs.copy(5, 5, WIDTH - 10, HEIGHT - 10, 0, 0);
            } else {
                offs.begin();
                draw_rect_fill(0, 0, WIDTH - 10, HEIGHT - 10, Color::White);
                offs.copy(5, 5, WIDTH - 10, HEIGHT - 10, 0, 0);
                offs.end();
            }
        }
    });

    frame.handle({
        let mut x = 0;
        let mut y = 0;
        move |f, ev| {
            // println!(&quot;{}&quot;, ev);
            // println!(&quot;coords {:?}&quot;, app::event_coords());
            // println!(&quot;get mouse {:?}&quot;, app::get_mouse());
            let offs = offs.borrow_mut();
            match ev {
                Event::Push =&gt; {
                    offs.begin();
                    set_draw_color(Color::Red);
                    set_line_style(LineStyle::Solid, 3);
                    let coords = app::event_coords();
                    x = coords.0;
                    y = coords.1;
                    draw_point(x, y);
                    offs.end();
                    f.redraw();
                    set_line_style(LineStyle::Solid, 0);
                    true
                }
                Event::Drag =&gt; {
                    offs.begin();
                    set_draw_color(Color::Red);
                    set_line_style(LineStyle::Solid, 3);
                    let coords = app::event_coords();
                    draw_line(x, y, coords.0, coords.1);
                    x = coords.0;
                    y = coords.1;
                    offs.end();
                    f.redraw();
                    set_line_style(LineStyle::Solid, 0);
                    true
                }
                _ =&gt; false,
            }
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>Notice how we open an Offscreen context using offs.begin() then close it with offs.end(). This allows us to call drawing functions inside the Offscreen.</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146173813-67038a94-7739-480e-a181-29498aac842a.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styling"><a class="header" href="#styling">Styling</a></h1>
<p>FLTK has a lot to offer in terms of styling applications. We have already seen that we can use true color and different fonts, in addition to draw custom things. Styling is making use of all that. It can be done per widget leveraging the methods in WidgetExt, or globally using functions in the app module.</p>
<h2 id="widgetext"><a class="header" href="#widgetext">WidgetExt</a></h2>
<p>Most of the WidgetExt trait is related to modifying the frame type, label type, widget color, text color, text font and text size.
These all have setters and getters which can be found <a href="https://docs.rs/fltk/*/fltk/prelude/trait.WidgetExt.html">here</a>.</p>
<p>An example of this:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    enums::{Align, Color, Font, FrameType},
    prelude::*,
    *,
};

const BLUE: Color = Color::from_hex(0x42A5F5);
const SEL_BLUE: Color = Color::from_hex(0x2196F3);
const GRAY: Color = Color::from_hex(0x757575);
const WIDTH: i32 = 600;
const HEIGHT: i32 = 400;

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default()
        .with_size(WIDTH, HEIGHT)
        .with_label(&quot;Flutter-like!&quot;);
    let mut bar =
        frame::Frame::new(0, 0, WIDTH, 60, &quot;  FLTK App!&quot;).with_align(Align::Left | Align::Inside);
    let mut text = frame::Frame::default()
        .with_size(100, 40)
        .center_of(&amp;win)
        .with_label(&quot;You have pushed the button this many times:&quot;);
    let mut count = frame::Frame::default()
        .size_of(&amp;text)
        .below_of(&amp;text, 0)
        .with_label(&quot;0&quot;);
    let mut but = button::Button::new(WIDTH - 100, HEIGHT - 100, 60, 60, &quot;@+6plus&quot;);
    win.end();
    win.make_resizable(true);
    win.show();

    // Theming
    app::background(255, 255, 255);
    app::set_visible_focus(false);

    bar.set_frame(FrameType::FlatBox);
    bar.set_label_size(22);
    bar.set_label_color(Color::White);
    bar.set_color(BLUE);
    bar.draw(|b| {
        draw::set_draw_rgb_color(211, 211, 211);
        draw::draw_rectf(0, b.height(), b.width(), 3);
    });

    text.set_label_size(18);
    text.set_label_font(Font::Times);

    count.set_label_size(36);
    count.set_label_color(GRAY);

    but.set_color(BLUE);
    but.set_selection_color(SEL_BLUE);
    but.set_label_color(Color::White);
    but.set_frame(FrameType::OFlatFrame);
    // End theming

    but.set_callback(move |_| {
        let label = (count.label().parse::&lt;i32&gt;().unwrap() + 1).to_string();
        count.set_label(&amp;label);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/flutter_like.jpg" alt="counter" /></p>
<p>Widgets also support showing images within them, which is discussed more in the Images section.</p>
<h2 id="global-styling"><a class="header" href="#global-styling">Global styling</a></h2>
<p>These can be found in the app module. Starting from changing the app's scheme:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, enums::*, *};
let app = app::App::default().with_scheme(app::Scheme::Plastic);
<span class="boring">}
</span></code></pre></pre>
<p>There are four schemes:</p>
<ul>
<li>Base</li>
<li>Gtk</li>
<li>Gleam</li>
<li>Plastic</li>
</ul>
<p>To setting the app's colors, default font, default frame type and whether to show focus on widgets.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, button::Button, enums, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();
    app::set_background_color(170, 189, 206);
    app::set_background2_color(255, 255, 255);
    app::set_foreground_color(0, 0, 0);
    app::set_selection_color(255, 160,  63);
    app::set_inactive_color(130, 149, 166);
    app::set_font(enums::Font::Times);
    
    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, &quot;Click me!&quot;);
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label(&quot;Hello world&quot;));

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727821-5923fcd4-3a57-4a15-b36f-574b3e5321ea.png" alt="image" /></p>
<h3 id="custom-drawing"><a class="header" href="#custom-drawing">Custom Drawing</a></h3>
<p>FLTK also offers drawing primitives which makes giving a widget a custom appearance quite easy. This is done using the draw() method which takes a closure. Lets draw our own button, even though FLTK offers a ShadowFrame FrameType, let's create our own:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, enums::*, *};

fn main() {
    let app = app::App::default();
    app::set_color(255, 255, 255); // white
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);

    let mut but = button::Button::default()
        .with_pos(160, 210)
        .with_size(80, 40)
        .with_label(&quot;Button1&quot;);

    but.draw2(|b| {
        draw::set_draw_color(Color::Gray0);
        draw::draw_rectf(b.x() + 2, b.y() + 2, b.width(), b.height());
        draw::set_draw_color(Color::from_u32(0xF5F5DC));
        draw::draw_rectf(b.x(), b.y(), b.width(), b.height());
        draw::set_draw_color(Color::Black);
        draw::draw_text2(
            &amp;b.label(),
            b.x(),
            b.y(),
            b.width(),
            b.height(),
            Align::Center,
        );
    });

    my_window.end();
    my_window.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/100938232-62956a80-3505-11eb-888f-ffe655e7aadc.jpg" alt="draw" /></p>
<p>The draw() method also supports drawing images inside of widgets as will be seen in the next section.</p>
<h2 id="fltk-theme"><a class="header" href="#fltk-theme">fltk-theme</a></h2>
<p>This is a <a href="https://github.com/fltk-rs/fltk-theme">crate</a> which provides several predefined themes which can be used by just loading the theme:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};
use fltk_theme::{widget_themes, WidgetTheme, ThemeType};

fn main() {
    let a = app::App::default();
    let widget_theme = WidgetTheme::new(ThemeType::Aero);
    widget_theme.apply();
    let mut win = window::Window::default().with_size(400, 300);
    let mut btn = button::Button::new(160, 200, 80, 30, &quot;Hello&quot;);
    btn.set_frame(widget_themes::OS_DEFAULT_BUTTON_UP_BOX);
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-theme/raw/main/screenshots/aqua_classic.jpg" alt="aqua-classic" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animations"><a class="header" href="#animations">Animations</a></h1>
<p>Animations can be shown in fltk-rs using several mechanism:</p>
<ul>
<li>Leveraging the event loop</li>
<li>Spawning threads</li>
<li>Timeouts</li>
</ul>
<h2 id="leveraging-the-event-loop"><a class="header" href="#leveraging-the-event-loop">Leveraging the event loop</a></h2>
<p>fltk offers app::wait() and app::check() which allow updating the ui during a blocking operation:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::*, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    // our button takes the whole left side of the window
    let mut sliding_btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut sliding_btn);
    win.end();
    win.show();

    sliding_btn.set_callback(|btn| {
        if btn.w() &gt; 0 &amp;&amp; btn.w() &lt; 100 {
            return; // we're still animating
        }
        while btn.w() != 0 {
            btn.set_size(btn.w() - 2, btn.h());
            app::sleep(0.016);
            btn.parent().unwrap().redraw();
            app::wait(); // or app::check();
        }
    });
    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}
</code></pre></pre>
<h2 id="spawning-threads"><a class="header" href="#spawning-threads">Spawning threads</a></h2>
<p>This ensures we don't block the main/ui thread:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::*, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    // our button takes the whole left side of the window
    let mut sliding_btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut sliding_btn);
    win.end();
    win.show();

    sliding_btn.set_callback(|btn| {
        if btn.w() &gt; 0 &amp;&amp; btn.w() &lt; 100 {
            return; // we're still animating
        }
        std::thread::spawn({
            let mut btn = btn.clone();
            move || {
                while btn.w() != 0 {
                    btn.set_size(btn.w() - 2, btn.h());
                    app::sleep(0.016);
                    app::awake(); // to awaken the ui thread
                    btn.parent().unwrap().redraw();
                }
            }
        });
    });
    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}
</code></pre></pre>
<h2 id="timeouts"><a class="header" href="#timeouts">Timeouts</a></h2>
<p>fltk offers timeouts for recurring operations. We can add a timeout, repeat it and remove it:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::*, prelude::*, *};

fn move_button(mut btn: button::Button, handle: app::TimeoutHandle) {
    btn.set_size(btn.w() - 2, btn.h());
    btn.parent().unwrap().redraw();
    if btn.w() == 20 {
        app::remove_timeout3(handle);
    } else {
        app::repeat_timeout3(0.016, handle);
    }
}

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    let mut btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut btn);
    btn.clear_visible_focus();
    win.end();
    win.show();

    btn.set_callback(|b| {
        let btn = b.clone();
        app::add_timeout3(0.016, move |handle| {
            let btn = btn.clone();
            move_button(btn, handle)
        });
    });

    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}
</code></pre></pre>
<p>We basically add the timeout when the user clicks the button, and depending on the size of the button we either repeat it or remove it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="build-issues"><a class="header" href="#build-issues">Build issues</a></h2>
<h3 id="why-does-the-build-fails-when-i-follow-one-of-the-tutorials"><a class="header" href="#why-does-the-build-fails-when-i-follow-one-of-the-tutorials">Why does the build fails when I follow one of the tutorials?</a></h3>
<p>The first tutorial uses the fltk-bundled feature flag, which is only supported for certain platforms since these are built using the Github Actions CI, namely:</p>
<ul>
<li>Windows 10 x64 (msvc and gnu).</li>
<li>MacOS 12 x64 and aarch64.</li>
<li>Ubuntu 20.04 or later, x64 and aarch64.</li>
</ul>
<p>If you're not running one of the aforementioned platforms, you'll have to remove the fltk-bundled feature flag in your Cargo.toml file:</p>
<pre><code class="language-toml">[dependencies]
fltk = &quot;^1.3&quot;
</code></pre>
<p>Furthermore, the fltk-bundled flag assumes you have curl and tar installed (for Windows, they're available in the Native Tools Command Prompt).</p>
<h3 id="build-fails-on-windows-why-cant-cmake-find-my-toolchain"><a class="header" href="#build-fails-on-windows-why-cant-cmake-find-my-toolchain">Build fails on windows, why can't CMake find my toolchain?</a></h3>
<p>If you're building using the MSVC toolchain, make sure you run your build (at least your initial build) using the Native Tools Command Prompt, which should appear once you start typing &quot;native&quot; in the start menu, choose the version corresponding to your installed Rust toolchain (x86 or x64). The Native Tools Command Prompt has all the environment variables set correctly for native development. <a href="https://github.com/alexcrichton/cmake-rs">cmake-rs</a> which the bindings use might not be able to find the Visual Studio 2022 generator, in which case, you can try to use the fltk-bundled feature, or use ninja via the use-ninja feature. This requires installing <a href="https://github.com/ninja-build/ninja/wiki/Pre-built-Ninja-packages">Ninja</a> which can be installed with Chocolatey, Scoop or manually.</p>
<p>If you're building for the GNU toolchain, make sure that Make is also installed, which usually comes installed in mingw64 toolchain.</p>
<h3 id="build-fails-on-macos-11-with-an-apple-m1-chip-what-can-i-do"><a class="header" href="#build-fails-on-macos-11-with-an-apple-m1-chip-what-can-i-do">Build fails on MacOS 11 with an Apple M1 chip, what can I do?</a></h3>
<p>If you're getting &quot;file too small to be an archive&quot; error, you might be hitting this <a href="https://github.com/rust-lang/cargo/issues/8875">issues</a> or this <a href="https://github.com/rust-lang/rust/issues/50220">issue</a>. MacOS's native C/C++ toolchain shouldn't have this issue, and can be installed by running <code>xcode-select --install</code> or by installing XCode. Make sure the corresponding Rust toolchain (aarch64-apple-darwin) is installed as well. You can uninstall other Rust apple-darwin toolchains or use cargo-lipo instead if you need universal/fat binaries.</p>
<h3 id="why-do-i-get-a-link-error-while-using-the-mingw-toolchain-on-windows"><a class="header" href="#why-do-i-get-a-link-error-while-using-the-mingw-toolchain-on-windows">Why do I get a Link error while using the mingw toolchain on windows?</a></h3>
<p>If the linking fails because of this <a href="https://github.com/rust-lang/rust/issues/47048">issue</a> with older toolchains, it should work by using the fltk-shared feature (an issue with older compilers). Which would also generate a dynamic library which would need to be deployed with your application.</p>
<pre><code class="language-toml">[dependencies]
fltk = { version = &quot;^1.3&quot;, features = [&quot;fltk-shared&quot;] }
</code></pre>
<h3 id="why-does-my-msys2-mingw-built-fltk-app-using-fltk-bundled-isnt-self-contained-and-requires-several-dlls"><a class="header" href="#why-does-my-msys2-mingw-built-fltk-app-using-fltk-bundled-isnt-self-contained-and-requires-several-dlls">Why does my msys2 mingw built fltk app using, fltk-bundled, isn't self-contained and requires several dlls?</a></h3>
<p>If you have installed libgdiplus via pacman, it would require those dependencies on other systems. If you're using the windows sdk-provided libgdiplus, it shouldn't require extra dlls. You can either uninstall libgdiplus that was installed via pacman, or or you can build using the feature flag: <code>no-gdiplus</code>.</p>
<h3 id="why-do-i-get-link-errors-when-i-use-the-system-fltk-feature"><a class="header" href="#why-do-i-get-link-errors-when-i-use-the-system-fltk-feature">Why do I get link errors when I use the system-fltk feature?</a></h3>
<p>This crate targets FLTK 1.4, while currently most distros distribute an older version of FLTK (1.3.5). You can try to install FLTK (C++) by building from source.</p>
<h3 id="build-fails-on-arch-linux-because-of-pango-or-cairo"><a class="header" href="#build-fails-on-arch-linux-because-of-pango-or-cairo">Build fails on Arch linux because of pango or cairo?</a></h3>
<p>Pango changed its include paths which caused build failures across many projects. There are 2 solutions:</p>
<ul>
<li>Use the no-pango feature. Downsides: loss of rtl and cjk language support.</li>
<li>Set the CFLAGS and CXXFLAGS to correct the global include paths.</li>
</ul>
<pre><code>export CFLAGS=&quot;-isystem /usr/include/harfbuzz -isystem /usr/include/cairo&quot;
export CXXFLAGS=&quot;-isystem /usr/include/harfbuzz -isystem /usr/include/cairo&quot;
</code></pre>
<h3 id="how-do-i-force-cmake-to-use-a-certain-c-compiler"><a class="header" href="#how-do-i-force-cmake-to-use-a-certain-c-compiler">How do I force CMake to use a certain C++ compiler?</a></h3>
<p>FLTK works with all 3 major compilers. If you would like to change the C++ compiler that's chosen by default by CMake, you can change the CXX environment variable before running the build:</p>
<pre><code>export CXX=/usr/bin/clang++
cargo run
</code></pre>
<p>CMake caches the C++ compiler variable after it's first run, so if the above failed because of a previous run, you would have to run <code>cargo clean</code> or you can manually delete the CMakeCache.txt file in the build directory.</p>
<h3 id="can-i-accelerate-the-build-speed"><a class="header" href="#can-i-accelerate-the-build-speed">Can I accelerate the build speed?</a></h3>
<p>You can use the &quot;use-ninja&quot; feature flag if you have ninja installed. </p>
<h3 id="can-i-cache-a-previous-build-of-the-fltk-library"><a class="header" href="#can-i-cache-a-previous-build-of-the-fltk-library">Can I cache a previous build of the FLTK library?</a></h3>
<p>You can use the fltk-bundled feature and use either the CFLTK_BUNDLE_DIR or CFLTK_BUNDLE_URL to point to the location of your cached cfltk and fltk libraries.</p>
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<h3 id="how-do-i-deploy-my-application"><a class="header" href="#how-do-i-deploy-my-application">How do I deploy my application?</a></h3>
<p>Rust, by default, statically links your application. FLTK is built also for static linking. That means that the resulting executable can be directly deployed without the need to deploy other files along with it. If you want to create a WIN32 application, Mac OS Bundle or Linux AppImage, please check the question just below!</p>
<h3 id="why-do-i-get-a-console-window-whenever-i-start-my-gui-app"><a class="header" href="#why-do-i-get-a-console-window-whenever-i-start-my-gui-app">Why do I get a console window whenever I start my GUI app?</a></h3>
<p>This is the default behavior of the toolchain, and is helpful for debugging purposes. It can be turned off easily by adding <code>#![windows_subsystem = &quot;windows&quot;]</code> at the beginning of your main.rs file if you're on windows. 
If you would like to keep the console window on debug builds, but not on release builds, you can use <code>#![cfg_attr(not(debug_assertions), windows_subsystem = &quot;windows&quot;)]</code> instead.</p>
<p>For Mac OS and Linux, this is done by a post-build process to create a Mac OS Bundle or Linux AppImage respectively.</p>
<p>See <a href="https://github.com/burtonageo/cargo-bundle">cargo-bundle</a> for an automated tool for creating Mac OS app bundles. </p>
<p>See <a href="https://docs.appimage.org/packaging-guide/overview.html#converting-existing-binary-packages">here</a> for directions on creating an AppImage for Linux.</p>
<h3 id="why-is-the-size-of-my-resulting-executable-larger-than-i-had-expected"><a class="header" href="#why-is-the-size-of-my-resulting-executable-larger-than-i-had-expected">Why is the size of my resulting executable larger than I had expected?</a></h3>
<p>FLTK is known for it's small applications. Make sure you're building in release, and make sure symbols are stripped using the strip command in Unix-like systems. On Windows it's unnecessary since symbols would end up in the pdb file (which shouldn't be deployed).</p>
<p>If you need an even smaller size, try using opt-level=&quot;z&quot;:</p>
<pre><code class="language-toml">[profile.release]
opt-level = &quot;z&quot;
lto = true
codegen-units = 1
panic = &quot;abort&quot;
</code></pre>
<p>Newer versions of cargo (&gt;1.46) support automatically stripping binaries in the post-build phase:</p>
<pre><code class="language-toml">cargo-features = [&quot;strip&quot;]

[profile.release]
strip = true
opt-level = &quot;z&quot;
lto = true
codegen-units = 1
panic = &quot;abort&quot;
</code></pre>
<p>Furthermore, you can build Rust's stdlib optimized for size (it comes optimized for speed by default). More info on that <a href="https://github.com/johnthagen/min-sized-rust">here</a></p>
<h3 id="can-i-cross-compile-my-application-to-a-mobile-platform-or-wasm"><a class="header" href="#can-i-cross-compile-my-application-to-a-mobile-platform-or-wasm">Can I cross-compile my application to a mobile platform or WASM?</a></h3>
<p>FLTK currently doesn't support WASM nor iOS. It has experimental support for Android (YMMV). It is focused on desktop applications.</p>
<h2 id="licensing"><a class="header" href="#licensing">Licensing</a></h2>
<h3 id="can-i-use-this-crate-in-a-commercial-application"><a class="header" href="#can-i-use-this-crate-in-a-commercial-application">Can I use this crate in a commercial application?</a></h3>
<p>Yes. This crate has an MIT license which requires acknowledgment. FLTK (the C++ library) is licensed under the LGPL license with an exception allowing static linking for commercial/closed-source use. You can find the full terms of both licenses here:</p>
<ul>
<li><a href="https://github.com/fltk/fltk/blob/master/COPYING">COPYING</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/blob/master/LICENSE">LICENSE</a></li>
</ul>
<h2 id="alignment"><a class="header" href="#alignment">Alignment</a></h2>
<h3 id="why-cant-i-align-input-or-output-text-to-the-right"><a class="header" href="#why-cant-i-align-input-or-output-text-to-the-right">Why can't I align input or output text to the right?</a></h3>
<p>FLTK has some known issues with text alignment.</p>
<h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<h3 id="do-you-plan-on-supporting-multithreading-or-asyncawait"><a class="header" href="#do-you-plan-on-supporting-multithreading-or-asyncawait">Do you plan on supporting multithreading or async/await?</a></h3>
<p>FLTK supports multithreaded and concurrent applications. See the examples dir and the <a href="https://github.com/fltk-rs/demos">fltk-rs demos repo</a> for examples on usage with threads, messages, async_std and tokio (web-todo examples).</p>
<h3 id="should-i-explicitly-call-applock-and-appunlock"><a class="header" href="#should-i-explicitly-call-applock-and-appunlock">Should I explicitly call app::lock() and app::unlock()?</a></h3>
<p>fltk-rs surrounds all mutating calls to widgets with a lock on the C++ wrapper side. Normally you wouldn't have to call app::lock() and app::unlock(). 
This depends however on the support of recursive mutexes in your system. 
If you notice haning in multithreaded applications, you might have to initialize threads (like xlib threads) by calling app::lock() once in your main thread. 
In that case, you can wrap widgets in an Arc<Mutex> or surround widget-mutating functions/methods with an app::lock and app::unlock. 
But that should rarely be required.</p>
<h2 id="windowing"><a class="header" href="#windowing">Windowing</a></h2>
<h3 id="why-does-fltk-exit-when-i-hit-the-escape-key"><a class="header" href="#why-does-fltk-exit-when-i-hit-the-escape-key">Why does FLTK exit when I hit the escape key?</a></h3>
<p>This is the default behavior in FLTK. You can easily override it by setting a callback for your main window:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    wind.set_callback(|_| {
        if fltk::app::event() == fltk::enums::Event::Close {
            app::quit(); // Which would close using the close button. You can also assign other keys to close the application
        }
    });
<span class="boring">}
</span></code></pre></pre>
<h2 id="panicscrashes"><a class="header" href="#panicscrashes">Panics/Crashes</a></h2>
<h3 id="my-app-panics-when-i-try-to-handle-events-how-can-i-fix-it"><a class="header" href="#my-app-panics-when-i-try-to-handle-events-how-can-i-fix-it">My app panics when I try to handle events, how can I fix it?</a></h3>
<p>This is due to a debug_assert which checks that the involved widget and the window are capable of handling events. Although most events would be handled correctly, some events require that the aforementioned conditions be met. Thus it is advisable to place your event handling code after the main drawing is done, i.e after calling your main window's show() method. Another point is that event handling and drawing should be done in the main thread. Panics accross FFI boundaries are undefined behavior, as such, the wrapper never throws. Furthermore, all panics which might arise in callbacks are caught on the Rust side using catch_unwind.</p>
<h2 id="memory-and-unsafety"><a class="header" href="#memory-and-unsafety">Memory and unsafety</a></h2>
<h3 id="how-memory-safe-is-fltk-rs"><a class="header" href="#how-memory-safe-is-fltk-rs">How memory-safe is fltk-rs?</a></h3>
<p>The callback mechanism consists of a closure as a void pointer with a shim which dereferences the void pointer into a function pointer and calls the function. This is technically undefined behavior, however most implementations permit it and it's the method used by most wrappers to handle callbacks across FFI boundaries. <a href="https://rust-lang.github.io/unsafe-code-guidelines/layout/function-pointers.html#representation">link</a></p>
<p>As stated before, panics accross FFI boundaries are undefined behavior, as such, the C++ wrapper never throws. Furthermore, all panics which might arise in callbacks are caught on the Rust side using catch_unwind.</p>
<p>FLTK manages it's own memory. Any widget is automatically owned by a parent which does the book-keeping as well and deletion, this is the enclosing widget implementing GroupExt such as windws etc. This is done in the C++ FLTK library itself. Any constructed widget calls the current() method which detects the enclosing group widget, and calls its add() method rending ownership to the group widget. Upon destruction of the group widget, all owned widgets are freed. Also all widgets are wrapped in a mutex for all mutating methods, and their lifetimes are tracked using an Fl_Widget_Tracker, That means widgets have interior mutability as if wrapped in an Arc&lt;Mutex<widget>&gt; and have a tracking pointer to detect deletion. Cloning a widget performs a memcpy of the underlying pointer and allows for interior mutability; it does not create a new widget.
Images are reference-counted. All mutating methods are wrapped in locks.
This locking might lead to some performance degradation as compared to the original FLTK library, it does allow for multithreaded applications, and is necessary in an FLTK (C++) application if it also required threading.</p>
<p>Overriding drawing methods will box data to be sent to the C++ library, so the data should optimally be limited to widgets or plain old data types to avoid unnecessary leaks if a custom drawn widget might be deleted during the lifetime of the program.</p>
<h3 id="can-i-get-memory-leaks-with-fltk-rs"><a class="header" href="#can-i-get-memory-leaks-with-fltk-rs">Can I get memory leaks with fltk-rs?</a></h3>
<p>Non-parented widgets that can no longer be accessed are a memory leak. Otherwise, as mentioned in the previous section all parented widgets lifetimes' are managed by the parent.
An example of a leaking widget:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let a = app::App::default();
    let mut win = window::Window::default();
    win.end();
    win.show();

    {
        button::Button::default(); // this leaks since it's not parented by the window, and has no handle in main
    }
}
</code></pre></pre>
<p>A more subtle cause of leaks, is removing a widget from a group, then the scope ends without it being added to another group or deleted:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let a = app::App::default();
    let mut win = window::Window::default();
    {
        button::Button::default(); // This doesn't leak since the parent is the window
    }
    win.end();
    win.show();

    {
        win.remove_by_index(0); // the button leaks here since it's removed and we no longer have access to it
    }
}
</code></pre></pre>
<h3 id="why-is-fltk-rs-using-so-much-unsafe-code"><a class="header" href="#why-is-fltk-rs-using-so-much-unsafe-code">Why is fltk-rs using so much unsafe code?</a></h3>
<p>Interfacing with C++ or C code can't be reasoned about by the Rust compiler, so the unsafe keyword is needed.</p>
<h3 id="is-fltk-rs-panicexception-safe"><a class="header" href="#is-fltk-rs-panicexception-safe">Is fltk-rs panic/exception-safe?</a></h3>
<p>FLTK (C++) doesn't throw exceptions, neither do the C wrapper (cfltk) nor the fltk-sys crate. The higher level fltk crate, which wraps fltk-sys, is not exception-safe since it uses asserts internally after various operations to ensure memory-safety. An example is a widget constructor which checks that the returned pointer (from the C++ side) is not null from allocation failure. It also asserts all widget reads/writes are happening on valid (not deleted) widgets.
Also any function sending a string across FFI is checked for interal null bytes. For such functions, the developer can perform a sanity check on passed strings to make sure they're valid UTF-8 strings, or check that a widget was not deleted prior to accessing a widget. That said, all functions passed as callbacks to be handled by the C++ side are exception-safe.</p>
<h3 id="are-there-any-environment-variables-which-can-affect-the-build-or-behavior"><a class="header" href="#are-there-any-environment-variables-which-can-affect-the-build-or-behavior">Are there any environment variables which can affect the build or behavior?</a></h3>
<ul>
<li><code>CFLTK_TOOLCHAIN=&lt;path&gt;</code> allows passing the path to a CMake file acting as a CMAKE_TOOLCHAIN_FILE, this allows passing extra info to cmake if needed.</li>
<li><code>CFLTK_WAYLAND_ONLY=&lt;1 or 0&gt;</code> allows building for wayland only without directly linking X11 libs nor relying on their headers for the build process. This only works with the <code>use-wayland</code> feature flag.</li>
<li><code>CFLTK_BUNDLE_DIR=&lt;path&gt;</code> allows passing a path of prebuilt cfltk and fltk static libs, useful for when a customized build of fltk is needed, or for targetting other arches when building with the <code>fltk-bundled</code> flag.</li>
<li><code>CFLTK_BUNDLE_URL=&lt;url&gt;</code> similar to above but allows passing a url which will directs the build script to download from the passed url.</li>
<li><code>FLTK_BACKEND=&lt;x11 or wayland&gt;</code> allows choosing the backend of your hybrid X11/wayland FLTK app. This only works for apps built with <code>use-wayland</code> feature flag. </li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Please refer to the <a href="https://github.com/fltk-rs/fltk-rs/blob/master/CONTRIBUTING.md">CONTRIBUTING</a> page for further information.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
