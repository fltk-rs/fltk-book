<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>fltk book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="Home.html"><strong aria-hidden="true">1.</strong> 开始</a></li><li class="chapter-item expanded "><a href="Setup.html"><strong aria-hidden="true">2.</strong> 配置</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Cross-Compiling.html"><strong aria-hidden="true">2.1.</strong> 交叉编译</a></li><li class="chapter-item expanded "><a href="Fluid.html"><strong aria-hidden="true">2.2.</strong> 使用 Fluid</a></li></ol></li><li class="chapter-item expanded "><a href="The-App-struct.html"><strong aria-hidden="true">3.</strong> App 结构</a></li><li class="chapter-item expanded "><a href="Windows.html"><strong aria-hidden="true">4.</strong> 窗口 Windows</a></li><li class="chapter-item expanded "><a href="Widgets.html"><strong aria-hidden="true">5.</strong> 组件 Widgets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Buttons.html"><strong aria-hidden="true">5.1.</strong> 按钮 Buttons</a></li><li class="chapter-item expanded "><a href="Labels.html"><strong aria-hidden="true">5.2.</strong> 标签 Labels</a></li><li class="chapter-item expanded "><a href="Group-widgets.html"><strong aria-hidden="true">5.3.</strong> 组控件 Group widgets</a></li><li class="chapter-item expanded "><a href="Menus.html"><strong aria-hidden="true">5.4.</strong> 菜单 Menus</a></li><li class="chapter-item expanded "><a href="Input-&-Output.html"><strong aria-hidden="true">5.5.</strong> 输入输出 Input & Output</a></li><li class="chapter-item expanded "><a href="Valuators.html"><strong aria-hidden="true">5.6.</strong> 估值器 Valuators</a></li><li class="chapter-item expanded "><a href="Text.html"><strong aria-hidden="true">5.7.</strong> 文字 Text</a></li><li class="chapter-item expanded "><a href="Browsers.html"><strong aria-hidden="true">5.8.</strong> 阅览器 Browsers</a></li><li class="chapter-item expanded "><a href="Trees.html"><strong aria-hidden="true">5.9.</strong> 树 Trees</a></li><li class="chapter-item expanded "><a href="Tables.html"><strong aria-hidden="true">5.10.</strong> 表格 Tables</a></li><li class="chapter-item expanded "><a href="Custom-Widgets.html"><strong aria-hidden="true">5.11.</strong> 自定义组件 Custom widgets</a></li></ol></li><li class="chapter-item expanded "><a href="Dialogs.html"><strong aria-hidden="true">6.</strong> 对话框 Dialogs</a></li><li class="chapter-item expanded "><a href="Images.html"><strong aria-hidden="true">7.</strong> 图像 Images</a></li><li class="chapter-item expanded "><a href="Events.html"><strong aria-hidden="true">8.</strong> 事件 Events</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Drag-&-Drop.html"><strong aria-hidden="true">8.1.</strong> 拖放 Drag & Drop</a></li><li class="chapter-item expanded "><a href="State-Management.html"><strong aria-hidden="true">8.2.</strong> 状态管理器 State Management</a></li></ol></li><li class="chapter-item expanded "><a href="Layouts.html"><strong aria-hidden="true">9.</strong> 布局 Layouts</a></li><li class="chapter-item expanded "><a href="Style.html"><strong aria-hidden="true">10.</strong> 样式 Style</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Colors.html"><strong aria-hidden="true">10.1.</strong> 颜色 Colors</a></li><li class="chapter-item expanded "><a href="FrameTypes.html"><strong aria-hidden="true">10.2.</strong> FrameTypes</a></li><li class="chapter-item expanded "><a href="Fonts.html"><strong aria-hidden="true">10.3.</strong> 字体 Fonts</a></li><li class="chapter-item expanded "><a href="Drawing.html"><strong aria-hidden="true">10.4.</strong> Drawing things</a></li><li class="chapter-item expanded "><a href="Styling.html"><strong aria-hidden="true">10.5.</strong> Styling</a></li></ol></li><li class="chapter-item expanded "><a href="Animations.html"><strong aria-hidden="true">11.</strong> 动画 Animations</a></li><li class="chapter-item expanded "><a href="FAQ.html"><strong aria-hidden="true">12.</strong> FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">fltk book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="开始"><a class="header" href="#开始">开始</a></h1>
<p>欢迎来到 <a href="https://github.com/fltk-rs/fltk-rs">fltk-rs</a> !</p>
<p>这是为 <a href="https://crates.io/crates/fltk">fltk crate</a> 而写的一本说明书。 其他资源有:</p>
<ul>
<li><a href="https://docs.rs/fltk">官方文档</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs#tutorials">视频</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/discussions">讨论、社区</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/tree/master/fltk/examples">示例</a></li>
<li><a href="https://github.com/fltk-rs/demos">示范</a></li>
<li><a href="https://github.com/tdryer/7guis-fltk-rs">7guis-fltk-rs</a></li>
<li><a href="https://github.com/wyhinton/FLTK-RS-Examples">FLTK-RS-Examples</a></li>
<li>Erco's FLTK cheat <a href="http://seriss.com/people/erco/fltk/">page</a>, which is an excellent FLTK C++ reference. </li>
</ul>
<p><a href="https://github.com/fltk/fltk">FLTK</a> 是一个跨平台的轻量级 gui库。
该库自身是使用 C++98编写的，具有高度可移植性。 fltk crate 则使用 rust实现，并使用FFI来调用 使用C89和C++11编写的FLTK封装器 <a href="https://github.com/MoAlyousef/cfltk">cfltk</a>。</p>
<p>该库的构造及其简洁，习惯使用面向对象gui库的开发者会感觉到很熟悉。封装器本身也遵循同样的模式，因为方法的名称与C++的名称相同或相似，这使得文档大大简化。同时也让参考FLTK的C++文档变得非常简单，因为这些方法基本上是相互对应的。</p>
<p>C++：</p>
<pre><code class="language-c++">int main() {
    auto wind = new Fl_Window(100, 100, 400, 300, &quot;My Window&quot;);
    wind-&gt;end();
    wind-&gt;show();
}
</code></pre>
<p>Rust：</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let wind = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    wind.end();
    wind.show();
}
</code></pre></pre>
<p>为什么选择 FLTK ？</p>
<ul>
<li>轻量。二进制文件简小，strip 后仅有大约1MB。 <a href="https://szibele.com/memory-footprint-of-gui-toolkits/">低内存占用</a>。</li>
<li>快速。安装快、构建快、启动快、运行快。</li>
<li>仅有一个运行文件。不需要配置DDL库。</li>
<li>向前兼容，支持旧架构。</li>
<li>FLTK的允许性许可证，允许闭源应用静态链接。</li>
<li>多主题 (4款默认支持的主题: Base, GTK, Plastic and Gleam)，以及 <a href="https://crates.io/crates/fltk-theme">fltk-theme</a> 中的其他主题。</li>
<li>提供了约80个可供自定义的 widget。</li>
<li>内置图像支持。</li>
</ul>
<h2 id="用法"><a class="header" href="#用法">用法</a></h2>
<p>将以下代码添加到你的 Cargo.toml 文件:</p>
<pre><code class="language-toml">[dependencies]
fltk = &quot;^1.2&quot;
</code></pre>
<p>使用捆绑的库（适用于 x64 windows (msvc &amp; gnu (msys2)), x64 linux &amp; macos）:</p>
<pre><code class="language-toml">[dependencies]
fltk = { version = &quot;^1.2&quot;, features = [&quot;fltk-bundled&quot;] }
</code></pre>
<p>该库会自动构建并静态链接到你的二进制文件中。</p>
<p>我们需要导入必要的 fltk 模块，以使我们的第一个rust代码示例工作：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, window::Window};
fn main() {
    let wind = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    wind.end();
    wind.show();
}
</code></pre></pre>
<p>如果你运行代码样本，你可能会发现什么都没有发生。实际上，我们还需要运行事件循环（event loop），这相当于在C++中使用<code>Fl::run()</code>：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, prelude::*, window::Window};
fn main() {
    let a = app::App::default();
    let wind = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    wind.end();
    wind.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>我们实例化了 App 结构，它初始化了 runtime 和 styles，在main的最后，我们调用了 run() 函数。</p>
<h2 id="为本书做贡献"><a class="header" href="#为本书做贡献">为本书做贡献</a></h2>
<p>这本书是使用 <a href="https://github.com/rust-lang/mdBook">mdbook</a>，根据 <a href="https://github.com/fltk-rs/fltk-book">fltk-book</a> 仓库的内容生成的。本书的作者为 <strong>Mohammed Alyousef</strong>，由 <strong>Flatig L</strong> 翻译为中文</p>
<p>因此，你可能需要运行 <code>cargo install mdbook</code>. 更多说明可以在fltk-book的README文件和mdbook的 <a href="https://rust-lang.github.io/mdBook/">用户指南</a> 中找到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置"><a class="header" href="#配置">配置</a></h1>
<p>请确保 Rust (version &gt; 1.45)，CMake (version &gt; 3.11)，Git 和一个 C++11 编译器已安装并在 PATH 中配置，以此通过源代码构建跨平台程序。这个 crate 还在选定的平台上提供了fltk的捆绑形式，这可以使用fltk-bundle feature flag 来启用（这需要curl和tar来下载并解包捆绑的库）。如果你安装了 ninja-build ，你可以使用 &quot;use-ninja&quot; feature来启用它。这应该会大大加快构建时间。</p>
<ul>
<li>Windows: 
<ul>
<li>MSVC: Windows SDK</li>
<li>Gnu: 无依赖</li>
</ul>
</li>
<li>MacOS: 无依赖</li>
<li>Linux: 开发时需要安装 X11 and OpenGL 头文件。这些库本身可以在具有图形用户界面的Linux发行版上使用。</li>
</ul>
<p>基于 Debian 的Linux发行版，运行：</p>
<pre><code>sudo apt-get install libx11-dev libxext-dev libxft-dev libxinerama-dev libxcursor-dev libxrender-dev libxfixes-dev libpango1.0-dev libgl1-mesa-dev libglu1-mesa-dev
</code></pre>
<p>基于 RHEL的Linux发行版，运行：</p>
<pre><code>sudo yum groupinstall &quot;X Software Development&quot; &amp;&amp; yum install pango-devel libXinerama-devel
</code></pre>
<p>基于 Arch 的Linux发行版，运行：</p>
<pre><code>sudo pacman -S libx11 libxext libxft libxinerama libxcursor libxrender libxfixes pango cairo libgl mesa --needed
</code></pre>
<p>Alpine Linux：</p>
<pre><code>apk add pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
</code></pre>
<ul>
<li>Android： Android Studio，Android Sdk， Android Ndk。</li>
</ul>
<h2 id="具体配置细节"><a class="header" href="#具体配置细节">具体配置细节</a></h2>
<p>本节假设你甚至没有安装Rust，我们分几个不同的环境讨论：</p>
<h3 id="windows-msvc-toolchain"><a class="header" href="#windows-msvc-toolchain">Windows (MSVC toolchain)</a></h3>
<ul>
<li>访问rust语言官网的 <a href="https://www.rust-lang.org/learn/get-started">开始</a>。</li>
<li>按照 &quot;Visual Studio C++ build tools &quot;的链接，下载MSVC编译器和Windows sdk。</li>
<li>使用安装器安装：</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/37966791/116013495-2dff8800-a639-11eb-8e4c-8c6228e00abc.png" alt="image" /></p>
<p>确保选中这些：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/116013520-48d1fc80-a639-11eb-934a-fac6609135b4.png" alt="image" /></p>
<ul>
<li>你也需要在前面的列表中检查是否有CMake，或者点击这里直接下载 <a href="https://cmake.org/download/">Cmake</a>。</li>
<li>如果你还没有GIt，请点击下载 <a href="https://git-scm.com/downloads">Git</a>。</li>
<li>从 rust-lang.org 网站上，下载适合你的架构的正确的rustup安装程序。</li>
<li>一旦你都准备好了，你就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>作为依赖，然后开始构建你的应用程序。</li>
</ul>
<h3 id="windows-gnu-toolchain"><a class="header" href="#windows-gnu-toolchain">Windows (gnu toolchain)</a></h3>
<p>如果你还没有msys2，点击这里安装 <a href="https://www.msys2.org/">msys2</a>。</p>
<ul>
<li>你可以通过pacman软件包管理器获得Rust工具链，或者通过前面所说的rustup。然而，在安装过程中需要指定使用gnu工具链（而不是默认安装MSVC工具链）。
工具链也应该反映你的机器的结构。例如，一台64位机器应该安装x86_64-pc-windows-gnu工具链。
如果你决定通过软件包管理器来获得Rust，请确保你得到的是mingw的变体，并且有正确的MINGW_PACKAGE_PREFIX（对于64位机器，这个环境变量相当于mingw-w64-x86_64）。</li>
<li>假设你通过pacman安装了所有东西，打开mingw shell（不是msys2 shell，它可以在msys2安装目录下找到，或者通过<code>source shell mingw64</code>）并运行以下内容：</li>
</ul>
<pre><code>pacman -S curl tar git $MINGW_PACKAGE_PREFIX-rust $MINGW_PACKAGE_PREFIX-gcc $MINGW_PACKAGE_PREFIX-cmake $MINGW_PACKAGE_PREFIX-make --needed
</code></pre>
<p>如果你打算通过use-ninja使用ninja，你可以用$MINGW_PACKAGE_PREFIX-ninja替换$MINGW_PACKAGE_PREFIX-make。</p>
<ul>
<li>一旦你都准备好了，你就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>作为依赖，然后开始构建你的应用程序。</li>
</ul>
<h3 id="macos"><a class="header" href="#macos">MacOS</a></h3>
<ul>
<li>要获得Xcode命令行工具（它带有C++编译器），运行下列代码：</li>
</ul>
<pre><code>xcode-select --install
</code></pre>
<p>​	之后按照说明进行。或者，你也可以通过Homebrew安装clang或gcc：</p>
<ul>
<li>为了下载CMake，你可以点击这里下载<a href="https://cmake.org/download/">CMake</a>。</li>
</ul>
<p>或者，也可以跟上面一样使用Homebrew：</p>
<pre><code>brew install cmake
</code></pre>
<ul>
<li>安装Rust Toolchain：</li>
</ul>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>按照默认设置进行即可。</p>
<ul>
<li>一旦你都准备好了，你就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>作为依赖，然后开始构建你的应用程序。</li>
</ul>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<ul>
<li>使用你的软件包管理器安装一个C++编译器，还有CMake，make，git。
以Debian/Ubuntu 为例：</li>
</ul>
<pre><code>sudo apt-get install g++ cmake git make
</code></pre>
<ul>
<li>要获得FLTK的开发依赖项，你也可以使用你的软件包管理器。
对基于Debian的GUI发行版，运行下列代码：</li>
</ul>
<pre><code>sudo apt-get install libx11-dev libxext-dev libxft-dev libxinerama-dev libxcursor-dev libxrender-dev libxfixes-dev libpango1.0-dev libgl1-mesa-dev libglu1-mesa-dev
</code></pre>
<p>对于基于RHEL的GUI发行版，运行下列代码：</p>
<pre><code>sudo yum groupinstall &quot;X Software Development&quot; &amp;&amp; yum install pango-devel libXinerama-devel
</code></pre>
<p>对于基于Arch Linux的GUI发行版，运行下列代码：</p>
<pre><code>sudo pacman -S libx11 libxext libxft libxinerama libxcursor libxrender libxfixes pango cairo libgl mesa --needed
</code></pre>
<p>对于Alpine linux：</p>
<pre><code>apk add pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
</code></pre>
<ul>
<li>安装Rust Toolchain：</li>
</ul>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>按照默认设置进行即可。</p>
<ul>
<li>一旦你都准备好了，你就可以用<code>cargo new</code>创建一个Rust项目，在Cargo.toml中添加<code>fltk</code>作为依赖，然后开始构建你的应用程序。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="交叉编译"><a class="header" href="#交叉编译">交叉编译</a></h1>
<h2 id="使用预置bundle"><a class="header" href="#使用预置bundle">使用预置Bundle</a></h2>
<p>如果你要为下列平台编译的话，很幸运，它们已经有一个预置包了：</p>
<ul>
<li>x86_64-pc-windows-gnu</li>
<li>x86_64-pc-windows-msvc</li>
<li>x86_64-apple-darwin</li>
<li>aarch64-apple-darwin</li>
<li>x86_64-unknown-linux-gnu</li>
<li>aarch64-unknown-linux-gnu</li>
</ul>
<p>通过rustup添加target，然后调用build：</p>
<pre><code>rustup target add &lt;your target&gt; # 使用上列目标平台替换target
cargo build --target=&lt;your target&gt; --features=fltk-bundled
</code></pre>
<p>对于arch64-unknonw-linux-gnu，你可能需要验证链接器：</p>
<pre><code>CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc cargo build --target=&lt;your target&gt; --features=fltk-bundled
</code></pre>
<h2 id="使用交叉编译-cc-toolchain"><a class="header" href="#使用交叉编译-cc-toolchain">使用交叉编译 C/C++ toolchain</a></h2>
<p>我们的想法是，你需要一个C/C++交叉编译器和一个正如前面的方案中提到的，通过<code>rustup target add</code>安装的Rust target。</p>
<p>对于Windows and MacOS，系统编译器已经支持为特定的架构为目标编译。例如，在MacOS上，如果你已经可以使用你的系统编译器构建fltk应用程序，你可以针对不同的架构使用下列命令进行编译（假设你有一个intel x86_64 mac）：</p>
<pre><code>rustup target add aarch64-apple-darwin
cargo build --target=arch64-apple-darwin
</code></pre>
<h3 id="linux-to-64-bit-windows"><a class="header" href="#linux-to-64-bit-windows">Linux to 64-bit Windows</a></h3>
<p>假设你想从Linux交叉编译到64位Windows，在此之前你已经能够在你的主机上进行编译。</p>
<ul>
<li>你需要使用下令命令添加Rust target：</li>
</ul>
<pre><code>rustup target add x86_64-pc-windows-gnu # 基于arch
</code></pre>
<ul>
<li>安装一个C/C++ 交叉编译器，比如Mingw toolchain。在基于Debian的发行部上，你可以运行：</li>
</ul>
<pre><code>apt-get install mingw-w64 # 或者 gcc-mingw-w64-x86-64
</code></pre>
<p>在基于RHEL的发行部上：</p>
<pre><code>dnf install mingw64-gcc
</code></pre>
<p>在Arch上：</p>
<pre><code>pacman -S mingw-w64-gcc
</code></pre>
<p>在Alpine上：</p>
<pre><code>apk add mingw-w64-gcc
</code></pre>
<ul>
<li>在你项目根目录添加一个<code>.cargo/config.toml</code> （如果你想全局设置的话，也可以是HOME目录）并指定交叉链接器和归档管理器：</li>
</ul>
<pre><code class="language-toml"># .cargo/config.toml
[target.x86_64-pc-windows-gnu]
linker = &quot;x86_64-w64-mingw32-gcc&quot;
ar = &quot;x86_64-w64-mingw32-gcc-ar&quot;
</code></pre>
<ul>
<li>运行build：</li>
</ul>
<pre><code>cargo build --target=x86_64-pc-windows-gnu
</code></pre>
<h3 id="x64-linux-gnu-to-aarch64-linux-gnu"><a class="header" href="#x64-linux-gnu-to-aarch64-linux-gnu">x64 linux-gnu to aarch64 linux-gnu</a></h3>
<p>另一个例子是，从基于x86_64 debian的发行版到基于arm64 debian的发行部：
假设你已经安装了cmake：</p>
<ul>
<li>你需要使用下列命令添加 rust target：</li>
</ul>
<pre><code>rustup target add aarch64-unknown-linux-gnu
</code></pre>
<ul>
<li>安装一个C/C++ 交叉编译器，比如Mingw toolchain。在基于Debian的发行版上，你可以运行：</li>
</ul>
<pre><code>apt-get install g++-aarch64-linux-gnu
</code></pre>
<ul>
<li>为你的系统添加需要的架构：</li>
</ul>
<pre><code>sudo dpkg --add-architecture arm64
</code></pre>
<ul>
<li>你可能需要将下列镜像添加到/etc/apt/sources.list：</li>
</ul>
<pre><code>sudo sed -i &quot;s/deb http/deb [arch=amd64] http/&quot; /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s) main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-security main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-backports main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-updates main multiverse universe&quot; | sudo tee -a /etc/apt/sources.list
</code></pre>
<p>第一条命令改变了当前的镜像， 以反映你当前的 amd64 系统。其他命令则将 arm64 的端口添加到 /etc/apt/sources.list 文件中。</p>
<ul>
<li>更新你的包管理器数据库：</li>
</ul>
<pre><code>sudo apt-get update
</code></pre>
<ul>
<li>为你的目标平台安装需要的依赖：</li>
</ul>
<pre><code>sudo apt-get install libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 libxinerama-dev:arm64 libxcursor-dev:arm64 libxrender-dev:arm64 libxfixes-dev:arm64 libpango1.0-dev:arm64 libgl1-mesa-dev:arm64 libglu1-mesa-dev:arm64 libasound2-dev:arm64
</code></pre>
<p>注意软件包名称中的<code>:arm64</code>后缀。</p>
<ul>
<li>运行build：</li>
</ul>
<pre><code>CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc cargo build --target=aarch64-unknown-linux-gnu
</code></pre>
<h2 id="使用cross"><a class="header" href="#使用cross">使用cross</a></h2>
<p>如果你已经安装了docker，你可以试试 <a href="https://github.com/cross-rs/cross">cross</a>：</p>
<pre><code>cargo install cross
cross build --target=x86_64-pc-windows-gnu # replace with your target, the Docker daemon has to be running, no need to add via rustup
</code></pre>
<p>如果你的target需要外部依赖，比如在Linux上，你将必须创建一个自定义的docker镜像，并通过Cross.toml文件将其用于交叉编译。例如，对于一个有如下结构的项目来说。</p>
<pre><code>myapp
     |_src
     |    |_main.rs    
     |
     |_Cargo.toml
     |
     |_Cross.toml
     |
     |_arm64-dockerfile
</code></pre>
<p>arm64-dockerfile（名称并不重要，只要确保Cross.toml指向该文件）的内容：</p>
<pre><code class="language-dockerfile">FROM ghcr.io/cross-rs/aarch64-unknown-linux-gnu:latest

RUN dpkg --add-architecture arm64 &amp;&amp; \
    apt-get update &amp;&amp; \
    apt-get install --assume-yes --no-install-recommends \
    libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 \
    libxinerama-dev:arm64 libxcursor-dev:arm64 \
    libxrender-dev:arm64  libxfixes-dev:arm64  libgl1-mesa-dev:arm64 \
    libglu1-mesa-dev:arm64 libasound2-dev:arm64 libpango1.0-dev:arm64
</code></pre>
<p>注意库包名称后面附加的架构，如：libx11-dev:arm64。</p>
<p>Cross.toml的内容：</p>
<pre><code class="language-toml">[target.aarch64-unknown-linux-gnu]
dockerfile = &quot;./arm64-dockerfile&quot;
</code></pre>
<p>最后运行cross：</p>
<pre><code>cross build --target=aarch64-unknown-linux-gnu
</code></pre>
<p>第一次运行可能会花较长时间</p>
<h2 id="使用docker"><a class="header" href="#使用docker">使用docker</a></h2>
<p>直接使用目标平台的docker镜像可以让你免去使用cross交叉编译到不同linux目标的麻烦。
你需要一个Docker文件，它可以拉出你想要的target，并安装Rust和C++工具链以及所需的依赖。
例如，为allpine linux构建：</p>
<pre><code class="language-dockerfile">FROM alpine:latest AS alpine_build
RUN apk add rust cargo git cmake make g++ pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
COPY . .
RUN cargo build --release

FROM scratch AS export-stage
COPY --from=alpine_build target/release/&lt;your binary name&gt; .
</code></pre>
<p>然后运行：</p>
<pre><code>DOCKER_BUILDKIT=1 docker build --file Dockerfile --output out .
</code></pre>
<p>你的二进制文件将在<code>./out</code>目录中。
注意在alpine上，如果你通过rustup安装Rust，你可能需要在你的dockerfile中把musl-gcc和musl-g++指向相应的工具链（在运行<code>cargo build</code>之前）。</p>
<pre><code class="language-dockerfile">RUN ln -s /usr/bin/x86_64-alpine-linux-musl-gcc /usr/bin/musl-gcc
RUN ln -s /usr/bin/x86_64-alpine-linux-musl-g++ /usr/bin/musl-g++
</code></pre>
<p>另一个例子是将 amd64 linux-gnu 编译成 arm64 linux-gnu：</p>
<pre><code class="language-dockerfile">FROM ubuntu:latest AS ubuntu_build

RUN apt-get update -qq
RUN	apt-get install -y --no-install-recommends lsb-release g++-aarch64-linux-gnu g++ cmake curl tar git 
RUN	dpkg --add-architecture arm64 
RUN sed -i &quot;s/deb http/deb [arch=amd64] http/&quot; /etc/apt/sources.list
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s) main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-security main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-backports main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN echo &quot;deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-updates main multiverse universe&quot; | tee -a /etc/apt/sources.list 
RUN	apt-get update -qq &amp;&amp; apt-get install -y --no-install-recommends libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 libxinerama-dev:arm64 libxcursor-dev:arm64 libxrender-dev:arm64 libxfixes-dev:arm64 libpango1.0-dev:arm64 libgl1-mesa-dev:arm64 libglu1-mesa-dev:arm64 libasound2-dev:arm64
RUN curl https://sh.rustup.rs -sSf | sh -s -- --default-toolchain stable --profile minimal -y

ENV PATH=/root/.cargo/bin:$PATH

RUN rustup target add aarch64-unknown-linux-gnu
# works around an include path issue in some debian versions
RUN apt-get install -y libharfbuzz-dev libpango1.0-dev --no-install-recommends &amp;&amp; cp /usr/include/harfbuzz/*.h /usr/include/aarch64-linux-gnu

COPY . .

RUN CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc cargo build --release --target=aarch64-unknown-linux-gnu

FROM scratch AS export-stage
COPY --from=ubuntu_build target/aarch64-unknown-linux-gnu/release/&lt;your binary 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fluid"><a class="header" href="#fluid">Fluid</a></h1>
<p>FLTK提供了一个名为FLUID的，所见即所得的快速GUI应用开发工具，用它可以创建GUI应用。
目前在youtube上有一个使用基于Rust使用它的视频教程。
<a href="https://www.youtube.com/watch?v=k_P0wG3-dNk">Use FLUID (RAD tool) with Rust</a></p>
<p>fl2rust crate将Fluid生成的.fl文件翻译成Rust代码，并编译进你的程序中。
要获取更多详细信息，请查看它的官方<a href="https://github.com/MoAlyousef/fl2rust">仓库</a>。</p>
<p>你可以使用cargo install 安装 fltk-fluid和fl2rust crates来获得FLUID。</p>
<pre><code>cargo install fltk-fluid
cargo install fl2rust
</code></pre>
<p>然后运行：</p>
<pre><code>fluid &amp;
</code></pre>
<p>你也可以通过你系统的包管理器获取Fluid，这样的话它将作为一个单独的包或fltk包的一部分。</p>
<p>目前，fl2rust并不能检查生成的Rust代码的正确性。它也只限于构造方法。</p>
<h2 id="用法-1"><a class="header" href="#用法-1">用法</a></h2>
<p>首先，你可以使用<code>cargo new app</code>创建一个新的Rust项目。
fl2rust将作为一个构建依赖项，被添加到你的项目中：</p>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
fltk = &quot;1&quot;

[build-dependencies]
fl2rust = &quot;0.4&quot;
</code></pre>
<p>然后就可以在build.rs文件中使用它（该文件在预编译时运行）来生成Rust代码。</p>
<pre><pre class="playground"><code class="language-rust edition2018">// build.rs
fn main() {
    use std::path::PathBuf;
    use std::env;
    println!(&quot;cargo:rerun-if-changed=src/myuifile.fl&quot;);
    let g = fl2rust::Generator::default();
    let out_path = PathBuf::from(env::var(&quot;OUT_DIR&quot;).unwrap());
    g.in_out(&quot;src/myuifile.fl&quot;, out_path.join(&quot;myuifile.rs&quot;).to_str().unwrap()).expect(&quot;Failed to generate rust from fl file!&quot;);
}
</code></pre></pre>
<p>我们将把fluid文件命名为myuifile.fl。我们告诉cargo，如果该文件被修改，就重新运行。我们将在我们的源代码目录创建文件，但如果你愿意，也可以为它创建自己的文件夹放进去。我们告诉生成器，让它接受fluid文件并生成一个myuifile.rs。这个文件是在OUT_DIR中生成的，所以你不会在你的src目录中看到它。
但是为了包含（include）它，你需要创建一个Rust源文件，它可以和我们输出的文件同名，并把它放在src目录中：</p>
<pre><code>touch src/myuifile.rs
</code></pre>
<p>我们将使用include！宏，从自动生成的文件中导入这些内容。</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/myuifile.rs
#![allow(unused_variables)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(clippy::needless_update)]

include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/myuifile.rs&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>然后我们就可以使用main.rs中的内容了：</p>
<pre><pre class="playground"><code class="language-rust edition2018">// src/main.rs
use fltk::{prelude::*, *};
mod myuifile;

fn main() {
    let app = app::App::default();
    app.run().unwrap();
}
</code></pre></pre>
<p>现在到了gui部分。打开fluid：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fltk-fluid &amp; #or just fluid if installed from a package manager
<span class="boring">}
</span></code></pre></pre>
<p>“&amp;”符号让shell把它作为一个分离进程打开，所以我们仍然可以用我们的shell来编译我们的代码。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146925955-ac778726-1398-4ea2-8e46-a2f8fff89804.png" alt="image" /></p>
<p>我们第一眼看到的是一个空窗口和一个菜单栏。我们在这里的第一步是创建一个类：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926284-cd9f21ce-b4b1-4009-9766-32876a08de98.png" alt="image" /></p>
<p>这将弹出一个对话框，我们直接点击 &quot;OK &quot;让它使用默认的名称（UserInterface）。现在你会看到我们的类出现在列表中：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926505-545f26c1-ac7d-4f10-94a9-2d0c16875d4e.png" alt="image" /></p>
<p>(我们已经扩展了这个窗口)</p>
<p>接下来，再次按下new键，我们将为我们的类添加一个构造函数：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926749-9199bd23-0346-4286-993f-bfb7588ae420.png" alt="image" /></p>
<p>同样使用它的默认名称，即<code>make_window()</code>。</p>
<p>接下来我们将添加一个窗口：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146926970-769ad7a1-9d03-457a-91f7-d6a18e2ba3b0.png" alt="image" /></p>
<p>现在弹出了一个新的窗口，我们可以拖动边框将其放大一些：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146927099-ff014e0d-8ea0-4f90-a500-882eb7b49bb2.png" alt="image" /></p>
<p>双击窗口会弹出一个对话框，我们可以改变窗口的gui属性（在GUI标签下）、风格（在Style标签下）和类属性（在C++标签下）。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146927520-c2ee18b1-0d17-43cd-93eb-edbf725ddf6c.png" alt="image" /></p>
<p>我们在GUI标签中给这个窗口一个<code>My Window</code>标签 ，然后在Style标签中把颜色改为白色：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146932899-6a4419ae-9c91-4b48-a363-d87c85b01778.png" alt="image" /></p>
<p>在C++标签下，我们给它一个变量名<code>my_win</code>。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146932794-7e1a2819-842d-45c7-88c8-be9fb728e805.png" alt="image" /></p>
<p>现在，我们的窗口可以通过<code>myuifile::UserInterface::my_win</code>访问。</p>
<p>现在左击窗口并添加一个Button（按钮）：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146928089-ad0454de-252e-4e81-9079-db0ef5c67c8f.png" alt="image" /></p>
<p>这将打开与之前相同的对话框，但这次我们选择按钮。在C++下，我们将给它一个变量名<code>btn</code>。在style下，我们将改变颜色和标签的颜色。然后在Gui下，我们将给它一个标签 &quot;click me&quot;。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146928419-a1a96e03-5b90-4aaa-8f70-9b17f76f9b9f.png" alt="image" /></p>
<p>可以拖动边框来调整大小，把按钮拖到任何想要的位置。Fluid有一个布局菜单，可以用它修改一些小部件（如果我们有很多按钮），使其具有相同的布局/大小...等。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146928654-43838e2a-aba8-4a24-8d70-1e25e1717c58.png" alt="image" /></p>
<p>我们现在点击<code>File/Save As...</code>将文件保存在src目录下，命名为srcmyuifile.fl。</p>
<p>现在可以运行<code>cargo run</code>来看看是否能编译通过，但我们还没有调用<code>make_window()</code>方法，所以暂时还不会看到任何东西。
现在你可以修改 src/main.rs 来显示窗口，并为我们的按钮添加一个回调。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};
mod myuifile;

fn main() {
    let app = app::App::default();
    let mut ui = myuifile::UserInterface::make_window();
    let mut win = ui.my_win.clone();
    ui.btn.set_callback(move |b| {
        b.set_label(&quot;clicked&quot;);
        win.set_label(&quot;Button clicked&quot;);
        println!(&quot;Works!&quot;);
    });
    app.run().unwrap();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="app-结构"><a class="header" href="#app-结构">App 结构</a></h1>
<p>crate在app模块中提供了一个App结构。初始化App结构可以初始化所有内部样式、字体和支持的图像类型。它还初始化了程序将要运行的多线程环境。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::*;

fn main() {
    let app = app::App::default();
    app.run().unwrap();
}
</code></pre></pre>
<p>run方法运行gui应用程序的事件循环（event loop）。
要对事件进行精细的控制，可以使用wait()方法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::*;

fn main() {
    let app = app::App::default();
    while app.wait() {
        // handle events
    }
}
</code></pre></pre>
<p>此外，App结构允许你使用with_scheme()初始器来设置程序的全局主题：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::*;

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);
    app.run().unwrap();
}
</code></pre></pre>
<p>这将使你的程序具有Gtk程序的样子。还有其他的内置方案，Basic、Plastic和Gleam。</p>
<p>App结构还负责在应用程序开始时使用load_system_fonts()方法加载系统字体。</p>
<p>一个典型的fltk-rs应用程序，将在创建任何部件和显示主窗口之前构建App结构。</p>
<p>任何在run()方法调用后添加的逻辑，将在事件循环结束后执行（通常是关闭应用程序的所有窗口时，或者调用quit()方法时）。该逻辑可能包括在必要时重启程序的逻辑。</p>
<p>除了App结构外，App模块本身还包含与你的程序的全局状态有关的结构和自由函数。其中包括设置背景和前景颜色、默认字体和大小等视觉效果、屏幕功能、剪贴板功能、全局处理器、应用事件、通道（channels）（发送器和接收器）和超时。</p>
<p>其中一些将在本书的其他部分讨论。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="窗口-windows"><a class="header" href="#窗口-windows">窗口 Windows</a></h1>
<p>FLTK会在它支持的系统平台上调用原生窗口，然后基本上通过自己的方法来绘制。它会在windows上调用HWND，在MacOS上调用NSWindow，在X11系统（linux, BSD）上调用XWindow。</p>
<p>Window 本身具有与FLTK提供的其他部件相同的接口，即WidgetExt trait，这将在下一页讨论。</p>
<p>让我们用到目前为止学到的东西来创建一个Window。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    my_window.end();
    my_window.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/100937363-f82ffa80-3503-11eb-8f3a-9afe34bdad59.jpg" alt="img1" /></p>
<p>调用new()函数需要五个参数：</p>
<ul>
<li><code>x</code> 以电脑屏幕最左侧为原点的水平距离。</li>
<li><code>y</code> 以电脑屏幕最左侧为原点的垂直距离。</li>
<li><code>width</code> window的宽度。</li>
<li><code>height</code> window的高度。</li>
<li><code>title</code> window标题。</li>
</ul>
<p>接下来注意对end()的调用。window，以及其他类型的widget，实现了GroupExt trait。实现该trait的这些部件将 持有 任何在call()和end()间创建的widget（通过new()创建串口时，隐式调用了begin()），或者作为其父widget。
下一个调用show()唤起了window，使其出现在显示屏上。</p>
<p>window可以被嵌入到其他window内：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut my_window2 = window::Window::new(10, 10, 380, 280, &quot;&quot;);
    my_window2.set_color(Color::Black);
    my_window2.end();
    my_window.end();
    my_window.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/100937446-139b0580-3504-11eb-8738-1e4161175d0b.jpg" alt="embed" /></p>
<p>在这里，第二个窗口，my_window2，被嵌入到第一个窗口，my_window里面。我们把它的颜色设为黑色，这样它才会被我们看到。注意，它的父窗口是第一个窗口。在父窗口之外创建第2个窗口才会创建两个独立的窗口，不要忘记还要调用show()：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    my_window.end();
    my_window.show();
    let mut my_window2 = window::Window::new(10, 10, 380, 280, &quot;&quot;);
    my_window2.end();
    my_window2.show();
    app.run().unwrap();
}
</code></pre></pre>
<p>可以使用my_window.set_border(false)方法实现无边框窗口：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/100937639-565cdd80-3504-11eb-8cf6-e135243c38b0.png" alt="image" /></p>
<p>set_border(bool)方法是WindowExt trait的一部分，除了WidgetExt和GroupExt trait外，FLTK中的所有窗口类型都实现了它。
所有trait的列表可以在crates的prelude module中找到：</p>
<p><a href="https://docs.rs/fltk/*/fltk/prelude/index.html">文档</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="组件-widgets"><a class="header" href="#组件-widgets">组件 Widgets</a></h1>
<p>FLTK提供了大约80个窗口组件。这些组件都实现了WidgetBase和WidgetExt的基本trait集。 我们已经遇到了我们的第一个组件，Window。
正如我们在Window小组件中所看到的，小组件也可以根据其功能实现其他trait。
在我们之前写的例子中添加一个按钮：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/100937814-adfb4900-3504-11eb-8a6b-f42a4fb4e470.png" alt="image" /></p>
<p>注意，这个按钮的父组件是my_window，因为它是在begin()和end()之间创建的。
另一种添加组件的方法是，使用实现了GroupExt trait的widget所提供的add(widget)方法。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    my_window.end();
    my_window.show();

    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.add(&amp;but);

    app.run().unwrap();
}
</code></pre></pre>
<p>另一件要注意的事情是按钮的初始化，它的构造函数基本上与Window相同，这是因为它实现了WidgetBase trait。注意，虽然Window的x和y坐标是相对于屏幕的，但按钮的x和y坐标却是相对于包含按钮的窗口的。你可能已经注意到，这也适用于我们在前一页的嵌入式窗口。</p>
<p>这个按钮也实现了ButtonExt trait，它提供了一些有用的方法，比如设置快捷键来触发我们的按钮以及其他方法。</p>
<p>构建组件也可以用构建器模式来完成：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let but1 = Button::new(10, 10, 80, 40, &quot;Button 1&quot;);
// OR
let but1 = Button::default()
    .with_pos(10, 10)
    .with_size(80, 40)
    .with_label(&quot;Button 1&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>这基本上有相同的效果。</p>
<p>目前，我们的程序显示了一个带有按钮的窗口，这个按钮是可以点击的，但什么也做不了！因此，在下一页中，我们将学习为它添加一些动作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="按钮-buttons"><a class="header" href="#按钮-buttons">按钮 Buttons</a></h1>
<p>Button widgets 有多种用途和多种形式：</p>
<ul>
<li>Button</li>
<li>RadioButton</li>
<li>ToggleButton</li>
<li>RoundButton</li>
<li>CheckButton</li>
<li>LightButton</li>
<li>RepeatButton</li>
<li>RadioLightButton</li>
<li>RadioRoundButton</li>
</ul>
<p>这些可以在可以在 button module 中找到。
其中最简单的就是Button，它在用户点击时产生一些行为。当然所有的按钮都会这样：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, button::Button, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();
    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, &quot;Click me!&quot;);
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label(&quot;Hello world&quot;));

    app.run().unwrap();
}
</code></pre></pre>
<p>然而其他按钮可以带有表示自己某些属性的其他值（value）：
例如CheckButton, ToggleButton, LightButton 拥有它们当前状态（比如，是否被选中）的信息。</p>
<p>单选按钮（RadioRoundButton、RadioLightButton和RadioButton）也带有它们的一些值，但在parent group（任何实现GroupExt的widget）中只有一个可以被切换。所以这些组件是知道其他按钮的值的：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    // only one can be toggled by the user at a time, the other will be automatically untoggled
    let btn1 = button::RadioRoundButton::default().with_label(&quot;Option 1&quot;);
    let btn2 = button::RadioRoundButton::default().with_label(&quot;Option 2&quot;); 
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>(可以用clear_visible_focus()方法<code>btn1.clear_visible_focus()</code>来删除焦点框）</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145727291-8be40de6-8ec6-4e57-bb29-fa0f0ac3b251.png" alt="image" /></p>
<p>其他可切换的按钮没有这个属性。</p>
<p>你可以使用ButtonExt::value()方法查询一个按钮是否被切换：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    let btn1 = button::CheckButton::default().with_label(&quot;Option 1&quot;);
    let btn2 = button::CheckButton::default().with_label(&quot;Option 2&quot;);
    let mut btn3 = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn3.set_callback(move |btn3| {
        if btn1.value() {
            println!(&quot;btn1 is checked&quot;);
        }
        if btn2.value() {
            println!(&quot;btn1 is checked&quot;);
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p>CheckButton还提供了一个方便的方法is_checked()，而radio buttons提供了一个is_toggled()：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145727325-7e5bb45f-674e-4bb2-81c8-27d0ee391d34.png" alt="image" /></p>
<p>默认情况下，可切换的按钮在创建时是不可切换的，然而这可以用set_value()，或者方便的方法set_checked()（对CheckButton使用）和set_toggled()（对radio buttons使用）来重写：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    let mut btn1 = button::CheckButton::default().with_label(&quot;Option 1&quot;);
    btn1.set_value(true);
    // Similarly you can use btn1.set_checked(true)
    let btn2 = button::CheckButton::default().with_label(&quot;Option 2&quot;);
    let mut btn3 = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn3.set_callback(move |btn3| {
        if btn1.value() {
            println!(&quot;btn1 is checked&quot;);
        }
        if btn2.value() {
            println!(&quot;btn2 is checked&quot;);
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727352-bf6dba5c-1a0c-4da4-8296-093e10470f0c.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标签-labels"><a class="header" href="#标签-labels">标签 Labels</a></h1>
<p>FLTK没有标签widget。因此，如果你要想显示文本，你可以使用一个Frame widget并给它一个label。</p>
<p>所有widge件都可以使用::new()构造函数，或者用with_label()或set_label()来获取一个标签。</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let btn = button::Button::new(160, 200, 80, 30, &quot;Click&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>这个按钮有一个显示 &quot;点击 &quot;文字的标签。</p>
<p>同样地，我们可以使用set_label()或with_label()：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let btn = button::Button::default().with_label(&quot;Click&quot;);
// or
let mut btn = button::Button::default();
btn.set_label(&quot;Click&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>然而，::new()构造函数实际上是把一个可选的 static str 带到了这里，所以下面的代码会失败：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let label = String::from(&quot;Click&quot;); // label is not a static str
let mut btn = button::Button::new(160, 200, 80, 30, &amp;label);
<span class="boring">}
</span></code></pre></pre>
<p>在这种情况下，你应该使用<code>btn.set_label(&amp;label);</code>。原因是FLTK期望的label是<code>const char *</code> 的，这相当于Rust的<code>&amp;'static str</code>。这些字符串存在于程序的二进制代码段中。如果你反汇编一个程序，会显示所有这些静态字符串。由于这些字符串有一个静态的生命周期，FLTK默认不会存储它们。而当使用set_label()和with_label()调用FLTK的Fl_Widget::copy_label()方法时，实际上是存储字符串。</p>
<p>你也不限于文字标签，FLTK有预定义的符号，可以转换成图像。</p>
<p><img src="https://www.fltk.org/doc-1.4/symbols.png" alt="symbols" /></p>
<p>@符号后面还可以加上以下可选的 &quot;格式化 &quot;字符，其顺序和规则如下：</p>
<ul>
<li>'#'强制进行方形缩放，而不是对小部件的形状进行扭曲。</li>
<li>+[1-9]或-[1-9]将缩放比例调大或调小一点。</li>
<li>$'水平翻转符号，'%'垂直翻转符号。</li>
<li>[0-9] - 旋转45度的倍数。5'和'6'不做旋转，而其他数字则指向数字键盘上的那个键的方向。'0'，后面还有四个数字，使符号按该度数旋转。</li>
</ul>
<p>因此，如果要显示一个非常大的指向下方的箭头，你可以使用标签字符串&quot;@+92-&gt;&quot;。</p>
<p>符号和文本可以结合在一个标签中，但是符号必须在文本的开头和/或结尾处。如果文本跨越了多行，那么符号将被放大以匹配所有行的高度：</p>
<p><img src="https://www.fltk.org/doc-1.4/symbol-examples.png" alt="ex" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="组控件-group-widgets"><a class="header" href="#组控件-group-widgets">组控件 Group widgets</a></h1>
<p>这些组件包括window类型和在group module中发现的其他部件：Group，Scroll，Pack，Tile，Flex ...等等。
实现GroupExt trait的部件具有一个特点，即必须调用<code>::end()</code>方法来关闭它们：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    let _btn = Button::new(160, 200, 80, 30, &quot;Click&quot;);
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>在上面的例子中，按钮 &quot;btn &quot;的父部件将是window。
在 <code>end</code>这样的GroupExt部件后，任何在 <code>end</code> 后实例化的其他widget，将在该部件外实例化。
但这些widget仍然可以使用<code>::add(&amp;other_widget)</code>方法来添加进去（或使用<code>::insert</code>）。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    win.end();
    win.show();

    let btn = Button::new(160, 200, 80, 30, &quot;Click&quot;);
    win.add(&amp;btn);
    
    a.run().unwrap();
}
</code></pre></pre>
<p>另一个选择是重新begin该widget：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    win.end();
    win.show();

    win.begin();
    let _btn = Button::new(160, 200, 80, 30, &quot;Click&quot;);
    win.end();

    a.run().unwrap();
}
</code></pre></pre>
<p>虽然大多数GroupExt widget需要手动布局，但有几个widget具有自动布局功能。Flex widget在 <a href="Layouts.html">布局 layout</a>中会讨论。Pack需要子widget的height，这取决于Pack的方向。</p>
<p>一个vertical pack只需要知道它的子widget的height：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(200, 300);
    let mut pack = group::Pack::default_fill();
    pack.set_spacing(5);
    for i in 0..2 {
        frame::Frame::default().with_size(0, 40).with_label(&amp;format!(&quot;field {}&quot;, i));
        input::Input::default().with_size(0, 40);
    }
    frame::Frame::default().with_size(0, 40); // a filler
    button::Button::default().with_size(0, 40).with_label(&quot;Submit&quot;);
    pack.end();
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727469-a7181ebf-a3a3-4675-af23-ec40d847a593.png" alt="image" /></p>
<p>对于一个horizontal pack，我们设置Pack type，然后我们只需要传递子widget的width：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(300, 100);
    let mut pack = group::Pack::default_fill().with_type(group::PackType::Horizontal);
    pack.set_spacing(5);
    for i in 0..2 {
        frame::Frame::default().with_size(40, 0).with_label(&amp;format!(&quot;field {}&quot;, i));
        input::Input::default().with_size(40, 0);
    }
    frame::Frame::default().with_size(40, 0); // a filler
    button::Button::default().with_size(40, 0).with_label(&quot;Submit&quot;);
    pack.end();
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="菜单-menus"><a class="header" href="#菜单-menus">菜单 Menus</a></h1>
<p>FLTK中的菜单是实现MenuExt trait的widget。Menu有下面这几种类型：</p>
<ul>
<li>MenuBar</li>
<li>MenuItem</li>
<li>Choice (dropdown list)</li>
<li>SysMenuBar (MacOS上则是出现在屏幕顶部的menu bar)</li>
</ul>
<p>Menu类型主要有两个方面的功能：
1- 使用add_choice()方法添加选项，然后在callback中处理用户的选择：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default().with_size(80, 30).center_of_parent().with_label(&quot;Select item&quot;);
    choice.add_choice(&quot;Choice 1&quot;);
    choice.add_choice(&quot;Choice 2&quot;);
    choice.add_choice(&quot;Choice 3&quot;);
    // You can also simply type choice.add_choice(&quot;Choice 1|Choice 2|Choice 3&quot;);
    wind.end();
    wind.show();

    choice.set_callback(|c| {
        match c.value() {
            0 =&gt; println!(&quot;choice 1 selected&quot;),
            1 =&gt; println!(&quot;choice 2 selected&quot;),
            2 =&gt; println!(&quot;choice 3 selected&quot;),
            _ =&gt; unreachable!(),
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727397-dd713782-9f8e-474b-b009-f2ebeb5170ea.png" alt="image" /></p>
<p>另外，你也可以获取所选项目的文本内容来操作：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default().with_size(80, 30).center_of_parent().with_label(&quot;Select item&quot;);
    choice.add_choice(&quot;Choice 1|Choice 2|Choice 3&quot;);
    wind.end();
    wind.show();

    choice.set_callback(|c| {
        if let Some(choice) = c.choice() {
            match choice.as_str() {
                &quot;Choice 1&quot; =&gt; println!(&quot;choice 1 selected&quot;),
                &quot;Choice 2&quot; =&gt; println!(&quot;choice 2 selected&quot;),
                &quot;Choice 3&quot; =&gt; println!(&quot;choice 3 selected&quot;),
                _ =&gt; unreachable!(),
            }
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>2- 通过add()方法添加选项，你要明确地传递每个选项的回调：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default()
        .with_size(80, 30)
        .center_of_parent()
        .with_label(&quot;Select item&quot;);

    choice.add(
        &quot;Choice 1&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!(&quot;choice 1 selected&quot;),
    );
    choice.add(
        &quot;Choice 2&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!(&quot;choice 2 selected&quot;),
    );
    choice.add(
        &quot;Choice 3&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!(&quot;choice 3 selected&quot;),
    );

    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>另外，正如在 <a href="Events">事件 Events</a>中提到的，你可以使用一个函数对象，而不必传递闭包：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::*, prelude::*, *};

fn menu_cb(m: &amp;mut impl MenuExt) {
    if let Some(choice) = m.choice() {
        match choice.as_str() {
            &quot;New\t&quot; =&gt; println!(&quot;New&quot;),
            &quot;Open\t&quot; =&gt; println!(&quot;Open&quot;),
            &quot;Third&quot; =&gt; println!(&quot;Third&quot;),
            &quot;Quit\t&quot; =&gt; {
                println!(&quot;Quitting&quot;);
                app::quit();
            },
            _ =&gt; println!(&quot;{}&quot;, choice),
        }
    }
}

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut menubar = menu::MenuBar::new(0, 0, 400, 40, &quot;rew&quot;);
    menubar.add(&quot;File/New\t&quot;, Shortcut::None, menu::MenuFlag::Normal, menu_cb);
    menubar.add(
        &quot;File/Open\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    let idx = menubar.add(
        &quot;File/Recent&quot;,
        Shortcut::None,
        menu::MenuFlag::Submenu,
        menu_cb,
    );
    menubar.add(
        &quot;File/Recent/First\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    menubar.add(
        &quot;File/Recent/Second\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    menubar.add(
        &quot;File/Quit\t&quot;,
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    let mut btn1 = button::Button::new(160, 150, 80, 30, &quot;Modify 1&quot;);
    let mut btn2 = button::Button::new(160, 200, 80, 30, &quot;Modify 2&quot;);
    let mut clear = button::Button::new(160, 250, 80, 30, &quot;Clear&quot;);
    win.end();
    win.show();

    btn1.set_callback({
        let menubar = menubar.clone();
        move |_| {
            if let Some(mut item) = menubar.find_item(&quot;File/Recent&quot;) {
                item.add(
                    &quot;Recent/Third&quot;,
                    Shortcut::None,
                    menu::MenuFlag::Normal,
                    menu_cb,
                );
                item.add(
                    &quot;Recent/Fourth&quot;,
                    Shortcut::None,
                    menu::MenuFlag::Normal,
                    menu_cb,
                );
            }
        }
    });

    btn2.set_callback({
        let mut menubar = menubar.clone();
        move |_| {
            menubar.add(
                &quot;File/Recent/Fifth\t&quot;,
                Shortcut::None,
                menu::MenuFlag::Normal,
                menu_cb,
            );
            menubar.add(
                &quot;File/Recent/Sixth\t&quot;,
                Shortcut::None,
                menu::MenuFlag::Normal,
                menu_cb,
            );
        }
    });

    clear.set_callback(move |_| {
        menubar.clear_submenu(idx).unwrap();
    });

    a.run().unwrap();
}
</code></pre></pre>
<p>另外，你可以使用add_emit()来传递一个sender和一个message，而不必要传递回调：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

#[derive(Clone)]
enum Message {
    Choice1,
    Choice2,
    Choice3,
}

fn main() {
    let a = app::App::default();
    let (s, r) = app::channel();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default()
        .with_size(80, 30)
        .center_of_parent()
        .with_label(&quot;Select item&quot;);

    choice.add_emit(
        &quot;Choice 1&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s.clone(),
        Message::Choice1,
    );
    choice.add_emit(
        &quot;Choice 2&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s.clone(),
        Message::Choice2,
    );
    choice.add_emit(
        &quot;Choice 3&quot;,
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s,
        Message::Choice3,
    );

    wind.end();
    wind.show();

    while a.wait() {
        if let Some(msg) = r.recv() {
            match msg {
                Message::Choice1 =&gt; println!(&quot;choice 1 selected&quot;),
                Message::Choice2 =&gt; println!(&quot;choice 2 selected&quot;),
                Message::Choice3 =&gt; println!(&quot;choice 3 selected&quot;),
            }
        }
    }
}
</code></pre></pre>
<p>你可能会问，为什么我们要从第一个例子中的几行代码，转到更复杂的方式。其实每种方法都有它的用途。
对于简单的下拉widget，建议用第一种方法。对于一个程序的菜单栏，用第二种方法。它允许你指定Shortcuts和MenuFlags，并且可以更好地解耦事件，所以你不必在菜单的回调中处理一切。使用add()方法处理子菜单也更容易，就像在<a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/editor.rs">编辑器例子</a>中那样：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let mut menu = menu::SysMenuBar::default().with_size(800, 35);
        menu.set_frame(FrameType::FlatBox);
        menu.add_emit(
            &quot;&amp;File/New...\t&quot;,
            Shortcut::Ctrl | 'n',
            menu::MenuFlag::Normal,
            *s,
            Message::New,
        );

        menu.add_emit(
            &quot;&amp;File/Open...\t&quot;,
            Shortcut::Ctrl | 'o',
            menu::MenuFlag::Normal,
            *s,
            Message::Open,
        );

        menu.add_emit(
            &quot;&amp;File/Save\t&quot;,
            Shortcut::Ctrl | 's',
            menu::MenuFlag::Normal,
            *s,
            Message::Save,
        );

        menu.add_emit(
            &quot;&amp;File/Save as...\t&quot;,
            Shortcut::Ctrl | 'w',
            menu::MenuFlag::Normal,
            *s,
            Message::SaveAs,
        );

        menu.add_emit(
            &quot;&amp;File/Print...\t&quot;,
            Shortcut::Ctrl | 'p',
            menu::MenuFlag::MenuDivider,
            *s,
            Message::Print,
        );

        menu.add_emit(
            &quot;&amp;File/Quit\t&quot;,
            Shortcut::Ctrl | 'q',
            menu::MenuFlag::Normal,
            *s,
            Message::Quit,
        );

        menu.add_emit(
            &quot;&amp;Edit/Cut\t&quot;,
            Shortcut::Ctrl | 'x',
            menu::MenuFlag::Normal,
            *s,
            Message::Cut,
        );

        menu.add_emit(
            &quot;&amp;Edit/Copy\t&quot;,
            Shortcut::Ctrl | 'c',
            menu::MenuFlag::Normal,
            *s,
            Message::Copy,
        );

        menu.add_emit(
            &quot;&amp;Edit/Paste\t&quot;,
            Shortcut::Ctrl | 'v',
            menu::MenuFlag::Normal,
            *s,
            Message::Paste,
        );

        menu.add_emit(
            &quot;&amp;Help/About\t&quot;,
            Shortcut::None,
            menu::MenuFlag::Normal,
            *s,
            Message::About,
        );

        if let Some(mut item) = menu.find_item(&quot;&amp;File/Quit\t&quot;) {
            item.set_label_color(Color::Red);
        }
<span class="boring">}
</span></code></pre></pre>
<p>注意到最后一个调用，它使用find_item()在menu中找到一个item，然后我们将其标签颜色设置为红色：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145727434-d66c6d55-018d-4341-9570-7c2864b5bf29.png" alt="image" /></p>
<h2 id="系统菜单栏"><a class="header" href="#系统菜单栏">系统菜单栏</a></h2>
<p>在MacOS上，你可能更喜欢使用系统菜单栏，它通常出现在屏幕的顶部。为此，你可以使用一个SysMenuBar widget。它与所有实现MenuExt trait的widget具有相同的api，当程序为MacOS以外的其他目标平台编译时，它将转化为一个普通的MenuBar。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="输入输出-input--output"><a class="header" href="#输入输出-input--output">输入输出 Input &amp; Output</a></h1>
<p>输入和输出 widget 实现了InputExt trait。在input&amp;output modules中还可以找到这些：</p>
<ul>
<li>Input</li>
<li>IntInput</li>
<li>FloatInput</li>
<li>MultilineInput</li>
<li>SecretInput</li>
<li>FileInput</li>
<li>Output</li>
<li>MultilineOutput</li>
</ul>
<p>这种trait的特点是，这些widget会带有一个文本值，可以用value()方法查询，用set_value()方法改变：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 100).column().center_of_parent();
    let label = frame::Frame::default().with_label(&quot;Enter age&quot;);
    let input = input::IntInput::default();
    let mut btn = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn.set_callback(move |btn| {
        println!(&quot;your age is {}&quot;, input.value());
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727249-2fa4d384-2bd3-41fd-bbae-61a3a33b12f6.png" alt="image" /></p>
<p>请注意，我们使用了一个IntInput来限制输入整数值。虽然用户不能输入字符串，但就开发者而言，value()的返回值仍然是一个String。</p>
<p>输出部件不允许用户修改其数值：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(200, 50).column().center_of_parent();
    let label = frame::Frame::default().with_label(&quot;Check this text:&quot;);
    let mut output = output::Output::default();
    output.set_value(&quot;You can't edit this!&quot;);
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727261-88ec533f-200b-4df7-a570-76ebd2ba520a.png" alt="image" /></p>
<p>输入部件也可以使用 InputExt::set_readonly(bool) 方法变成只读：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 100).column().center_of_parent();
    let label = frame::Frame::default().with_label(&quot;Enter age&quot;);
    let mut input = input::IntInput::default();
    let mut btn = button::Button::default().with_label(&quot;Submit&quot;);
    flex.end();
    win.end();
    win.show();

    btn.set_callback(move |btn| {
        println!(&quot;your age is {}&quot;, input.value());
        input.set_readonly(true);
    });

    a.run().unwrap();
}
</code></pre></pre>
<p>这使我们的输入在用户点击按钮后成为只读。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="估值器-valuators"><a class="header" href="#估值器-valuators">估值器 Valuators</a></h1>
<p>估值器widget实现了ValuatorExt trait。这些widget跟踪（以图形和内部方式）跟踪steps，ranges和bounds。
你可能熟悉滚动条和滑块（scrollbars and sliders）这种估值器。可以在valuator模块中找到fltk提供的这些估值器：</p>
<ul>
<li>Slider</li>
<li>NiceSlider</li>
<li>ValueSlider</li>
<li>Dial</li>
<li>LineDial</li>
<li>Counter</li>
<li>Scrollbar</li>
<li>Roller</li>
<li>Adjuster</li>
<li>ValueInput</li>
<li>ValueOutput</li>
<li>FillSlider</li>
<li>FillDial</li>
<li>HorSlider (Horizontal slider)</li>
<li>HorFillSlider</li>
<li>HorNiceSlider</li>
<li>HorValueSlider</li>
</ul>
<p>在gui中改变valuator的值会触发其回调。Valuator的当前值可以通过value()方法来查询。它也可以用set_value()来为它设置一个值。range和step也可以根据你的使用情况进行查询和改变：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut slider = valuator::HorNiceSlider::default().with_size(400, 20).center_of_parent();
    slider.set_minimum(0.);
    slider.set_maximum(100.);
    slider.set_step(1., 1); // 每一step增长10
    slider.set_value(50.); // 从中间开始
    win.end();
    win.show();

    slider.set_callback(|s| {
        println!(&quot;slider at {}&quot;, s.value());
    });
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727188-4ac06d45-7fd1-44f7-9adc-366d9bb79d8f.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="文字-text"><a class="header" href="#文字-text">文字 Text</a></h1>
<p>Text widget实现了DisplayExt trait，共有3个，可以在text module中找到：</p>
<ul>
<li>TextDisplay</li>
<li>TextEditor</li>
<li>SimpleTerminal</li>
</ul>
<p>这些部件的主要目的是显示/编辑文本。前两个部件需要一个TextBuffer，而SimpleTerminal有一个内部缓冲器：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextEditor::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf.clone());
    win.end();
    win.show();

    buf.set_text(&quot;Hello world!&quot;);
    buf.append(&quot;\n&quot;);
    buf.append(&quot;This is a text editor!&quot;);

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727101-175fe355-1383-4789-ae40-2945ef0c63e2.png" alt="image" /></p>
<p>大多数操作是通过TextBuffer完成的。可以用append()来追加文本，也可以用set_text()来设置其全部内容。
你可以使用DisplayExt::buffer()方法取回缓冲区的clone（reference type）：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let buf = text::TextBuffer::default();

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextEditor::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf);
    win.end();
    win.show();

    let mut my_buf = txt.buffer().unwrap();

    my_buf.set_text(&quot;Hello world!&quot;);
    my_buf.append(&quot;\n&quot;);
    my_buf.append(&quot;This is a text editor!&quot;);

    a.run().unwrap();
}
</code></pre></pre>
<p>DisplayExt提供了其他方法来管理文本属性，wrapping，cursor position，font，color，size...等。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::Color, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();
    buf.set_text(&quot;Hello world!&quot;);
    buf.append(&quot;\n&quot;);
    buf.append(&quot;This is a text editor!&quot;);

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextDisplay::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf);
    txt.wrap_mode(text::WrapMode::AtBounds, 0); // bounds don't require the second argument, unlike AtPixel and AtColumn
    txt.set_text_color(Color::Red);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727121-8396c77e-836d-4406-abd1-92af32ff7242.png" alt="image" /></p>
<p>TextBuffer还有第二个用途，那就是提供一个样式缓冲区（style buffer）。样式缓冲区反映了你的文本缓冲区，并使用一个样式表（包含字体、颜色和大小）来为你的文本添加细粒度的样式，样式表本身是有索引的，具体说是使用相应的字母：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    enums::{Color, Font},
    prelude::*,
    *,
};

const STYLES: &amp;[text::StyleTableEntry] = &amp;[
    text::StyleTableEntry {
        color: Color::Green,
        font: Font::Courier,
        size: 16,
    },
    text::StyleTableEntry {
        color: Color::Red,
        font: Font::Courier,
        size: 16,
    },
    text::StyleTableEntry {
        color: Color::from_u32(0x8000ff),
        font: Font::Courier,
        size: 16,
    },
];

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();
    let mut sbuf = text::TextBuffer::default();
    buf.set_text(&quot;Hello world!&quot;);
    sbuf.set_text(&amp;&quot;A&quot;.repeat(&quot;Hello world!&quot;.len())); // A represents the first entry in the table, repeated for every letter
    buf.append(&quot;\n&quot;); 
    sbuf.append(&quot;B&quot;); // Although a new line and the style might not apply, but it's needed to avoid messing out subsequent entries
    buf.append(&quot;This is a text editor!&quot;);
    sbuf.append(&amp;&quot;C&quot;.repeat(&quot;This is a text editor!&quot;.len()));

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextDisplay::default()
        .with_size(390, 290)
        .center_of_parent();
    txt.set_buffer(buf);
    txt.set_highlight_data(sbuf, STYLES.to_vec());
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727157-be992344-763d-41f9-b3d8-2dfa13fbaab1.png" alt="image" /></p>
<p>Terminal的例子使用了SimpleTerminal和一个有样式的TextBuffer，你可以在 <a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/terminal.rs">这儿</a> 找到</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阅览器-browsers"><a class="header" href="#阅览器-browsers">阅览器 Browsers</a></h1>
<p>Browser widgets 实现了 BrowserExt trait：</p>
<ul>
<li>Browser</li>
<li>SelectBrowser</li>
<li>HoldBrowser</li>
<li>MultiBrowser</li>
<li>FileBrowser</li>
<li>CheckBrowser</li>
</ul>
<p>这些可以在 browser module中找到。</p>
<p>为了实例化一个browser，需要提供每一项的列宽column widths，以及在add()方法中用于将item分成几列的分隔符column char：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default().with_size(900, 300);
    let mut b = browser::Browser::new(10, 10, 900 - 20, 300 - 20, &quot;&quot;);
    let widths = &amp;[50, 50, 50, 70, 70, 40, 40, 70, 70, 50];
    b.set_column_widths(widths);
    b.set_column_char('\t');
    // we can now use the '\t' char in our add method.
    b.add(&quot;USER\tPID\t%CPU\t%MEM\tVSZ\tRSS\tTTY\tSTAT\tSTART\tTIME\tCOMMAND&quot;);
    b.add(&quot;root\t2888\t0.0\t0.0\t1352\t0\ttty3\tSW\tAug15\t0:00\t@b@f/sbin/mingetty tty3&quot;);
    b.add(&quot;erco\t2889\t0.0\t13.0\t221352\t0\ttty3\tR\tAug15\t1:34\t@b@f/usr/local/bin/render a35 0004&quot;);
    b.add(&quot;uucp\t2892\t0.0\t0.0\t1352\t0\tttyS0\tSW\tAug15\t0:00\t@b@f/sbin/agetty -h 19200 ttyS0 vt100&quot;);
    b.add(&quot;root\t13115\t0.0\t0.0\t1352\t0\ttty2\tSW\tAug30\t0:00\t@b@f/sbin/mingetty tty2&quot;);
    b.add(
        &quot;root\t13464\t0.0\t0.0\t1352\t0\ttty1\tSW\tAug30\t0:00\t@b@f/sbin/mingetty tty1 --noclear&quot;,
    );
    win.end();
    win.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145733437-e3061015-12fa-4f2e-a1e3-01f59c4b189d.png" alt="image" /></p>
<p>可以使用特殊字符<code>@</code>来实现其他丰富的格式化效果，我们需要后面跟一个格式化指定符：</p>
<ul>
<li>'@.' 打印其余行，且不会再寻找其他的'@'符号</li>
<li>'@@' 打印其余以'@'开头的行</li>
<li>'@l'  使用大号字体(24 point) </li>
<li>'@m' 使用中号字体(18 point)</li>
<li>'@s' 使用小号字体(11 point)</li>
<li>'@b' 使用宽字体(adds FL_BOLD to font)</li>
<li>'@i' 使用斜体(adds FL_ITALIC to font)</li>
<li>'@f' 或 '@t' 使用等距字体 (sets font to FL_COURIER)</li>
<li>'@c' 水平居中</li>
<li>'@r' 向右对齐文本</li>
<li>'@B0', '@B1', ... '@B255' 使用fl_color(n)填充背景</li>
<li>'@C0', '@C1', ... '@C255' 使用fl_color(n) 渲染文本</li>
<li>'@F0', '@F1', ... 使用 fl_font(n) 渲染文本</li>
<li>'@S1', '@S2', ... 使用相应的尺寸来渲染文本</li>
<li>'@u' or '@_' 字体添加下划线</li>
<li>'@-' 字体中间添加修改线</li>
</ul>
<p>在下面的例子中，我们在%CPU前面加上@C88，将其渲染成红色：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default().with_size(900, 300);
    let mut b = browser::Browser::new(10, 10, 900 - 20, 300 - 20, &quot;&quot;);
    let widths = &amp;[50, 50, 50, 70, 70, 40, 40, 70, 70, 50];
    b.set_column_widths(widths);
    b.set_column_char('\t');
    b.add(&quot;USER\tPID\t@C88%CPU\t%MEM\tVSZ\tRSS\tTTY\tSTAT\tSTART\tTIME\tCOMMAND&quot;);
    win.end();
    win.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145733713-2fe3207d-25f7-4acd-ae91-754679c5696a.png" alt="image" /></p>
<p>这些颜色遵循FLTK的颜色映射，可以从0到255进行索引。</p>
<p><img src="https://www.fltk.org/doc-1.4/fltk-colormap.png" alt="colormap" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="树-trees"><a class="header" href="#树-trees">树 Trees</a></h1>
<p>Tree widgets 让你可以以树状的形式显示一些元素。这里并没有 tree trait，所有方法来自 Tree type。可以使用add方法添加元素：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726958-f1f2a095-39c5-496f-b772-18d024dd609d.png" alt="image" /></p>
<p>子项目可以使用正斜线分隔符来添加：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727026-bfcff44f-2b01-4679-937b-3e7d441dfdf0.png" alt="image" /></p>
<p>如果你试试上面的代码，你会发现根项标签总是 &quot;ROOT &quot;。可以通过set_root_label()方法来改变根标签：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_root_label(&quot;My Tree&quot;);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727045-a25be6bc-a514-4b4a-b7b9-0a7ee2e359b4.png" alt="image" /></p>
<p>甚至可以使用set_show_root(false)方法隐藏根标签。</p>
<p>树中的元素可以使用first_selected_item()方法进行查询：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_show_root(false);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(item) = t.first_selected_item() {
            println!(&quot;{} selected&quot;, item.label().unwrap());
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727072-8596cf09-100c-4cb6-a427-0d3c66702b39.png" alt="image" /></p>
<p>目前我们的树只允许单选，让我们把它改成多选（我们也要改变连接器connecter的样式）：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_select_mode(tree::TreeSelect::Multi);
    tree.set_connector_style(tree::TreeConnectorStyle::Solid);
    tree.set_connector_color(enums::Color::Red.inactive());
    tree.set_show_root(false);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(item) = t.first_selected_item() {
            println!(&quot;{} selected&quot;, item.label().unwrap());
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p>现在的问题是，我们需要得到所有的选项，而不只是第一个被选中的项目，这里我们使用get_selected_items()方法，该方法返回一个可选的Vec，而不是只得到标签，我们将得到item的整个路径。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_select_mode(tree::TreeSelect::Multi);
    tree.set_connector_style(tree::TreeConnectorStyle::Solid);
    tree.set_connector_color(enums::Color::Red.inactive());
    tree.set_show_root(false);
    tree.add(&quot;Item 1&quot;);
    tree.add(&quot;Item 2&quot;);
    tree.add(&quot;Item 3&quot;);
    tree.add(&quot;Item 3/Subitem 1&quot;);
    tree.add(&quot;Item 3/Subitem 2&quot;);
    tree.add(&quot;Item 3/Subitem 3&quot;);
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(items) = t.get_selected_items() {
            for i in items {
                println!(&quot;{} selected&quot;, t.item_pathname(&amp;i).unwrap());
            }
        }
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727000-4b881896-309d-465d-8305-9a7e0a92eaea.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表格-tables"><a class="header" href="#表格-tables">表格 Tables</a></h1>
<p>fltk提供了table widget，其使用代码可以在例子中找到。然而，使用<a href="https://crates.io/crates/fltk-table">fltk-table crate</a>将需要更少的模板代码，并且还提供了一个更简单、更直观的界面。</p>
<pre><pre class="playground"><code class="language-rust edition2018">extern crate fltk_table;

use fltk::{
    app, enums,
    prelude::{GroupExt, WidgetExt},
    window,
};
use fltk_table::{SmartTable, TableOpts};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut wind = window::Window::default().with_size(800, 600);

    /// 我们通过 TableOpts 域传递行和列
    let mut table = SmartTable::default()
    .with_size(790, 590)
    .center_of_parent()
    .with_opts(TableOpts {
        rows: 30,
        cols: 15,
        editable: true,
        ..Default::default()
    });
    
    wind.end();
    wind.show();

    // 用一些值填充
    for i in 0..30 {
        for j in 0..15 {
            table.set_cell_value(i, j, &amp;(i + j).to_string());
        }
    }

    // 把行列为4，5的单元设置为&quot;another&quot;, 注意索引是从0开始的
    table.set_cell_value(3, 4, &quot;another&quot;);

    assert_eq!(table.cell_value(3, 4), &quot;another&quot;);

    // 防治点击空格键的时候关闭窗口
    wind.set_callback(move |_| {
        if app::event() == enums::Event::Close {
            app.quit();
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-table/raw/HEAD/screenshots/styled.jpg" alt="fltk-table" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="自定义组件-custom-widgets"><a class="header" href="#自定义组件-custom-widgets">自定义组件 Custom widgets</a></h1>
<p>fltk-rs允许你创建自定义widget。我们需要定义一个struct，它需要扩展一个已经存在的widget和widget type。最基本的widget type是widget::Widget。
1- 定义你的struct和任何其他需要存储在其中的内部数据：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, *};
use std::cell::RefCell;
use std::rc::Rc;

struct MyCustomButton {
    inner: widget::Widget,
    num_clicks: Rc&lt;RefCell&lt;i32&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>你会注意到两件事，我们正在使用一个Rc RefCell来存储数据。这在一般情况下是没有必要的，但是，由于我们需要将这些数据所有权move到一个回调中，同时在我们修改它之后仍然可以访问它，我们将把它包装在一个Rc RefCell中。我们已经导入了必要的模块。</p>
<p>2- 定义结构的impl。其中最重要的是构造函数，因为我们要通过它来初始化内部数据：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyCustomButton {
    // 我们定义的结构体
    pub fn new(radius: i32, label: &amp;str) -&gt; Self {
        let mut inner = widget::Widget::default()
            .with_size(radius * 2, radius * 2)
            .with_label(label)
            .center_of_parent();
        inner.set_frame(enums::FrameType::OFlatBox);
        let num_clicks = 0;
        let num_clicks = Rc::from(RefCell::from(num_clicks));
        let clicks = num_clicks.clone();
        inner.draw(|i| { // 我们需要一个绘图的实现 draw implementation
            draw::draw_box(i.frame(), i.x(), i.y(), i.w(), i.h(), i.color());
            draw::set_draw_color(enums::Color::Black); // 设置文字颜色
            draw::set_font(enums::Font::Helvetica, app::font_size());
            draw::draw_text2(&amp;i.label(), i.x(), i.y(), i.w(), i.h(), i.align());
        });
        inner.handle(move |i, ev| match ev {
            enums::Event::Push =&gt; {
                *clicks.borrow_mut() += 1; // 递增 num_clicks
                i.do_callback(); // 使用 set_callback() 时设置的回调
                true
            }
            _ =&gt; false,
        });
        Self {
            inner,
            num_clicks,
        }
    }

    // 获得我们的按钮被点击的次数
    pub fn num_clicks(&amp;self) -&gt; i32 {
        *self.num_clicks.borrow()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>3- 对我们的struct应用widget_extends！宏，该宏需要基本类型，已经我们通过该成员扩展的自定义类型。这是通过实现Deref和DerefMut trait实现的。该宏还添加了其他方便的构造函数和锚定方法（anchoring methods）：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 通过成员`inner`扩展widget::Widget，并添加其他初始化器和构造函数
widget_extends!(MyCustomButton, widget::Widget, inner);
<span class="boring">}
</span></code></pre></pre>
<p>现在来试一试我们的struct：</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    app::background(255, 255, 255); // 设置白色背景
    let mut wind = window::Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);
    
    let mut btn = MyCustomButton::new(50, &quot;Click&quot;);
    // 注意，set_color和set_callback已经自动为我们实现了
    btn.set_color(enums::Color::Cyan);
    btn.set_callback(|_| println!(&quot;Clicked&quot;));
    
    wind.end();
    wind.show();

    app.run().unwrap();
    
    // 打印我们的按钮被点击的数字，退出
    println!(&quot;Our button was clicked {} times&quot;, btn.num_clicks());
}
</code></pre></pre>
<p>全部代码：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};
use std::cell::RefCell;
use std::rc::Rc;

struct MyCustomButton {
    inner: widget::Widget,
    num_clicks: Rc&lt;RefCell&lt;i32&gt;&gt;,
}

impl MyCustomButton {
    // 我们定义的结构体
    pub fn new(radius: i32, label: &amp;str) -&gt; Self {
        let mut inner = widget::Widget::default()
            .with_size(radius * 2, radius * 2)
            .with_label(label)
            .center_of_parent();
        inner.set_frame(enums::FrameType::OFlatBox);
        let num_clicks = 0;
        let num_clicks = Rc::from(RefCell::from(num_clicks));
        let clicks = num_clicks.clone();
        inner.draw(|i| { // 我们需要一个绘图的实现 draw implementation
            draw::draw_box(i.frame(), i.x(), i.y(), i.w(), i.h(), i.color());
            draw::set_draw_color(enums::Color::Black); // 设置文字颜色
            draw::set_font(enums::Font::Helvetica, app::font_size());
            draw::draw_text2(&amp;i.label(), i.x(), i.y(), i.w(), i.h(), i.align());
        });
        inner.handle(move |i, ev| match ev {
            enums::Event::Push =&gt; {
                *clicks.borrow_mut() += 1; // 递增 num_clicks
                i.do_callback(); // 使用 set_callback() 时设置的回调
                true
            }
            _ =&gt; false,
        });
        Self {
            inner,
            num_clicks,
        }
    }

    // 获得我们的按钮被点击的次数
    pub fn num_clicks(&amp;self) -&gt; i32 {
        *self.num_clicks.borrow()
    }
}

// 通过成员`inner`扩展widget::Widget，并添加其他初始化器和构造函数
widget_extends!(MyCustomButton, widget::Widget, inner);

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    app::background(255, 255, 255); // 设置白色背景
    let mut wind = window::Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);
    let mut btn = MyCustomButton::new(50, &quot;Click&quot;);
    btn.set_color(enums::Color::Cyan);
    btn.set_callback(|_| println!(&quot;Clicked&quot;));
    wind.end();
    wind.show();

    app.run().unwrap();
    
    // 打印我们的按钮被点击的数字，退出
    println!(&quot;Our button was clicked {} times&quot;, btn.num_clicks());
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727718-fd0ee71f-f0c2-4438-a038-9b6950638a35.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="对话框-dialogs"><a class="header" href="#对话框-dialogs">对话框 Dialogs</a></h1>
<p>fltk提供了几种对话框类型，有文件对话框和其他一些。</p>
<h2 id="文件对话框-file-dialogs"><a class="header" href="#文件对话框-file-dialogs">文件对话框 File dialogs</a></h2>
<p>有2种类型，原生文件对话框和FLTK自己的文件对话框。原生对话框只是显示操作系统自己的对话框。对于windows来说，那是win32对话框，对于MacOS来说，那是Cocoa对话框，而对于其他posix系统来说，取决于你正在运行什么。在GNOME和其他基于gtk的桌面上，它显示gtk对话框，在KDE上它显示kdialog。</p>
<h3 id="原生对话框-native-dialogs"><a class="header" href="#原生对话框-native-dialogs">原生对话框 Native dialogs</a></h3>
<p>唤起一个原生对话框：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(80, 30)
        .with_label(&quot;Select file&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseFile);
        dialog.show();
        println!(&quot;{:?}&quot;, dialog.filename());
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/146625105-94b11a5d-0938-4962-96d1-aaff5424ffe8.png" alt="image" /></p>
<p>这将打印出所选文件的路径。有几种类型可以作为NativeFileChooserType被传递，这里我们浏览文件，你可以选择BrowseDir来代替，也可以启用多文件/目录选择。如果你选择了多个文件，你可以使用filenames()方法得到一个Vec：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Select files&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseMultiFile);
        dialog.show();
        println!(&quot;{:?}&quot;, dialog.filenames());
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>你也可以选择添加过滤器来有选择地选取文件：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseMultiFile);
        dialog.set_filter(&quot;*.{txt,rs,toml}&quot;);
        dialog.show();
        println!(&quot;{:?}&quot;, dialog.filenames());
    });
<span class="boring">}
</span></code></pre></pre>
<p>这将只显示.txt、.rs和.toml文件。</p>
<h3 id="fltl提供的文件选择器-fltks-own-file-chooser"><a class="header" href="#fltl提供的文件选择器-fltks-own-file-chooser">FLTL提供的文件选择器 FLTK's own file chooser</a></h3>
<p>FLTK也提供了自己的文件选择器：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Select file&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::FileChooser::new(
            /*start dir*/ &quot;.&quot;,
            /*pattern*/ &quot;*.{txt,rs,toml}&quot;,
            /*type*/ dialog::FileChooserType::Multi,
            /*title*/ &quot;Select file:&quot;,
        );
        dialog.show();
        while dialog.shown() {
            app::wait();
        }
        if dialog.count() &gt; 1 {
            for i in 1..=dialog.count() { // values start at 1
                println!(&quot; VALUE[{}]: '{}'&quot;, i, dialog.value(i).unwrap());
            }
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726912-600e4c58-32b7-4a1b-8e6a-44e640549722.png" alt="image" /></p>
<p>用file_chooser()和dir_chooser()函数提供了一个方便的函数：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Select file&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let file = dialog::file_chooser(
            &quot;Choose File&quot;,
            &quot;*.rs&quot;,
            /*start dir*/ &quot;.&quot;,
            /*relative*/ true,
        );
        if let Some(file) = file {
            println!(&quot;{}&quot;, file);
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<h3 id="帮助对话框-help-dialog"><a class="header" href="#帮助对话框-help-dialog">帮助对话框 Help dialog</a></h3>
<p>FLTK提供了一个帮助对话框，可以显示html 2文档：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut help = dialog::HelpDialog::new(100, 100, 400, 300);
        help.set_value(&quot;&lt;h2&gt;Hello world&lt;/h2&gt;&quot;); // this takes html
        help.show();
        while help.shown() {
            app::wait();
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>html文件也可以用HelpDialog::load(path_to_html_file)方法加载：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145726889-442d0453-e1d0-4b41-8717-f121fdf860fa.png" alt="image" /></p>
<h3 id="提示对话框-alert-dialogs"><a class="header" href="#提示对话框-alert-dialogs">提示对话框 Alert dialogs</a></h3>
<p>FLTK还提供了几种对话框类型，可以使用自由函数方便地显示：</p>
<ul>
<li>message</li>
<li>alert</li>
<li>choice</li>
<li>input</li>
<li>password (类似于input，但不显示输入内容)</li>
</ul>
<p>显示一个简单的message对话框：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        dialog::message_default(&quot;Message&quot;);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>这将在默认的位置（基本上在指针附近）显示一个message。如果你想手动输入坐标，你可以使用 message() 函数：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    btn.set_callback(|_| {
        dialog::message(100, 100, &quot;Message&quot;);
    });
<span class="boring">}
</span></code></pre></pre>
<p>前面提到的所有函数都有变体，一个有_default()后缀，不需要坐标，另一个没有，需要坐标。
有些对话框会返回一个值，比如choice，input，and password。input和password返回输入的文本，而choice则返回选择值的索引：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        // 密码和输入也需要第二个参数，这是默认值
        let pass = dialog::password_default(&quot;Enter password:&quot;, &quot;&quot;);
        if let Some(pass) = pass {
            println!(&quot;{}&quot;, pass);
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726850-61fc17e4-cd6e-4821-a9b5-396203806066.png" alt="image" /></p>
<p>使用choice的一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let choice = dialog::choice_default(&quot;Would you like to save&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Cancel&quot;);
        println!(&quot;{}&quot;, choice);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>这将打印索引，即选择No将打印0，Yes将打印1，Cancel将打印2。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145726775-d000a807-8bf5-439b-a991-8bf25fcd5049.png" alt="image" /></p>
<p>你已经注意到，所有这些对话框都没有一个。你也可以在对话框前调用函数来添加一个title：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        dialog::message_title(&quot;Exit!&quot;);
        let choice = dialog::choice_default(&quot;Would you like to save&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Cancel&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>你也可以使用 dialog::message_title_default() 来设置所有这些对话框的默认标题，你要在你的程序的开始部分这样做：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    dialog::message_title_default(&quot;My App!&quot;);
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label(&quot;Show dialog&quot;)
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let choice = dialog::choice_default(&quot;Would you like to save&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Cancel&quot;);
        println!(&quot;{}&quot;, choice);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726685-f086bde2-db63-4fa8-a579-954dbacbe44d.png" alt="image" /></p>
<h2 id="自定义对话框-custom-dialogs"><a class="header" href="#自定义对话框-custom-dialogs">自定义对话框 Custom dialogs</a></h2>
<p>所有这些对话框与你的程序设想的样子可能不相符合，特别是关于颜色和字体。如果你有一个深度定制的程序，你可能也会想要定制对话框。对话框基本上是一个在应用程序中生成的模式窗口。它可以与你的应用程序的其他部分具有相同的风格：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app, button,
    enums::{Color, Font, FrameType},
    frame, group, input,
    prelude::*,
    window,
};

fn style_button(btn: &amp;mut button::Button) {
    btn.set_color(Color::Cyan);
    btn.set_frame(FrameType::RFlatBox);
    btn.clear_visible_focus();
}

pub fn show_dialog() -&gt; MyDialog {
    MyDialog::default()
}

pub struct MyDialog {
    inp: input::Input,
}

impl MyDialog {
    pub fn default() -&gt; Self {
        let mut win = window::Window::default()
            .with_size(400, 100)
            .with_label(&quot;My Dialog&quot;);
        win.set_color(Color::from_rgb(240, 240, 240));
        let mut pack = group::Pack::default()
            .with_size(300, 30)
            .center_of_parent()
            .with_type(group::PackType::Horizontal);
        pack.set_spacing(20);
        frame::Frame::default()
            .with_size(80, 0)
            .with_label(&quot;Enter name:&quot;);
        let mut inp = input::Input::default().with_size(100, 0);
        inp.set_frame(FrameType::FlatBox);
        let mut ok = button::Button::default().with_size(80, 0).with_label(&quot;Ok&quot;);
        style_button(&amp;mut ok);
        pack.end();
        win.end();
        win.make_modal(true);
        win.show();
        ok.set_callback({
            let mut win = win.clone();
            move |_| {
                win.hide();
            }
        });
        while win.shown() {
            app::wait();
        }
        Self { inp }
    }
    pub fn value(&amp;self) -&gt; String {
        self.inp.value()
    }
}

fn main() {
    let a = app::App::default();
    app::set_font(Font::Times);
    let mut win = window::Window::default().with_size(600, 400);
    win.set_color(Color::from_rgb(240, 240, 240));
    let mut btn = button::Button::default()
        .with_size(80, 30)
        .with_label(&quot;Click&quot;)
        .center_of_parent();
    style_button(&amp;mut btn);
    let mut frame = frame::Frame::new(btn.x() - 40, btn.y() - 100, btn.w() + 80, 30, None);
    frame.set_frame(FrameType::BorderBox);
    frame.set_color(Color::Red.inactive());
    win.end();
    win.show();
    btn.set_callback(move |_| {
        let d = show_dialog();
        frame.set_label(&amp;d.value());
    });
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726727-a0018457-1d87-4519-9d6e-08d8f8030d1a.png" alt="image" /></p>
<h2 id="打印机话框-printer-dialog"><a class="header" href="#打印机话框-printer-dialog">打印机话框 Printer dialog</a></h2>
<p>FLTK还提供了一个打印机对话框，它使用你的系统平台的本地打印机对话框：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, *};
let mut but = button::Button::default();
but.set_callback(|widget| {
    let mut printer = printer::Printer::default();
    if printer.begin_job(1).is_ok() {
        printer.begin_page().ok();
        let (width, height) = printer.printable_rect();
        draw::set_draw_color(enums::Color::Black);
        draw::set_line_style(draw::LineStyle::Solid, 2);
        draw::draw_rect(0, 0, width, height);
        draw::set_font(enums::Font::Courier, 12);
        printer.set_origin(width / 2, height / 2);
        printer.print_widget(widget, -widget.width() / 2, -widget.height() / 2);
        printer.end_page().ok();
        printer.end_job();
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>这里只是打印按钮的图像并指定它在纸上显示的位置。你可以传递任何widget（主要是像TextEditor widget）作为打印widget。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="图像-images"><a class="header" href="#图像-images">图像 Images</a></h1>
<p>FLTK支持矢量图和位图，开箱即提供下列几种图像类型：</p>
<ul>
<li>BmpImage</li>
<li>JpegImage</li>
<li>GifImage</li>
<li>PngImage</li>
<li>SvgImage</li>
<li>Pixmap</li>
<li>RgbImage</li>
<li>XpmImage</li>
<li>XbmImage</li>
<li>PnmImage</li>
</ul>
<p>它还提供了两个helper types：</p>
<ul>
<li>SharedImage：它包装了之前所有的类型，所以你不需要指定图像类型。</li>
<li>TiledImage：它提供了一个任何具体类型的平铺图像（图形学术语）。</li>
</ul>
<p>图像类型实现了ImageExt trait，提供了允许缩放和检索图像元数据的方法。
Image可以通过向它的load()构造函数传递路径来构建，或者对某些类型可以使用接受图像数据的from_data()构造函数：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// 需要一个路径
let image = image::SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();

/// 需要图像数据
let image= image::SvgImage::from_data(&amp;data).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Image可以通过WidgetExt::set_image()/set_image_scaled()或set_deimage()/set_deimage_scaled()（用于deactivated/grayed image）与widget一起使用。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();
    image.scale(200, 200, true, true);
    frame.set_image(Some(image));

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>或者通过WidgetExt::draw()方法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();
    frame.draw(move |f| {
        image.scale(f.w(), f.h(), true, true);
        image.draw(f.x() + 40, f.y(), f.w(), f.h());
    });

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/hello.jpg" alt="svg" /></p>
<p>在你的应用程序中使用图像作为图标和背景也有助于赋予你的应用程序以风格。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="事件-events"><a class="header" href="#事件-events">事件 Events</a></h1>
<p>在前面提到的例子中，你主要看到了回调（Callback），除此之外，FLTK还提供了多种处理事件的方式：</p>
<ul>
<li>我们可以使用set_callback()方法，在点击我们的按钮时自动触发该方法。</li>
<li>我们可以使用handle()方法进行细粒度的事件处理。</li>
<li>我们可以使用emit()方法，该方法接收一个sender和一个message，这使我们可以在event loop中处理事件。</li>
<li>我们可以定义我们自己的事件，它可以在另一个部件的处理方法中被处理。</li>
</ul>
<h3 id="设置回调-callback"><a class="header" href="#设置回调-callback">设置回调 Callback</a></h3>
<p>WidgetExt trait 提供了set_callback方法。</p>
<h4 id="使用闭包"><a class="header" href="#使用闭包">使用闭包</a></h4>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(|_| println!(&quot;The button was clicked!&quot;));
    app.run().unwrap();
}
</code></pre></pre>
<p>捕获的参数是你所设置了回调的widget的可变借用<code>&amp;mut Self</code>： </p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(|b| b.set_label(&quot;Clicked!&quot;));
    app.run().unwrap();
}
</code></pre></pre>
<p>set_callback()方法有默认的触发器，不同widget可能有不同的触发器。对按钮来说，当它有焦点时，触发器是点击或按下回车。
可以通过set_trigger()方法为widget改变触发器。对于按钮可能没什么意义，但是对于Input widget来说，触发器可以被设置为 &quot;CallbackTrigger::Changed&quot;，这可以使Input widget的状态改变时触发回调：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut inp = input::Input::default()
        .with_size(160, 30)
        .center_of_parent();
    win.end();
    win.show();
    inp.set_trigger(enums::CallbackTrigger::Changed);
    inp.set_callback(|i| println!(&quot;{}&quot;, i.value()));
    a.run().unwrap();
}
</code></pre></pre>
<p>用户每输入一个字符就会打印一次。</p>
<p>使用闭包的好处是能够“关闭”作用域参数，即你也可以将周围作用域中的变量传递到闭包中：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(move |_| {
        my_window.set_label(&quot;button was pressed&quot;);
    });
    app.run().unwrap();
}
</code></pre></pre>
<p>你会注意到在<a href="Menus">菜单</a>中，处理是在每个MenuI tem基础上进行的。</p>
<h4 id="使用方法对象"><a class="header" href="#使用方法对象">使用方法对象</a></h4>
<p>如果你喜欢的话你也可以直接设置方法对象：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn button_cb(w: &amp;mut impl WidgetExt) {
    w.set_label(&quot;Clicked&quot;);
}

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();
    but.set_callback(button_cb);
    app.run().unwrap();
}
</code></pre></pre>
<p>我们使用<code>&amp;mut impl WidgetExt</code>，以便能够在多种不同的widget类型中重复使用这个函数对象。或者，你可以直接使用<code>&amp;mut button::Button</code>来表示只有Button可以使用。
这种方法的一个缺点是，为了处理状态，你必须管理全局状态：</p>
<pre><pre class="playground"><code class="language-rust edition2018">extern crate lazy_static;

use fltk::{prelude::*, *};
use std::sync::Mutex;

#[derive(Default)]
struct State {
    count: i32,
}

impl State {
    fn increment(&amp;mut self) {
        self.count += 1;
    }
}

lazy_static::lazy_static! {
    static ref STATE: Mutex&lt;State&gt; = Mutex::new(State::default());
}


fn button_cb(_w: &amp;mut button::Button) {
    let mut state = STATE.lock().unwrap();
    state.increment();
}

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Increment!&quot;);
    my_window.end();
    my_window.show();
    
    but.set_callback(button_cb);
    
    app.run().unwrap();
}
</code></pre></pre>
<p>这里我们使用lazy_static，也有其他的crate来优化状态管理。</p>
<p>同样，对菜单来说，在<code>MenuExt::add()/insert()</code>或<code>MenuItem::add()/insert()</code>方法中，我们可以使用<code>&amp;mut impl MenuExt</code>来设置menu widget和menu item的回调。</p>
<h3 id="使用处理方法-handle-method"><a class="header" href="#使用处理方法-handle-method">使用处理方法 handle method</a></h3>
<p>handle方法接收一个参数为事件的闭包，并为已处理的事件返回一个bool。这个bool值让FLTK知道该事件是否被处理。
它的调用是这样的：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();

    but.handle(|_, event| {
        println!(&quot;The event: {:?}&quot;, event);
        false
    });
    
    app.run().unwrap();
}
</code></pre></pre>
<p>这将打印出event，但并不处理它，因为我们返回false。很明显，我们想做一些有用的事情，所以把处理调用改为：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    but.handle(|_, event| match event {
        Event::Push =&gt; {
            println!(&quot;I was pushed!&quot;);
            true
        },
        _ =&gt; false,
    });
<span class="boring">}
</span></code></pre></pre>
<p>在这里，我们做一些有用的事情来处理推送事件并返回真，将其他事件都忽略并返回假。</p>
<p>另一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    but.handle(|b, event| match event {
        Event::Push =&gt; {
            b.set_label(&quot;Pushed&quot;);
            true
        },
        _ =&gt; false,
    });
<span class="boring">}
</span></code></pre></pre>
<h3 id="使用messages"><a class="header" href="#使用messages">使用messages</a></h3>
<p>这允许我们创建Channel和一个Sender Receiver结构，然后我们可以发射Message（必须是Send + Sync安全的），并在我们的事件循环中处理。这样做的好处是，当我们需要将我们的类型传递到闭包或生成的线程中时，我们不必用智能指针来包装它们。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);
    let mut but = button::Button::new(160, 200, 80, 40, &quot;Click me!&quot;);
    my_window.end();
    my_window.show();

    let (s, r) = app::channel();
    
    but.emit(s, true);
    // 这等同于调用but.set_callback(move |_| s.send(true))

    while app.wait() {
        if let Some(msg) = r.recv() {
            match msg {
                true =&gt; println!(&quot;Clicked&quot;),
                false =&gt; (), // 这里不作任何事
            }
        }
    }
}
</code></pre></pre>
<p>跟之前的例子一样，Messages 可以在事件循环中被接受， 另外你也可以在后台线程或app::add_idle()的回调中接收Message：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    app::add_idle(move || {
        if let Some(msg) = r.recv() {
            match msg {
                true =&gt; println!(&quot;Clicked&quot;),
                false =&gt; (), // 这里不做任何事
            }
        }
    });
<span class="boring">}
</span></code></pre></pre>
<p>你也不限于使用fltk channel，你可以使用任何channel。例如，这个使例子用std channel：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (s, r) = std::sync::mpsc::channel::&lt;Message&gt;();
btn.set_callback(move |_| {
    s.send(Message::SomeMessage).unwrap();
});
<span class="boring">}
</span></code></pre></pre>
<p>你也可以定义一个适用于所有widget的方法，类似于emit()方法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::sync::mpsc::Sender;

pub trait SenderWidget&lt;W, T&gt;
where
    W: WidgetExt,
    T: Send + Sync + Clone + 'static,
{
    fn send(&amp;mut self, sender: Sender&lt;T&gt;, msg: T);
}

impl&lt;W, T&gt; SenderWidget&lt;W, T&gt; for W
where
    W: WidgetExt,
    T: Send + Sync + Clone + 'static,
{
    fn send(&amp;mut self, sender: Sender&lt;T&gt;, msg: T) {
        self.set_callback(move |_| {
            sender.send(msg.clone()).unwrap();
        });
    }
}

fn main() {
    let btn = button::Button::default();
    let (s, r) = std::sync::mpsc::channel::&lt;Message&gt;();
    btn.send(s.clone(), Message::SomeMessage);
}
</code></pre></pre>
<h3 id="创建自己的events"><a class="header" href="#创建自己的events">创建自己的events</a></h3>
<p>FLTK识别了29个事件，这些事件在enums::Event中可以看到。然而，它允许我们使用app::handle(impl Into<i32>, window)调用创建我们自己的事件。handle函数接受一个任意的i32（&gt;30）值作为信号，理想情况下，这些值应该是预定义的，可以在另一个widget的handle()方法中处理，另一个widget需要在传递给app::handle的窗口中。
在下面的例子中，我们创建了一个带有Frame和button的窗口。button的回调通过app::handle_main函数发送一个CHANGED事件。该CHANGED信号在框架的handle方法中被查询到：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, button::*, enums::*, frame::*, group::*, prelude::*, window::*};
use std::cell::RefCell;
use std::rc::Rc;

pub struct MyEvent;

impl MyEvent {
    const CHANGED: i32 = 40;
}

#[derive(Clone)]
pub struct Counter {
    count: Rc&lt;RefCell&lt;i32&gt;&gt;,
}

impl Counter {
    pub fn new(val: i32) -&gt; Self {
        Counter {
            count: Rc::from(RefCell::from(val)),
        }
    }

    pub fn increment(&amp;mut self) {
        *self.count.borrow_mut() += 1;
        app::handle_main(MyEvent::CHANGED).unwrap();
    }

    pub fn decrement(&amp;mut self) {
        *self.count.borrow_mut() -= 1;
        app::handle_main(MyEvent::CHANGED).unwrap();
    }

    pub fn value(&amp;self) -&gt; i32 {
        *self.count.borrow()
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = app::App::default();
    let counter = Counter::new(0);
    let mut wind = Window::default().with_size(160, 200).with_label(&quot;Counter&quot;);
    let mut pack = Pack::default().with_size(120, 140).center_of(&amp;wind);
    pack.set_spacing(10);
    let mut but_inc = Button::default().with_size(0, 40).with_label(&quot;+&quot;);
    let mut frame = Frame::default()
        .with_size(0, 40)
        .with_label(&amp;counter.clone().value().to_string());
    let mut but_dec = Button::default().with_size(0, 40).with_label(&quot;-&quot;);
    pack.end();
    wind.end();
    wind.show();

    but_inc.set_callback({
        let mut c = counter.clone();
        move |_| c.increment()
    });

    but_dec.set_callback({
        let mut c = counter.clone();
        move |_| c.decrement()
    });
    
    frame.handle(move |f, ev| {
        if ev == MyEvent::CHANGED.into() {
            f.set_label(&amp;counter.clone().value().to_string());
            true
        } else {
            false
        }
    });

    Ok(app.run()?)
}
</code></pre></pre>
<p>发送的i32信号可以即时创建，或者也可以添加到局部/全局常量中，或者添加到一个枚举中。</p>
<h4 id="优点"><a class="header" href="#优点">优点</a></h4>
<ul>
<li>无开销。</li>
<li>该信号的处理与任何fltk事件一样。</li>
<li>app::handle函数可以返回一个bool，表示该事件是否被处理。</li>
<li>允许在事件循环之外处理自定义信号/事件。</li>
<li>允许在你的应用程序中采用MVC或SVU架构。</li>
</ul>
<h4 id="缺点"><a class="header" href="#缺点">缺点</a></h4>
<ul>
<li>该信号只能在一个widget的处理方法中处理。</li>
<li>该信号在事件循环中是不可访问的（为此，你可能想使用WidgetExt::emit或本页之前描述的channel）。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="拖放-drag--drop"><a class="header" href="#拖放-drag--drop">拖放 Drag &amp; Drop</a></h1>
<p>拖放是FLTK支持的事件类型。如果你实现了这些事件，你就可以拖动组件，也可以将外部文件拖入FLTK应用程序。你可能还想实现在widget上绘图，这就要求处理Event::Drag。</p>
<h2 id="拖动组件"><a class="header" href="#拖动组件">拖动组件</a></h2>
<p>这里我们将为窗口本身实现拖动。我们将创建一个没有边框的窗口。通常情况下，你可以使用边框来拖动窗口。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 400);
    wind.set_color(enums::Color::White);
    wind.set_border(false);
    wind.end();
    wind.show();

    wind.handle({
        let mut x = 0;
        let mut y = 0;
        move |w, ev| match ev {
            enums::Event::Push =&gt; {
                let coords = app::event_coords();
                x = coords.0;
                y = coords.1;
                true
            }
            enums::Event::Drag =&gt; {
                w.set_pos(app::event_x_root() - x, app::event_y_root() - y);
                true
            }
            _ =&gt; false,
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<h2 id="拖动文件"><a class="header" href="#拖动文件">拖动文件</a></h2>
<p>将一个文件拖入程序中会调用Paste事件，并将文件的路径填入app::event_text()。因此，当我们处理拖动时，我们想在Event::Paste中捕获路径，检查文件是否存在，读取其内容并填充我们的text widget：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, enums::Event, *};

fn main() {
    let app = app::App::default();
    let buf = text::TextBuffer::default();
    let mut wind = window::Window::default().with_size(400, 400);
    let mut disp = text::TextDisplay::default_fill();
    wind.end();
    wind.show();

    disp.set_buffer(buf.clone());
    disp.handle({
        let mut dnd = false;
        let mut released = false;
        let buf = buf.clone();
        move |_, ev| match ev {
            Event::DndEnter =&gt; {
                dnd = true;
                true
            }
            Event::DndDrag =&gt; true,
            Event::DndRelease =&gt; {
                released = true;
                true
            }
            Event::Paste =&gt; {
                if dnd &amp;&amp; released {
                    let path = app::event_text();
                    let path = path.trim();
                    let path = path.replace(&quot;file://&quot;, &quot;&quot;);
                    let path = std::path::PathBuf::from(&amp;path);
                    if path.exists() {
                        // we use a timeout to avoid pasting the path into the buffer
                        app::add_timeout3(0.0, {
                            let mut buf = buf.clone();
                            move |_| {
                                buf.load_file(&amp;path).unwrap();
                            }
                        });
                    }
                    dnd = false;
                    released = false;
                    true
                } else {
                    false
                }
            }
            Event::DndLeave =&gt; {
                dnd = false;
                released = false;
                true
            }
            _ =&gt; false,
        }
    });
    app.run().unwrap();
}
</code></pre></pre>
<p>如果你对文件的内容不感兴趣，你可以只取路径并显示给用户：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, enums::Event, *};

fn main() {
    let app = app::App::default();
    let buf = text::TextBuffer::default();
    let mut wind = window::Window::default().with_size(400, 400);
    let mut disp = text::TextDisplay::default_fill();
    wind.end();
    wind.show();

    disp.set_buffer(buf.clone());
    disp.handle({
        let mut dnd = false;
        let mut released = false;
        let mut buf = buf.clone();
        move |_, ev| match ev {
            Event::DndEnter =&gt; {
                dnd = true;
                true
            }
            Event::DndDrag =&gt; true,
            Event::DndRelease =&gt; {
                released = true;
                true
            }
            Event::Paste =&gt; {
                if dnd &amp;&amp; released {
                    let path = app::event_text();
                    buf.append(&amp;path);
                    dnd = false;
                    released = false;
                    true
                } else {
                    false
                }
            }
            Event::DndLeave =&gt; {
                dnd = false;
                released = false;
                true
            }
            _ =&gt; false,
        }
    });
    app.run().unwrap();
}
</code></pre></pre>
<h2 id="拖动绘图"><a class="header" href="#拖动绘图">拖动绘图</a></h2>
<p>你可以在事件里面绘图，但你会可能想使用屏幕外的画法。在widget绘图方法中，你只是把屏幕外的内容复制到widget中。一个更详细的例子可以在<a href="Drawing.html#offscreen-drawing">绘图</a>中的屏幕外绘图部分看到。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="状态管理器-state-management"><a class="header" href="#状态管理器-state-management">状态管理器 State management</a></h1>
<p>FLTK并不强加某种形式的状态管理或应用程序架构。这是留给用户自己选择的。fltk-rs repo和本书中的所有例子都已经使用了回调（Callback）或消息（message），你会发现很多这两种方法的例子。
这些都在<a href="Events.html">事件 Event</a>中讨论过。</p>
<p>此外，所有的例子可能看起来都是在主函数中处理一切，这只是为了简化。您可以创建自己的应用程序结构，将主窗口和您的应用程序的状态包含在其中：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

#[derive(Copy, Clone)]
enum Message {
    Inc,
    Dec,
}

struct MyApp {
    app: app::App,
    main_win: window::Window,
    frame: frame::Frame,
    count: i32,
    receiver: app::Receiver&lt;Message&gt;,
}

impl MyApp {
    pub fn new() -&gt; Self {
        let count = 0;
        let app = app::App::default();
        let (s, receiver) = app::channel();
        let mut main_win = window::Window::default().with_size(400, 300);
        let col = group::Flex::default()
            .with_size(100, 200)
            .column()
            .center_of_parent();
        let mut inc = button::Button::default().with_label(&quot;+&quot;);
        inc.emit(s, Message::Inc);
        let frame = frame::Frame::default().with_label(&amp;count.to_string());
        let mut dec = button::Button::default().with_label(&quot;-&quot;);
        dec.emit(s, Message::Dec);
        col.end();
        main_win.end();
        main_win.show();
        Self {
            app,
            main_win,
            frame,
            count,
            receiver,
        }
    }

    pub fn run(mut self) {
        while self.app.wait() {
            if let Some(msg) = self.receiver.recv() {
                match msg {
                    Message::Inc =&gt; self.count += 1,
                    Message::Dec =&gt; self.count -= 1,
                }
                self.frame.set_label(&amp;self.count.to_string());
            }
        }
    }
}

fn main() {
    let a = MyApp::new();
    a.run();
}
</code></pre></pre>
<h2 id="helper-crates"><a class="header" href="#helper-crates">Helper crates</a></h2>
<p>crates生态系统给出了许多提供状态管理的crates。此外，在fltk-rs组织下有2个crate，它们提供了架构你的应用程序和管理其状态的方法：</p>
<ul>
<li><a href="https://github.com/fltk-rs/flemish">flemish</a>:</li>
</ul>
<p>提供了一个类似Elm的SVU架构。这是反应式（reactive）的，本质上是不可变的，而且拆解了每个Message的view。</p>
<ul>
<li><a href="https://github.com/fltk-rs/fltk-evented">fltk-evented</a>:</li>
</ul>
<p>这类似于即时模式的guis，所有事件都在事件循环中处理。在现实中，它也是反应式的，但却是可变的和无状态的。这不会引起触发器的重绘。</p>
<p>这两个crate都避免使用回调，因为在Rust中，由于生命周期和借用机制，处理这些回调极其麻烦。你需要使用具有内部可变性的共享智能指针，才能够借用回调。</p>
<p>你可以看一下这两个crate以获得灵感。</p>
<p>在这两个crate中都展示了一个示例计数器：</p>
<h2 id="flemish"><a class="header" href="#flemish">Flemish</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">use flemish::{
    button::Button, color_themes, frame::Frame, group::Flex, prelude::*, OnEvent, Sandbox, Settings,
};

pub fn main() {
    Counter::new().run(Settings {
        size: (300, 100),
        resizable: true,
        color_map: Some(color_themes::BLACK_THEME),
        ..Default::default()
    })
}

#[derive(Default)]
struct Counter {
    value: i32,
}

#[derive(Debug, Clone, Copy)]
enum Message {
    IncrementPressed,
    DecrementPressed,
}

impl Sandbox for Counter {
    type Message = Message;

    fn new() -&gt; Self {
        Self::default()
    }

    fn title(&amp;self) -&gt; String {
        String::from(&quot;Counter - fltk-rs&quot;)
    }

    fn update(&amp;mut self, message: Message) {
        match message {
            Message::IncrementPressed =&gt; {
                self.value += 1;
            }
            Message::DecrementPressed =&gt; {
                self.value -= 1;
            }
        }
    }

    fn view(&amp;mut self) {
        let col = Flex::default_fill().column();
        Button::default()
            .with_label(&quot;Increment&quot;)
            .on_event(Message::IncrementPressed);
        Frame::default().with_label(&amp;self.value.to_string());
        Button::default()
            .with_label(&quot;Decrement&quot;)
            .on_event(Message::DecrementPressed);
        col.end();
    }
}
</code></pre></pre>
<h2 id="fltk-evented"><a class="header" href="#fltk-evented">fltk-evented</a></h2>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, button::Button, frame::Frame, group::Flex, prelude::*, window::Window};
use fltk_evented::Listener;

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    app::set_font_size(20);

    let mut wind = Window::default()
        .with_size(160, 200)
        .center_screen()
        .with_label(&quot;Counter&quot;);
    let flex = Flex::default()
        .with_size(120, 160)
        .center_of_parent()
        .column();
    let but_inc: Listener&lt;_&gt; = Button::default().with_label(&quot;+&quot;).into();
    let mut frame = Frame::default();
    let but_dec: Listener&lt;_&gt; = Button::default().with_label(&quot;-&quot;).into();
    flex.end();
    wind.end();
    wind.show();

    let mut val = 0;
    frame.set_label(&amp;val.to_string());

    while a.wait() {
        if but_inc.triggered() {
            val += 1;
            frame.set_label(&amp;val.to_string());
        }

        if but_dec.triggered() {
            val -= 1;
            frame.set_label(&amp;val.to_string());
        }
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="布局-layouts"><a class="header" href="#布局-layouts">布局 Layouts</a></h1>
<p>Rust提供了开箱即用的：</p>
<ul>
<li>A Flex widget</li>
<li>Pack</li>
<li>Grid</li>
<li>Widget relative positioning.</li>
</ul>
<h3 id="flex"><a class="header" href="#flex">Flex</a></h3>
<p>Flex widget允许进行灵活的布局。它在group module中，实现了GroupExt trait。有2种形式的Flexwidget，可以使用set_type或with_type方法指定。比如列（Column） 和 行（Row）：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut win = window::Window::default().with_size(400, 300);
    let mut flex = Flex::new(0, 0, 400, 300, None);
    flex.set_type(group::FlexType::Column);
    let expanding = button::Button::default().with_label(&quot;Expanding&quot;);
    let mut normal = button::Button::default().with_label(&quot;Normal&quot;);
    flex.set_size(&amp;mut normal, 30);
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p>set_size方法接收另一个widget并将其大小固定为所传递的值，在这个例子中是30。因为这是一个column，所以30代表要设置的widget的高度。
另一个widget是可扩展的，因为没有为它设置尺寸。一个完整的例子可以在这里找到。</p>
<p><a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/flex.rs">第一个例子</a></p>
<p><img src="https://github.com/osen/FL_Flex/raw/main/doc/login.png" alt="image" /></p>
<h3 id="packs"><a class="header" href="#packs">Packs</a></h3>
<p>pack widget（在group module中）也实现了GroupExt trait。有两种形式的Pack，Vertical Pack 和 Horizontal Pack，Vertical Pack是默认的。它只需要子widget的高度，而Horizontal Pack只需要它的子widget的宽度，像下面的例子：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::default().with_size(400, 300);
    let mut hpack = group::Pack::default().with_size(190, 40).center_of(&amp;my_window);
    hpack.set_type(group::PackType::Horizontal);
    hpack.set_spacing(30);
    let _but1 = button::Button::default().with_size(80, 0).with_label(&quot;Button1&quot;);
    let _but2 = button::Button::default().with_size(80, 0).with_label(&quot;Button2&quot;);
    hpack.end();
    my_window.end();
    my_window.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>这就在窗口内创建了一个Pack Widget，并在其中填入2个按钮。注意，按钮的x和y坐标不再需要了。你也可以像 repo 中的Calculator示例一样，在Pack中嵌入Pack。
你也可以使用Pack::auto_layout()方法：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::default().with_size(400, 300);
    let mut hpack = group::Pack::new(0, 200, 400, 100, &quot;&quot;);
    hpack.set_type(group::PackType::Horizontal);
    hpack.set_spacing(30);
    let _but1 = button::Button::default().with_label(&quot;Button1&quot;);
    let _but2 = button::Button::default().with_label(&quot;Button2&quot;);
    hpack.end();
    hpack.auto_layout();
    my_window.end();
    my_window.show();

    app.run().unwrap();
}
</code></pre></pre>
<p>在这种情况下，我们甚至不需要按钮的大小。</p>
<p><img src="https://user-images.githubusercontent.com/37966791/100937983-ef8bf400-3504-11eb-9da1-09c5ac1aade4.png" alt="image" /></p>
<h3 id="grid"><a class="header" href="#grid">Grid</a></h3>
<p><a href="https://github.com/fltk-rs/fltk-grid">Grid</a>目前是在一个external crate中实现的。它需要一个layout，使用<code>Grid::set_layout(&amp;mut self, rows, columns)</code>来设置。然后通过<code>Grid::insert(&amp;mut self, row, column)</code>或<code>Grid::insert_ext(&amp;mut self, row, column, row_span, column_span)</code>方法插入widget。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};
use fltk_grid::Grid;

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut win = window::Window::default().with_size(500, 300);
    let mut grid = Grid::default_fill();
    // 设置为 &quot;true &quot;以显示单元格的框线和数字
    grid.debug(false); 
    // 5 行，5 列
    grid.set_layout(5, 5); 
    // 组件，行，列
    grid.insert(&amp;mut button::Button::default().with_label(&quot;Click&quot;), 0, 1); 
    // widget, row, col, row_span, col_span
    grid.insert_ext(&amp;mut button::Button::default().with_label(&quot;Button 2&quot;), 2, 1, 3, 1); 
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p><a href="https://github.com/fltk-rs/fltk-grid/blob/main/examples/form.rs">Grid example</a></p>
<p><img src="https://user-images.githubusercontent.com/37966791/160347418-b8b54408-3dc9-4fc4-93e8-fb6c1c0282e9.png" alt="image" /></p>
<h3 id="relative-positioning"><a class="header" href="#relative-positioning">Relative positioning</a></h3>
<p>WidgetExt trait提供了几个构造方法，允许我们相对于其他widget的大小和位置来构造widget。这类似于Qml的锚定（anchoring）：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default()
        .with_size(160, 200)
        .center_screen()
        .with_label(&quot;Counter&quot;);
    let mut frame = frame::Frame::default()
        .with_size(100, 40)
        .center_of(&amp;wind)
        .with_label(&quot;0&quot;);
    let mut but_inc = button::Button::default()
        .size_of(&amp;frame)
        .above_of(&amp;frame, 0)
        .with_label(&quot;+&quot;);
    let mut but_dec = button::Button::default()
        .size_of(&amp;frame)
        .below_of(&amp;frame, 0)
        .with_label(&quot;-&quot;);
    wind.end();
    wind.show();
    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/counter.jpg" alt="counter" /></p>
<p>(有一些跳过的主题设计)</p>
<p>这些方法是：</p>
<ul>
<li><code>above_of(&amp;widget, padding)</code>: 将该widget置于所传递的widget之上</li>
<li><code>below_of(&amp;widget, padding)</code>: 将该widget置于所传递的widget之下</li>
<li><code>right_of(&amp;widget, padding)</code>: 将该widget置于所传递的widget右边</li>
<li><code>left_of(&amp;widget, padding)</code>:将该widget置于所传递的widget左边</li>
<li><code>center_of(&amp;widget)</code>: 将widget放置在所传递的widget的中心（包括x和y轴）</li>
<li><code>center_of_parent()</code>: 将widget放在父widget的中心位置（包括x轴和y轴）</li>
<li><code>center_x(&amp;widget)</code>: 将widget放置在所传递的widget的中心（X轴）</li>
<li><code>center_y(&amp;widget)</code>: 将widget放置在所传递的widget的中心（Y轴）</li>
<li><code>size_of(&amp;widget)</code>: 构建与所传widget相同大小的widget</li>
<li><code>size_of_parent()</code>: 构建与其父widget相同大小的widget</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="样式-style"><a class="header" href="#样式-style">样式 Style</a></h1>
<p>FLTK为你的应用程序提供了广泛的自定义style选项，从改变应用程序的总体方案，到自定义颜色、字体、框架类型、自定义绘图...等等。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="颜色-colors"><a class="header" href="#颜色-colors">颜色 Colors</a></h1>
<p>FLTK可以处理<a href="https://en.wikipedia.org/wiki/Color_depth#True_color_(24-bit)">true color</a>。一些方便的颜色在enums::Color枚举中列举：</p>
<ul>
<li>Black</li>
<li>White</li>
<li>Red</li>
<li>Blue</li>
<li>Cyan
...etc.</li>
</ul>
<p>你也可以使用颜色方法构建你的颜色：</p>
<ul>
<li>by_index()。这使用了fltk的colorormap。值范围是0到255。</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let red = Color::by_index(88);
<span class="boring">}
</span></code></pre></pre>
<p><img src="https://www.fltk.org/doc-1.3/fltk-colormap.png" alt="colormap" /></p>
<ul>
<li>from_hex()。这需要一个24位的十六进制值，形式为RGB。</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RED: Color = Color::from_hex(0xff0000); // notice it's a const functions
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>from_rgb()。这需要3个值r、g、b：</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RED: Color = Color::from_rgb(255, 0, 0); // notice it's a const functions
<span class="boring">}
</span></code></pre></pre>
<p>颜色枚举还提供了一些方便的方法，使用.darker()、.lighter()、.inactive()等方法生成所选颜色的不同色调的颜色：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let col = Color::from_rgb(176, 100, 50).lighter();
<span class="boring">}
</span></code></pre></pre>
<p>如果你喜欢html十六进制字符串的颜色，你可以使用from_hex_str()方法：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let col = Color::from_hex_str(&quot;#ff0000&quot;);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="帧类型-frametypes"><a class="header" href="#帧类型-frametypes">帧类型 FrameTypes</a></h1>
<p>FLTK有广泛的帧类型。这些可以在enums模块下找到：
<img src="https://github.com/fltk-rs/fltk-rs/raw/master/screenshots/frames.jpg" alt="image" /></p>
<p>这些可以用WidgetExt::set_frame()来设置。一些widget/traits也支持set_down_frame()：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, &quot;Hello from rust&quot;);

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load(&quot;screenshots/RustLogo.svg&quot;).unwrap();
    image.scale(200, 200, true, true);
    frame.set_image(Some(image));

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-rs/raw/master/screenshots/hello.jpg" alt="image" />
在这里，我们将Frame的FrameType设置为EngravedBox，你可以看到图像周围的情况。</p>
<p>​	ButtonExt支持set_down_frame()：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>btn1.set_frame(enums::FrameType::RFlatBox);
btn1.set_down_frame(enums::FrameType::RFlatBox);
<span class="boring">}
</span></code></pre></pre>
<p>此外，我们可以使用app::set_frame_type_cb()来改变我们的FrameTypes的绘制程序：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    enums::{Color, FrameType},
    prelude::*,
    *
};

fn down_box(x: i32, y: i32, w: i32, h: i32, c: Color) {
    draw::draw_box(FrameType::RFlatBox, x, y, w, h, Color::BackGround2);
    draw::draw_box(FrameType::RoundedFrame, x - 10, y, w + 20, h, c);
}

fn main() {
    let app = app::App::default();
    app::set_frame_type_cb(FrameType::DownBox, down_box, 0, 0, 0, 0);
    let mut w = window::Window::default().with_size(480, 230).with_label(&quot;Gui&quot;);
    w.set_color(Color::from_u32(0xf5f5f5));

    let mut txf = input::Input::default().with_size(160, 30).center_of_parent();    
    txf.set_color(Color::Cyan.darker());

    w.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/146932070-ae63fd63-3f37-4d97-978e-4604d2bc0e4b.png" alt="image" /></p>
<p>这就用一个自定义的down_box路径改变了默认的DownBox。我们也可以在我们的绘制例程中使用ImageExt::draw()来绘制图像（比如svg图像，以获得可伸缩的圆角边框）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字体-fonts"><a class="header" href="#字体-fonts">字体 Fonts</a></h1>
<p>FLTK已经有16种字体，可以在enums::Font中找到：</p>
<ul>
<li>Helvetica</li>
<li>HelveticaBold</li>
<li>HelveticaItalic</li>
<li>HelveticaBoldItalic</li>
<li>Courier</li>
<li>CourierBold</li>
<li>CourierItalic</li>
<li>CourierBoldItalic</li>
<li>Times</li>
<li>TimesBold</li>
<li>TimesItalic </li>
<li>TimesBoldItalic </li>
<li>Symbol </li>
<li>Screen </li>
<li>ScreenBold </li>
<li>Zapfdingbats</li>
</ul>
<p>它还允许加载系统字体和捆绑字体。</p>
<p>系统字体依赖于系统，默认情况下不被加载。这些字体可以用App::load_system_fonts()方法加载。
然后可以使用app::fonts()函数获取字体，还可以使用app::font_count()、app::font_name()和app::font_index()函数进行查询。
然后可以使用Font::by_index()或Font::by_name()方法来使用。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default().load_system_fonts();
    // 要按路径加载字体，请检查App::load_font()方法
    let fonts = app::fonts();
    // println!(&quot;{:?}&quot;, fonts);
    let mut wind = window::Window::default().with_size(400, 300);
    let mut frame = frame::Frame::default().size_of(&amp;wind);
    frame.set_label_size(30);
    wind.set_color(enums::Color::White);
    wind.end();
    wind.show();
    println!(&quot;The system has {} fonts!\nStarting slideshow!&quot;, fonts.len());
    let mut i = 0;
    while app.wait() {
        if i == fonts.len() {
            i = 0;
        }
        frame.set_label(&amp;format!(&quot;[{}]&quot;, fonts[i]));
        frame.set_label_font(enums::Font::by_index(i));
        app::sleep(0.5);
        i += 1;
    }
}
</code></pre></pre>
<p>如果你想加载一个不在系统中的捆绑字体，你可以选择使用Font::load_font()和Font::set_font()，这允许你用自定义字体替换FLTK的预定义字体：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, enums::Font, button::Button, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();

    let font = Font::load_font(&quot;angelina.ttf&quot;).unwrap();
    Font::set_font(Font::Helvetica, &amp;font);
    app::set_font_size(24);

    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, &quot;Click me!&quot;);
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label(&quot;Hello world&quot;));

    app.run().unwrap();
}
</code></pre></pre>
<p>load_font()从.ttf文件中加载字体，set_font()用我们加载的字体替换Font::Helvetica（FLTK的默认字体）：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145735197-130f7dd6-a31f-4bc6-a362-90a13493a556.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="绘制事物-drawing-things"><a class="header" href="#绘制事物-drawing-things">绘制事物 Drawing things</a></h1>
<p>fltk-rs在draw module中提供了让你绘制自定义元素的自由函数。只有当调用是在允许绘制的上下文中进行时，例如在WidgetBase::draw()方法中或在Offscreen上下文中，绘制才有效：</p>
<h2 id="在组件上绘制"><a class="header" href="#在组件上绘制">在组件上绘制</a></h2>
<p>注意，我们在widget的draw方法中使用了draw调用：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.end();
    win.show();

    win.draw(|w| {
        use draw::*;
        // 白色窗口
        draw_rect_fill(0, 0, w.w(), w.h(), enums::Color::White);
        // 画一个蓝色的圆
        set_draw_color(enums::Color::Blue.inactive());
        draw_pie(w.w() / 2 - 50, w.h() / 2 - 50, 100, 100, 0.0, 360.0);
        // 绘制具有角度的字体
        set_draw_color(enums::Color::Red);
        set_font(enums::Font::Courier, 16);
        draw_text_angled(45, &quot;Hello World&quot;, w.w() / 2, w.h() / 2);
    });

    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145693473-defb2298-fc6b-4d2f-8a0c-3d4902b39dd3.jpg" alt="draw" /></p>
<p>我们用整个窗口作为我们的画布，也可以是在任何widget上。其他可用的功能允许绘制直线、矩形、弧线、饼、循环、多边形，甚至图像。</p>
<h2 id="在屏幕外绘制"><a class="header" href="#在屏幕外绘制">在屏幕外绘制</a></h2>
<p>有时你想根据事件来画东西，比如推拖光标的时候。在这种情况下，你可以使用draw::Offscreen来做到这一点。在这种情况下，我们使用widget的draw方法只是复制屏幕外的内容，而绘制是在widget的handle方法中进行的。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    app,
    draw::{
        draw_line, draw_point, draw_rect_fill, set_draw_color, set_line_style, LineStyle, Offscreen,
    },
    enums::{Color, Event, FrameType},
    frame::Frame,
    prelude::*,
    window::Window,
};
use std::cell::RefCell;
use std::rc::Rc;

const WIDTH: i32 = 800;
const HEIGHT: i32 = 600;

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);

    let mut wind = Window::default()
        .with_size(WIDTH, HEIGHT)
        .with_label(&quot;RustyPainter&quot;);
    let mut frame = Frame::default()
        .with_size(WIDTH - 10, HEIGHT - 10)
        .center_of(&amp;wind);
    frame.set_color(Color::White);
    frame.set_frame(FrameType::DownBox);

    wind.end();
    wind.show();

    // We fill our offscreen with white
    let offs = Offscreen::new(frame.width(), frame.height()).unwrap();
    #[cfg(not(target_os = &quot;macos&quot;))]
    {
        offs.begin();
        draw_rect_fill(0, 0, WIDTH - 10, HEIGHT - 10, Color::White);
        offs.end();
    }

    let offs = Rc::from(RefCell::from(offs));

    frame.draw({
        let offs = offs.clone();
        move |_| {
            let mut offs = offs.borrow_mut();
            if offs.is_valid() {
                offs.rescale();
                offs.copy(5, 5, WIDTH - 10, HEIGHT - 10, 0, 0);
            } else {
                offs.begin();
                draw_rect_fill(0, 0, WIDTH - 10, HEIGHT - 10, Color::White);
                offs.copy(5, 5, WIDTH - 10, HEIGHT - 10, 0, 0);
                offs.end();
            }
        }
    });

    frame.handle({
        let mut x = 0;
        let mut y = 0;
        move |f, ev| {
            // println!(&quot;{}&quot;, ev);
            // println!(&quot;coords {:?}&quot;, app::event_coords());
            // println!(&quot;get mouse {:?}&quot;, app::get_mouse());
            let offs = offs.borrow_mut();
            match ev {
                Event::Push =&gt; {
                    offs.begin();
                    set_draw_color(Color::Red);
                    set_line_style(LineStyle::Solid, 3);
                    let coords = app::event_coords();
                    x = coords.0;
                    y = coords.1;
                    draw_point(x, y);
                    offs.end();
                    f.redraw();
                    set_line_style(LineStyle::Solid, 0);
                    true
                }
                Event::Drag =&gt; {
                    offs.begin();
                    set_draw_color(Color::Red);
                    set_line_style(LineStyle::Solid, 3);
                    let coords = app::event_coords();
                    draw_line(x, y, coords.0, coords.1);
                    x = coords.0;
                    y = coords.1;
                    offs.end();
                    f.redraw();
                    set_line_style(LineStyle::Solid, 0);
                    true
                }
                _ =&gt; false,
            }
        }
    });

    app.run().unwrap();
}
</code></pre></pre>
<p>注意我们是如何用offs.begin()打开一个Offscreen上下文，然后用offs.end()关闭它。这使得我们可以在Offscreen内调用绘图函数：</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146173813-67038a94-7739-480e-a181-29498aac842a.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="样式设计-styling"><a class="header" href="#样式设计-styling">样式设计 Styling</a></h1>
<p>FLTK在风格化应用方面提供了许多东西。我们已经看到，我们可以使用true color和不同的字体，此外还可以进行自定义绘制。Styling就是利用所有这些。它可以利用WidgetExt中的方法在每个widget上进行，也可以使用app模块中的函数在全局上完成。</p>
<h2 id="widgetext"><a class="header" href="#widgetext">WidgetExt</a></h2>
<p>大多数WidgetExt trait与修改框架类型、标签类型、widget颜色、文本颜色、文本字体和文本大小有关。
这些都有setter和 getter，可以在[这里]（https://docs.rs/fltk/*/fltk/prelude/trait.WidgetExt.html）找到。</p>
<p>一个例子：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{
    enums::{Align, Color, Font, FrameType},
    prelude::*,
    *,
};

const BLUE: Color = Color::from_hex(0x42A5F5);
const SEL_BLUE: Color = Color::from_hex(0x2196F3);
const GRAY: Color = Color::from_hex(0x757575);
const WIDTH: i32 = 600;
const HEIGHT: i32 = 400;

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default()
        .with_size(WIDTH, HEIGHT)
        .with_label(&quot;Flutter-like!&quot;);
    let mut bar =
        frame::Frame::new(0, 0, WIDTH, 60, &quot;  FLTK App!&quot;).with_align(Align::Left | Align::Inside);
    let mut text = frame::Frame::default()
        .with_size(100, 40)
        .center_of(&amp;win)
        .with_label(&quot;You have pushed the button this many times:&quot;);
    let mut count = frame::Frame::default()
        .size_of(&amp;text)
        .below_of(&amp;text, 0)
        .with_label(&quot;0&quot;);
    let mut but = button::Button::new(WIDTH - 100, HEIGHT - 100, 60, 60, &quot;@+6plus&quot;);
    win.end();
    win.make_resizable(true);
    win.show();

    // Theming
    app::background(255, 255, 255);
    app::set_visible_focus(false);

    bar.set_frame(FrameType::FlatBox);
    bar.set_label_size(22);
    bar.set_label_color(Color::White);
    bar.set_color(BLUE);
    bar.draw(|b| {
        draw::set_draw_rgb_color(211, 211, 211);
        draw::draw_rectf(0, b.height(), b.width(), 3);
    });

    text.set_label_size(18);
    text.set_label_font(Font::Times);

    count.set_label_size(36);
    count.set_label_color(GRAY);

    but.set_color(BLUE);
    but.set_selection_color(SEL_BLUE);
    but.set_label_color(Color::White);
    but.set_frame(FrameType::OFlatFrame);
    // End theming

    but.set_callback(move |_| {
        let label = (count.label().parse::&lt;i32&gt;().unwrap() + 1).to_string();
        count.set_label(&amp;label);
    });

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/flutter_like.jpg" alt="counter" /></p>
<p>widget也支持在其中显示图像，这在image章节有更多讨论。</p>
<h2 id="global-styling"><a class="header" href="#global-styling">Global styling</a></h2>
<p>这些可以在程序module中找到。从改变程序的主题开始：</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, enums::*, *};
let app = app::App::default().with_scheme(app::Scheme::Plastic);
<span class="boring">}
</span></code></pre></pre>
<p>提供有四个主题：</p>
<ul>
<li>Base</li>
<li>Gtk</li>
<li>Gleam</li>
<li>Plastic</li>
</ul>
<p>设置应用程序的颜色、默认字体、默认框架类型和是否在widget上显示焦点：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{app, button::Button, enums, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();
    app::set_background_color(170, 189, 206);
    app::set_background2_color(255, 255, 255);
    app::set_foreground_color(0, 0, 0);
    app::set_selection_color(255, 160,  63);
    app::set_inactive_color(130, 149, 166);
    app::set_font(enums::Font::Times);
    
    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, &quot;Click me!&quot;);
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label(&quot;Hello world&quot;));

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727821-5923fcd4-3a57-4a15-b36f-574b3e5321ea.png" alt="image" /></p>
<h3 id="custom-drawing"><a class="header" href="#custom-drawing">Custom Drawing</a></h3>
<p>FLTK还提供了原始绘图drawing primitives，这使得给widget自定义外观非常容易。这是用draw()方法完成的，它需要一个闭包。让我们来绘制一个自己的按钮（虽然FLTK提供了一个ShadowFrame FrameType），在这里创建一个我们自己的：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, enums::*, *};

fn main() {
    let app = app::App::default();
    app::set_color(255, 255, 255); // white
    let mut my_window = window::Window::new(100, 100, 400, 300, &quot;My Window&quot;);

    let mut but = button::Button::default()
        .with_pos(160, 210)
        .with_size(80, 40)
        .with_label(&quot;Button1&quot;);

    but.draw2(|b| {
        draw::set_draw_color(Color::Gray0);
        draw::draw_rectf(b.x() + 2, b.y() + 2, b.width(), b.height());
        draw::set_draw_color(Color::from_u32(0xF5F5DC));
        draw::draw_rectf(b.x(), b.y(), b.width(), b.height());
        draw::set_draw_color(Color::Black);
        draw::draw_text2(
            &amp;b.label(),
            b.x(),
            b.y(),
            b.width(),
            b.height(),
            Align::Center,
        );
    });

    my_window.end();
    my_window.show();

    app.run().unwrap();
}
</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/100938232-62956a80-3505-11eb-888f-ffe655e7aadc.jpg" alt="draw" /></p>
<p>draw()方法也支持在widget内部绘制图像，这将在下一节看到。</p>
<h2 id="fltk-theme"><a class="header" href="#fltk-theme">fltk-theme</a></h2>
<p>这是一个<a href="https://github.com/fltk-rs/fltk-theme">crate</a>，它提供了几个预定义的主题，只要加载主题就可以使用</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{prelude::*, *};
use fltk_theme::{widget_themes, WidgetTheme, ThemeType};

fn main() {
    let a = app::App::default();
    let widget_theme = WidgetTheme::new(ThemeType::Aero);
    widget_theme.apply();
    let mut win = window::Window::default().with_size(400, 300);
    let mut btn = button::Button::new(160, 200, 80, 30, &quot;Hello&quot;);
    btn.set_frame(widget_themes::OS_DEFAULT_BUTTON_UP_BOX);
    win.end();
    win.show();
    a.run().unwrap();
}
</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-theme/raw/main/screenshots/aqua_classic.jpg" alt="aqua-classic" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动画-animations"><a class="header" href="#动画-animations">动画 Animations</a></h1>
<p>动画可以通过几种机制在fltk-rs中显示：</p>
<ul>
<li>利用事件循环 Leveraging the event loop</li>
<li>使用线程 Spawning threads</li>
<li>超时 Timeouts</li>
</ul>
<h2 id="利用事件循环"><a class="header" href="#利用事件循环">利用事件循环</a></h2>
<p>fltk提供了app::wait()和app::check()，允许在一个阻塞操作中更新ui：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::*, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    // 我们的按钮占据了窗口的左侧
    let mut sliding_btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut sliding_btn);
    win.end();
    win.show();

    sliding_btn.set_callback(|btn| {
        if btn.w() &gt; 0 &amp;&amp; btn.w() &lt; 100 {
            return; // we're still animating
        }
        while btn.w() != 0 {
            btn.set_size(btn.w() - 2, btn.h());
            app::sleep(0.016);
            btn.parent().unwrap().redraw();
            app::wait(); // or app::check();
        }
    });
    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}
</code></pre></pre>
<h2 id="使用线程"><a class="header" href="#使用线程">使用线程</a></h2>
<p>这确保我们不会阻塞主/ui线程：</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::*, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    // our button takes the whole left side of the window
    let mut sliding_btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut sliding_btn);
    win.end();
    win.show();

    sliding_btn.set_callback(|btn| {
        if btn.w() &gt; 0 &amp;&amp; btn.w() &lt; 100 {
            return; // we're still animating
        }
        std::thread::spawn({
            let mut btn = btn.clone();
            move || {
                while btn.w() != 0 {
                    btn.set_size(btn.w() - 2, btn.h());
                    app::sleep(0.016);
                    app::awake(); // to awaken the ui thread
                    btn.parent().unwrap().redraw();
                }
            }
        });
    });
    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}
</code></pre></pre>
<h2 id="超时"><a class="header" href="#超时">超时</a></h2>
<p>fltk为重复性操作提供了timeout功能。我们可以添加一个timeout，重复操作或让它消失。</p>
<pre><pre class="playground"><code class="language-rust edition2018">use fltk::{enums::*, prelude::*, *};

fn move_button(mut btn: button::Button, handle: app::TimeoutHandle) {
    btn.set_size(btn.w() - 2, btn.h());
    btn.parent().unwrap().redraw();
    if btn.w() == 20 {
        app::remove_timeout3(handle);
    } else {
        app::repeat_timeout3(0.016, handle);
    }
}

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    let mut btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut btn);
    btn.clear_visible_focus();
    win.end();
    win.show();

    btn.set_callback(|b| {
        let btn = b.clone();
        app::add_timeout3(0.016, move |handle| {
            let btn = btn.clone();
            move_button(btn, handle)
        });
    });

    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}
</code></pre></pre>
<p>我们是在用户点击按钮时加入timeout，根据按钮的大小，我可以重复使用或者删除它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="build-issues"><a class="header" href="#build-issues">Build issues</a></h2>
<h3 id="why-does-the-build-fails-when-i-follow-one-of-the-tutorials"><a class="header" href="#why-does-the-build-fails-when-i-follow-one-of-the-tutorials">Why does the build fails when I follow one of the tutorials?</a></h3>
<p>The first tutorial uses the fltk-bundled feature flag, which is only supported for certain platforms since these are built using the Github Actions CI, namely:</p>
<ul>
<li>Windows 10 x64 (msvc and gnu).</li>
<li>MacOS 12 x64 and aarch64.</li>
<li>Ubuntu 20.04 or later, x64 and aarch64.</li>
</ul>
<p>If you're not running one of the aforementioned platforms, you'll have to remove the fltk-bundled feature flag in your Cargo.toml file:</p>
<pre><code class="language-toml">[dependencies]
fltk = &quot;^1.3&quot;
</code></pre>
<p>Furthermore, the fltk-bundled flag assumes you have curl and tar installed (for Windows, they're available in the Native Tools Command Prompt).</p>
<h3 id="build-fails-on-windows-why-cant-cmake-find-my-toolchain"><a class="header" href="#build-fails-on-windows-why-cant-cmake-find-my-toolchain">Build fails on windows, why can't CMake find my toolchain?</a></h3>
<p>If you're building using the MSVC toolchain, make sure you run your build (at least your initial build) using the Native Tools Command Prompt, which should appear once you start typing &quot;native&quot; in the start menu, choose the version corresponding to your installed Rust toolchain (x86 or x64). The Native Tools Command Prompt has all the environment variables set correctly for native development. <a href="https://github.com/alexcrichton/cmake-rs">cmake-rs</a> which the bindings use might not be able to find the Visual Studio 2022 generator, in which case, you can try to use the fltk-bundled feature, or use ninja via the use-ninja feature. This requires installing <a href="https://github.com/ninja-build/ninja/wiki/Pre-built-Ninja-packages">Ninja</a> which can be installed with Chocolatey, Scoop or manually.</p>
<p>If you're building for the GNU toolchain, make sure that Make is also installed, which usually comes installed in mingw64 toolchain.</p>
<h3 id="build-fails-on-macos-11-with-an-apple-m1-chip-what-can-i-do"><a class="header" href="#build-fails-on-macos-11-with-an-apple-m1-chip-what-can-i-do">Build fails on MacOS 11 with an Apple M1 chip, what can I do?</a></h3>
<p>If you're getting &quot;file too small to be an archive&quot; error, you might be hitting this <a href="https://github.com/rust-lang/cargo/issues/8875">issues</a> or this <a href="https://github.com/rust-lang/rust/issues/50220">issue</a>. MacOS's native C/C++ toolchain shouldn't have this issue, and can be installed by running <code>xcode-select --install</code> or by installing XCode. Make sure the corresponding Rust toolchain (aarch64-apple-darwin) is installed as well. You can uninstall other Rust apple-darwin toolchains or use cargo-lipo instead if you need universal/fat binaries.</p>
<h3 id="why-do-i-get-a-link-error-while-using-the-mingw-toolchain-on-windows"><a class="header" href="#why-do-i-get-a-link-error-while-using-the-mingw-toolchain-on-windows">Why do I get a Link error while using the mingw toolchain on windows?</a></h3>
<p>If the linking fails because of this <a href="https://github.com/rust-lang/rust/issues/47048">issue</a> with older toolchains, it should work by using the fltk-shared feature (an issue with older compilers). Which would also generate a dynamic library which would need to be deployed with your application.</p>
<pre><code class="language-toml">[dependencies]
fltk = { version = &quot;^1.3&quot;, features = [&quot;fltk-shared&quot;] }
</code></pre>
<h3 id="why-does-my-msys2-mingw-built-fltk-app-using-fltk-bundled-isnt-self-contained-and-requires-several-dlls"><a class="header" href="#why-does-my-msys2-mingw-built-fltk-app-using-fltk-bundled-isnt-self-contained-and-requires-several-dlls">Why does my msys2 mingw built fltk app using, fltk-bundled, isn't self-contained and requires several dlls?</a></h3>
<p>If you have installed libgdiplus via pacman, it would require those dependencies on other systems. If you're using the windows sdk-provided libgdiplus, it shouldn't require extra dlls. You can either uninstall libgdiplus that was installed via pacman, or or you can build using the feature flag: <code>no-gdiplus</code>.</p>
<h3 id="why-do-i-get-link-errors-when-i-use-the-system-fltk-feature"><a class="header" href="#why-do-i-get-link-errors-when-i-use-the-system-fltk-feature">Why do I get link errors when I use the system-fltk feature?</a></h3>
<p>This crate targets FLTK 1.4, while currently most distros distribute an older version of FLTK (1.3.5). You can try to install FLTK (C++) by building from source.</p>
<h3 id="build-fails-on-arch-linux-because-of-pango-or-cairo"><a class="header" href="#build-fails-on-arch-linux-because-of-pango-or-cairo">Build fails on Arch linux because of pango or cairo?</a></h3>
<p>Pango changed its include paths which caused build failures across many projects. There are 2 solutions:</p>
<ul>
<li>Use the no-pango feature. Downsides: loss of rtl and cjk language support.</li>
<li>Set the CFLAGS and CXXFLAGS to correct the global include paths.</li>
</ul>
<pre><code>export CFLAGS=&quot;-isystem /usr/include/harfbuzz -isystem /usr/include/cairo&quot;
export CXXFLAGS=&quot;-isystem /usr/include/harfbuzz -isystem /usr/include/cairo&quot;
</code></pre>
<h3 id="how-do-i-force-cmake-to-use-a-certain-c-compiler"><a class="header" href="#how-do-i-force-cmake-to-use-a-certain-c-compiler">How do I force CMake to use a certain C++ compiler?</a></h3>
<p>FLTK works with all 3 major compilers. If you would like to change the C++ compiler that's chosen by default by CMake, you can change the CXX environment variable before running the build:</p>
<pre><code>export CXX=/usr/bin/clang++
cargo run
</code></pre>
<p>CMake caches the C++ compiler variable after it's first run, so if the above failed because of a previous run, you would have to run <code>cargo clean</code> or you can manually delete the CMakeCache.txt file in the build directory.</p>
<h3 id="can-i-accelerate-the-build-speed"><a class="header" href="#can-i-accelerate-the-build-speed">Can I accelerate the build speed?</a></h3>
<p>You can use the &quot;use-ninja&quot; feature flag if you have ninja installed. </p>
<h3 id="can-i-cache-a-previous-build-of-the-fltk-library"><a class="header" href="#can-i-cache-a-previous-build-of-the-fltk-library">Can I cache a previous build of the FLTK library?</a></h3>
<p>You can use the fltk-bundled feature and use either the CFLTK_BUNDLE_DIR or CFLTK_BUNDLE_URL to point to the location of your cached cfltk and fltk libraries.</p>
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<h3 id="how-do-i-deploy-my-application"><a class="header" href="#how-do-i-deploy-my-application">How do I deploy my application?</a></h3>
<p>Rust, by default, statically links your application. FLTK is built also for static linking. That means that the resulting executable can be directly deployed without the need to deploy other files along with it. If you want to create a WIN32 application, Mac OS Bundle or Linux AppImage, please check the question just below!</p>
<h3 id="why-do-i-get-a-console-window-whenever-i-start-my-gui-app"><a class="header" href="#why-do-i-get-a-console-window-whenever-i-start-my-gui-app">Why do I get a console window whenever I start my GUI app?</a></h3>
<p>This is the default behavior of the toolchain, and is helpful for debugging purposes. It can be turned off easily by adding <code>#![windows_subsystem = &quot;windows&quot;]</code> at the beginning of your main.rs file if you're on windows. 
If you would like to keep the console window on debug builds, but not on release builds, you can use <code>#![cfg_attr(not(debug_assertions), windows_subsystem = &quot;windows&quot;)]</code> instead.</p>
<p>For Mac OS and Linux, this is done by a post-build process to create a Mac OS Bundle or Linux AppImage respectively.</p>
<p>See <a href="https://github.com/burtonageo/cargo-bundle">cargo-bundle</a> for an automated tool for creating Mac OS app bundles. </p>
<p>See <a href="https://docs.appimage.org/packaging-guide/overview.html#converting-existing-binary-packages">here</a> for directions on creating an AppImage for Linux.</p>
<h3 id="why-is-the-size-of-my-resulting-executable-larger-than-i-had-expected"><a class="header" href="#why-is-the-size-of-my-resulting-executable-larger-than-i-had-expected">Why is the size of my resulting executable larger than I had expected?</a></h3>
<p>FLTK is known for it's small applications. Make sure you're building in release, and make sure symbols are stripped using the strip command in Unix-like systems. On Windows it's unnecessary since symbols would end up in the pdb file (which shouldn't be deployed).</p>
<p>If you need an even smaller size, try using opt-level=&quot;z&quot;:</p>
<pre><code class="language-toml">[profile.release]
opt-level = &quot;z&quot;
lto = true
codegen-units = 1
panic = &quot;abort&quot;
</code></pre>
<p>Newer versions of cargo (&gt;1.46) support automatically stripping binaries in the post-build phase:</p>
<pre><code class="language-toml">cargo-features = [&quot;strip&quot;]

[profile.release]
strip = true
opt-level = &quot;z&quot;
lto = true
codegen-units = 1
panic = &quot;abort&quot;
</code></pre>
<p>Furthermore, you can build Rust's stdlib optimized for size (it comes optimized for speed by default). More info on that <a href="https://github.com/johnthagen/min-sized-rust">here</a></p>
<h3 id="can-i-cross-compile-my-application-to-a-mobile-platform-or-wasm"><a class="header" href="#can-i-cross-compile-my-application-to-a-mobile-platform-or-wasm">Can I cross-compile my application to a mobile platform or WASM?</a></h3>
<p>FLTK currently doesn't support WASM nor iOS. It has experimental support for Android (YMMV). It is focused on desktop applications.</p>
<h2 id="licensing"><a class="header" href="#licensing">Licensing</a></h2>
<h3 id="can-i-use-this-crate-in-a-commercial-application"><a class="header" href="#can-i-use-this-crate-in-a-commercial-application">Can I use this crate in a commercial application?</a></h3>
<p>Yes. This crate has an MIT license which requires acknowledgment. FLTK (the C++ library) is licensed under the LGPL license with an exception allowing static linking for commercial/closed-source use. You can find the full terms of both licenses here:</p>
<ul>
<li><a href="https://github.com/fltk/fltk/blob/master/COPYING">COPYING</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/blob/master/LICENSE">LICENSE</a></li>
</ul>
<h2 id="alignment"><a class="header" href="#alignment">Alignment</a></h2>
<h3 id="why-cant-i-align-input-or-output-text-to-the-right"><a class="header" href="#why-cant-i-align-input-or-output-text-to-the-right">Why can't I align input or output text to the right?</a></h3>
<p>FLTK has some known issues with text alignment.</p>
<h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<h3 id="do-you-plan-on-supporting-multithreading-or-asyncawait"><a class="header" href="#do-you-plan-on-supporting-multithreading-or-asyncawait">Do you plan on supporting multithreading or async/await?</a></h3>
<p>FLTK supports multithreaded and concurrent applications. See the examples dir and the <a href="https://github.com/fltk-rs/demos">fltk-rs demos repo</a> for examples on usage with threads, messages, async_std and tokio (web-todo examples).</p>
<h3 id="should-i-explicitly-call-applock-and-appunlock"><a class="header" href="#should-i-explicitly-call-applock-and-appunlock">Should I explicitly call app::lock() and app::unlock()?</a></h3>
<p>fltk-rs surrounds all mutating calls to widgets with a lock on the C++ wrapper side. Normally you wouldn't have to call app::lock() and app::unlock(). 
This depends however on the support of recursive mutexes in your system. 
If you notice haning in multithreaded applications, you might have to initialize threads (like xlib threads) by calling app::lock() once in your main thread. 
In that case, you can wrap widgets in an Arc<Mutex> or surround widget-mutating functions/methods with an app::lock and app::unlock. 
But that should rarely be required.</p>
<h2 id="windowing"><a class="header" href="#windowing">Windowing</a></h2>
<h3 id="why-does-fltk-exit-when-i-hit-the-escape-key"><a class="header" href="#why-does-fltk-exit-when-i-hit-the-escape-key">Why does FLTK exit when I hit the escape key?</a></h3>
<p>This is the default behavior in FLTK. You can easily override it by setting a callback for your main window:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    wind.set_callback(|_| {
        if fltk::app::event() == fltk::enums::Event::Close {
            app::quit(); // Which would close using the close button. You can also assign other keys to close the application
        }
    });
<span class="boring">}
</span></code></pre></pre>
<h2 id="panicscrashes"><a class="header" href="#panicscrashes">Panics/Crashes</a></h2>
<h3 id="my-app-panics-when-i-try-to-handle-events-how-can-i-fix-it"><a class="header" href="#my-app-panics-when-i-try-to-handle-events-how-can-i-fix-it">My app panics when I try to handle events, how can I fix it?</a></h3>
<p>This is due to a debug_assert which checks that the involved widget and the window are capable of handling events. Although most events would be handled correctly, some events require that the aforementioned conditions be met. Thus it is advisable to place your event handling code after the main drawing is done, i.e after calling your main window's show() method. Another point is that event handling and drawing should be done in the main thread. Panics accross FFI boundaries are undefined behavior, as such, the wrapper never throws. Furthermore, all panics which might arise in callbacks are caught on the Rust side using catch_unwind.</p>
<h2 id="memory-and-unsafety"><a class="header" href="#memory-and-unsafety">Memory and unsafety</a></h2>
<h3 id="how-memory-safe-is-fltk-rs"><a class="header" href="#how-memory-safe-is-fltk-rs">How memory-safe is fltk-rs?</a></h3>
<p>The callback mechanism consists of a closure as a void pointer with a shim which dereferences the void pointer into a function pointer and calls the function. This is technically undefined behavior, however most implementations permit it and it's the method used by most wrappers to handle callbacks across FFI boundaries. <a href="https://rust-lang.github.io/unsafe-code-guidelines/layout/function-pointers.html#representation">link</a></p>
<p>As stated before, panics accross FFI boundaries are undefined behavior, as such, the C++ wrapper never throws. Furthermore, all panics which might arise in callbacks are caught on the Rust side using catch_unwind.</p>
<p>FLTK manages it's own memory. Any widget is automatically owned by a parent which does the book-keeping as well and deletion, this is the enclosing widget implementing GroupExt such as windws etc. This is done in the C++ FLTK library itself. Any constructed widget calls the current() method which detects the enclosing group widget, and calls its add() method rending ownership to the group widget. Upon destruction of the group widget, all owned widgets are freed. Also all widgets are wrapped in a mutex for all mutating methods, and their lifetimes are tracked using an Fl_Widget_Tracker, That means widgets have interior mutability as if wrapped in an Arc&lt;Mutex<widget>&gt; and have a tracking pointer to detect deletion. Cloning a widget performs a memcpy of the underlying pointer and allows for interior mutability; it does not create a new widget.
Images are reference-counted. All mutating methods are wrapped in locks.
This locking might lead to some performance degradation as compared to the original FLTK library, it does allow for multithreaded applications, and is necessary in an FLTK (C++) application if it also required threading.</p>
<p>Overriding drawing methods will box data to be sent to the C++ library, so the data should optimally be limited to widgets or plain old data types to avoid unnecessary leaks if a custom drawn widget might be deleted during the lifetime of the program.</p>
<h3 id="can-i-get-memory-leaks-with-fltk-rs"><a class="header" href="#can-i-get-memory-leaks-with-fltk-rs">Can I get memory leaks with fltk-rs?</a></h3>
<p>Non-parented widgets that can no longer be accessed are a memory leak. Otherwise, as mentioned in the previous section all parented widgets lifetimes' are managed by the parent.
An example of a leaking widget:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let a = app::App::default();
    let mut win = window::Window::default();
    win.end();
    win.show();

    {
        button::Button::default(); // this leaks since it's not parented by the window, and has no handle in main
    }
}
</code></pre></pre>
<p>A more subtle cause of leaks, is removing a widget from a group, then the scope ends without it being added to another group or deleted:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let a = app::App::default();
    let mut win = window::Window::default();
    {
        button::Button::default(); // This doesn't leak since the parent is the window
    }
    win.end();
    win.show();

    {
        win.remove_by_index(0); // the button leaks here since it's removed and we no longer have access to it
    }
}
</code></pre></pre>
<h3 id="why-is-fltk-rs-using-so-much-unsafe-code"><a class="header" href="#why-is-fltk-rs-using-so-much-unsafe-code">Why is fltk-rs using so much unsafe code?</a></h3>
<p>Interfacing with C++ or C code can't be reasoned about by the Rust compiler, so the unsafe keyword is needed.</p>
<h3 id="is-fltk-rs-panicexception-safe"><a class="header" href="#is-fltk-rs-panicexception-safe">Is fltk-rs panic/exception-safe?</a></h3>
<p>FLTK (C++) doesn't throw exceptions, neither do the C wrapper (cfltk) nor the fltk-sys crate. The higher level fltk crate, which wraps fltk-sys, is not exception-safe since it uses asserts internally after various operations to ensure memory-safety. An example is a widget constructor which checks that the returned pointer (from the C++ side) is not null from allocation failure. It also asserts all widget reads/writes are happening on valid (not deleted) widgets.
Also any function sending a string across FFI is checked for interal null bytes. For such functions, the developer can perform a sanity check on passed strings to make sure they're valid UTF-8 strings, or check that a widget was not deleted prior to accessing a widget. That said, all functions passed as callbacks to be handled by the C++ side are exception-safe.</p>
<h3 id="are-there-any-environment-variables-which-can-affect-the-build-or-behavior"><a class="header" href="#are-there-any-environment-variables-which-can-affect-the-build-or-behavior">Are there any environment variables which can affect the build or behavior?</a></h3>
<ul>
<li><code>CFLTK_TOOLCHAIN=&lt;path&gt;</code> allows passing the path to a CMake file acting as a CMAKE_TOOLCHAIN_FILE, this allows passing extra info to cmake if needed.</li>
<li><code>CFLTK_WAYLAND_ONLY=&lt;1 or 0&gt;</code> allows building for wayland only without directly linking X11 libs nor relying on their headers for the build process. This only works with the <code>use-wayland</code> feature flag.</li>
<li><code>CFLTK_BUNDLE_DIR=&lt;path&gt;</code> allows passing a path of prebuilt cfltk and fltk static libs, useful for when a customized build of fltk is needed, or for targetting other arches when building with the <code>fltk-bundled</code> flag.</li>
<li><code>CFLTK_BUNDLE_URL=&lt;url&gt;</code> similar to above but allows passing a url which will directs the build script to download from the passed url.</li>
<li><code>FLTK_BACKEND=&lt;x11 or wayland&gt;</code> allows choosing the backend of your hybrid X11/wayland FLTK app. This only works for apps built with <code>use-wayland</code> feature flag. </li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Please refer to the <a href="https://github.com/fltk-rs/fltk-rs/blob/master/CONTRIBUTING.md">CONTRIBUTING</a> page for further information.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
