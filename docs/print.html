<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>fltk book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">fltk book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/fltk-rs/fltk-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="home"><a class="header" href="#home">Home</a></h1>
<p>Welcome to the <a href="https://github.com/fltk-rs/fltk-rs">fltk-rs</a> book!</p>
<p><a href="https://flatig.vip/fltk-book-zh">本書的中文翻譯</a></p>
<p>This is an introductory book targeting the <a href="https://crates.io/crates/fltk">fltk crate</a>. Other resources include:</p>
<ul>
<li><a href="https://docs.rs/fltk">Official Documentation</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs#tutorials">Videos</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/discussions">Discussions</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/tree/master/fltk/examples">Examples</a></li>
<li><a href="https://github.com/fltk-rs/demos">Demos</a></li>
<li><a href="https://github.com/tdryer/7guis-fltk-rs">7guis-fltk-rs</a></li>
<li><a href="https://github.com/wyhinton/FLTK-RS-Examples">FLTK-RS-Examples</a></li>
<li>Erco's FLTK cheat <a href="http://seriss.com/people/erco/fltk/">page</a>, which is an excellent FLTK C++ reference.</li>
</ul>
<p><a href="https://github.com/fltk/fltk">FLTK</a> is a cross-platform lightweight gui library.
The library itself is written in C++98, which is highly-portable. The fltk crate is written in Rust, and uses FFI to call into the FLTK wrapper, <a href="https://github.com/MoAlyousef/cfltk">cfltk</a>, which is written in C89 and C++11.</p>
<p>The library has a minimalist architecture, and would be familiar to developers used to Object-Oriented gui libraries. The wrapper itself follows the same model which simplifies the documentation, since method names are identical or similar to their C++ equivalents. This makes referring the FLTK C++ documentation quite simpler since the methods basically map to each other.</p>
<pre><code class="language-c++">#include &lt;FL/Fl_Window.H&gt;

int main() {
    auto wind = new Fl_Window(100, 100, 400, 300, "My Window");
    wind-&gt;end();
    wind-&gt;show();
}
</code></pre>
<p>maps to:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, window};

fn main() {
    let mut wind = window::Window::new(100, 100, 400, 300, "My Window");
    wind.end();
    wind.show();
}</code></pre></pre>
<p>Why choose FLTK?</p>
<ul>
<li>Lightweight. Small binary, around 1mb after stripping. <a href="https://szibele.com/memory-footprint-of-gui-toolkits/">Small memory footprint</a>.</li>
<li>Speed. Fast to install, fast to build, fast at startup and fast at runtime.</li>
<li>Single executable. No DLLs to deploy.</li>
<li>Supports old architectures.</li>
<li>FLTK's permissive license which allows static linking for closed-source applications.</li>
<li>Themeability (4 supported schemes: Base, GTK, Plastic and Gleam), and additional theming using <a href="https://crates.io/crates/fltk-theme">fltk-theme</a>.</li>
<li>Provides around 80 customizable widgets.</li>
<li>Has inbuilt image support.</li>
</ul>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Just add the following to your project's Cargo.toml file:</p>
<pre><code class="language-toml">[dependencies]
fltk = "^1.5"
</code></pre>
<p>To use the bundled libs (available for x64 windows (msvc &amp; gnu (msys2)), x64 linux &amp; macos):</p>
<pre><code class="language-toml">[dependencies]
fltk = { version = "^1.5", features = ["fltk-bundled"] }
</code></pre>
<p>The library is automatically built and statically linked to your binary.</p>
<p>To make our first Rust code sample work, we need to import the necessary fltk modules:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, window::Window};

fn main() {
    let mut wind = Window::new(100, 100, 400, 300, "My Window");
    wind.end();
    wind.show();
}</code></pre></pre>
<p>If you run the code sample, you might notice it does nothing. We actually need to run the event loop, this is equivalent to using <code>Fl::run()</code> in C++:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, prelude::*, window::Window};

fn main() {
    let a = app::App::default();
    let mut wind = Window::new(100, 100, 400, 300, "My Window");
    wind.end();
    wind.show();
    a.run().unwrap();
}</code></pre></pre>
<p>We instantiate the App struct, which initializes the runtime and styles, then at the end of main, we call the run() method.</p>
<h2 id="contributing-to-the-book"><a class="header" href="#contributing-to-the-book">Contributing to the book</a></h2>
<p>The book is generated using <a href="https://github.com/rust-lang/mdBook">mdbook</a> on the <a href="https://github.com/fltk-rs/fltk-book">fltk-book</a> repo.</p>
<p>As such, you would need to <code>cargo install mdbook</code>. More instructions can be found in fltk-book's README and in mdbook's <a href="https://rust-lang.github.io/mdBook/">user guide</a>.</p>
<p>You can also contribute to the Chinese translation <a href="https://github.com/Flatigers/fltk-book-zh">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<h2 id="build-dependencies"><a class="header" href="#build-dependencies">Build Dependencies</a></h2>
<p>Rust (version &gt; 1.55), CMake (version &gt; 3.11), Git and a C++11 compiler need to be installed and in your PATH for a crossplatform build from source. This crate also offers a bundled form of fltk on selected platforms, this can be enabled using the fltk-bundled feature flag (which requires curl and tar to download and unpack the bundled libraries). If you have ninja-build installed, you can enable it using the "use-ninja" feature. This should accelerate build times significantly.</p>
<ul>
<li>Windows:
<ul>
<li>MSVC: Windows SDK</li>
<li>Gnu: No dependencies</li>
</ul>
</li>
<li>MacOS: No dependencies.</li>
<li>Linux: X11 and OpenGL development headers need to be installed for development. The libraries themselves are available on linux distros with a graphical user interface.</li>
</ul>
<p>For Debian-based GUI distributions, that means running:</p>
<pre><code>sudo apt-get install libx11-dev libxext-dev libxft-dev libxinerama-dev libxcursor-dev libxrender-dev libxfixes-dev libpango1.0-dev libgl1-mesa-dev libglu1-mesa-dev
</code></pre>
<p>For RHEL-based GUI distributions, that means running:</p>
<pre><code>sudo yum groupinstall "X Software Development" &amp;&amp; yum install pango-devel libXinerama-devel libstdc++-static
</code></pre>
<p>For Arch-based GUI distributions, that means running:</p>
<pre><code>sudo pacman -S libx11 libxext libxft libxinerama libxcursor libxrender libxfixes pango cairo libgl mesa --needed
</code></pre>
<p>For Alpine linux:</p>
<pre><code>apk add pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
</code></pre>
<ul>
<li>Android: Android Studio, Android Sdk, Android Ndk.</li>
</ul>
<h2 id="runtime-dependencies"><a class="header" href="#runtime-dependencies">Runtime Dependencies</a></h2>
<ul>
<li>Windows: None</li>
<li>MacOS: None</li>
<li>Linux: You need X11 libraries, as well as pango and cairo for drawing (and OpenGL if you want to enable the enable-glwindow feature):</li>
</ul>
<pre><code>apt-get install -qq --no-install-recommends libx11-6 libxinerama1 libxft2 libxext6 libxcursor1 libxrender1 libxfixes3 libcairo2 libpango-1.0-0 libpangocairo-1.0-0 libpangoxft-1.0-0 libglib2.0-0 libfontconfig1 libglu1-mesa libgl1
</code></pre>
<p>Note that if you installed the build dependencies, it will also install the runtime dependencies automatically as well.</p>
<p>Also note that most graphical desktop environments already have these libs already installed. This list can be useful if you are testing your already built package in CI/docker (where there is not graphical user interface).</p>
<h2 id="detailed-setup"><a class="header" href="#detailed-setup">Detailed setup</a></h2>
<p>This section assumes you don't even have Rust installed, and is separated into different environments:</p>
<h3 id="windows-msvc-toolchain"><a class="header" href="#windows-msvc-toolchain">Windows (MSVC toolchain)</a></h3>
<ul>
<li>Go to the rust-lang get-started <a href="https://www.rust-lang.org/learn/get-started">section</a>.</li>
<li>Follow the link to <code>Visual Studio C++ Build tools</code> and download the MSVC compiler and Windows sdk.</li>
<li>Using the installer, install:</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/37966791/116013495-2dff8800-a639-11eb-8e4c-8c6228e00abc.png" alt="image" /></p>
<p>and make sure the following are checked:</p>
<p><img src="https://user-images.githubusercontent.com/37966791/116013520-48d1fc80-a639-11eb-934a-fac6609135b4.png" alt="image" /></p>
<ul>
<li>You can also check CMake in the previous list, or download CMake from <a href="https://cmake.org/download/">here</a>.</li>
<li>If you don't have <code>git</code>, make sure to get it from <a href="https://git-scm.com/downloads">here</a>.</li>
<li>From the rust-lang.org website, download the correct rustup installer for your architecture.</li>
<li>Once you're all set up, you can create a Rust project using <code>cargo new</code>, add <code>fltk</code> as a dependency in your Cargo.toml and build your application.</li>
</ul>
<h3 id="windows-gnu-toolchain"><a class="header" href="#windows-gnu-toolchain">Windows (gnu toolchain)</a></h3>
<p>If you don't already have msys2, you can get it from <a href="https://www.msys2.org/">here</a>.</p>
<ul>
<li>You can get the Rust toolchain via the pacman package manager, or via rustup as described previously. The installation process however would require specifying the use of the gnu toolchain (not choosing the default which would install the MSVC toolchain).
The toolchain should also reflect the architecture of your machine. For example, a 64bit machine should install the x86_64-pc-windows-gnu toolchain.
If you decide to get Rust via the package manager, make sure you're getting the mingw variant, and with the correct MINGW_PACKAGE_PREFIX (for 64bits, that env variable would equate to mingw-w64-x86_64).</li>
<li>Assuming you're installing everything via pacman, open the mingw shell (not the msys2 shell, it can be found bundled in the msys2 install directory, or via <code>source shell mingw64</code>) and run the following:</li>
</ul>
<pre><code>pacman -S curl tar git $MINGW_PACKAGE_PREFIX-rust $MINGW_PACKAGE_PREFIX-gcc $MINGW_PACKAGE_PREFIX-cmake $MINGW_PACKAGE_PREFIX-make --needed
</code></pre>
<p>You can replace $MINGW_PACKAGE_PREFIX-make with $MINGW_PACKAGE_PREFIX-ninja if you plan to use ninja via the use-ninja feature.</p>
<ul>
<li>Once you're all set up, you can create a Rust project using <code>cargo new</code>, add <code>fltk</code> as a dependency in your Cargo.toml and build your application.</li>
</ul>
<h3 id="macos"><a class="header" href="#macos">MacOS</a></h3>
<ul>
<li>To get the Xcode Command Line Tools (which have the C++ compiler), run:</li>
</ul>
<pre><code>xcode-select --install
</code></pre>
<p>Follow the instructions. Alternatively you can install clang or gcc from homebrew.</p>
<ul>
<li>To get CMake, you can get it from <a href="https://cmake.org/download/">here</a>.</li>
</ul>
<p>Or from homebrew as well.</p>
<pre><code>brew install cmake
</code></pre>
<ul>
<li>To get the Rust toolchain:</li>
</ul>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>And follow the default instructions.</p>
<ul>
<li>Once you're all set up, you can create a Rust project using <code>cargo new</code>, add <code>fltk</code> as a dependency in your Cargo.toml and build your application.</li>
</ul>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<ul>
<li>Use your package manager to get a C++ compiler, CMake, make, git.
Taking Debian/Ubuntu as an example:</li>
</ul>
<pre><code>sudo apt-get install g++ cmake git make
</code></pre>
<ul>
<li>To get the dev dependencies for FLTK, you can also use your package manager:
For Debian-based GUI distributions, that means running:</li>
</ul>
<pre><code>sudo apt-get install libx11-dev libxext-dev libxft-dev libxinerama-dev libxcursor-dev libxrender-dev libxfixes-dev libpango1.0-dev libgl1-mesa-dev libglu1-mesa-dev
</code></pre>
<p>For RHEL-based GUI distributions, that means running:</p>
<pre><code>sudo yum groupinstall "X Software Development" &amp;&amp; yum install pango-devel libXinerama-devel libstdc++-static
</code></pre>
<p>For Arch-based GUI distributions, that means running:</p>
<pre><code>sudo pacman -S libx11 libxext libxft libxinerama libxcursor libxrender libxfixes pango cairo libgl mesa --needed
</code></pre>
<p>For Alpine linux:</p>
<pre><code>apk add pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
</code></pre>
<ul>
<li>To get the Rust toolchain:</li>
</ul>
<pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>And follow the default instructions.</p>
<ul>
<li>Once you're all set up, you can create a Rust project using <code>cargo new</code>, add <code>fltk</code> as a dependency in your Cargo.toml and build your application.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-compiling"><a class="header" href="#cross-compiling">Cross-compiling</a></h1>
<h2 id="using-a-prebuilt-bundle"><a class="header" href="#using-a-prebuilt-bundle">Using a prebuilt bundle</a></h2>
<p>If the target you're compiling to, already has a prebuilt package:</p>
<ul>
<li>x86_64-pc-windows-gnu</li>
<li>x86_64-pc-windows-msvc</li>
<li>x86_64-apple-darwin</li>
<li>aarch64-apple-darwin</li>
<li>x86_64-unknown-linux-gnu</li>
<li>aarch64-unknown-linux-gnu</li>
</ul>
<p>Add the target via rustup, then invoke the build:</p>
<pre><code>rustup target add &lt;your target&gt; # replace with one of the targets above
cargo build --target=&lt;your target&gt; --features=fltk-bundled
</code></pre>
<p>For aarch64-unknonw-linux-gnu, you might have to specify the linker:</p>
<pre><code>CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc cargo build --target=aarch64-unknown-linux-gnu --features=fltk-bundled
</code></pre>
<p>You can specify the linker in a .cargo/config.toml file so you won't have to pass it to the build command:</p>
<pre><code class="language-toml"># .cargo/config.toml
[target.aarch64-unknown-linux-gnu]
linker = "aarch64-linux-gnu-gcc"
</code></pre>
<p>Then:</p>
<pre><code>cargo build --target=aarch64-unknown-linux-gnu --features=fltk-bundled
</code></pre>
<h2 id="using-cross"><a class="header" href="#using-cross">Using cross</a></h2>
<p>If you have Docker installed, you can try <a href="https://github.com/cross-rs/cross">cross</a>.</p>
<pre><code>cargo install cross
cross build --target=x86_64-pc-windows-gnu # replace with your target, the Docker daemon has to be running, no need to add via rustup
</code></pre>
<p>If your target requires external dependencies, like on Linux, you would have to create a custom docker image and use it for your cross-compilation via either:</p>
<p>1- a Cross.toml file + Dockerfile:</p>
<p>For example, for a project of the following structure:</p>
<pre><code>myapp
     |_src
     |    |_main.rs    
     |
     |_Cargo.toml
     |
     |_Cross.toml
     |
     |_arm64-dockerfile
</code></pre>
<p>The arm64-dockerfile (the name doesn't matter, just make sure Cross.toml points to the file) contents:</p>
<pre><code class="language-dockerfile">FROM ghcr.io/cross-rs/aarch64-unknown-linux-gnu:edge

ENV DEBIAN_FRONTEND=noninteractive

RUN dpkg --add-architecture arm64 &amp;&amp; \
    apt-get update &amp;&amp; \
    apt-get install --assume-yes --no-install-recommends \
    libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 \
    libxinerama-dev:arm64 libxcursor-dev:arm64 \
    libxrender-dev:arm64  libxfixes-dev:arm64  libgl1-mesa-dev:arm64 \
    libglu1-mesa-dev:arm64 libasound2-dev:arm64 libpango1.0-dev:arm64
</code></pre>
<p>Notice the architecture appended to the library package's name like: libx11-dev:arm64.</p>
<p>The Cross.toml contents:</p>
<pre><code class="language-toml">[target.aarch64-unknown-linux-gnu]
dockerfile = "./arm64-dockerfile"
</code></pre>
<p>2- Configuring Cargo.toml:</p>
<pre><code class="language-toml">[package.metadata.cross.target.aarch64-unknown-linux-gnu]
pre-build = [""" \
    dpkg --add-architecture arm64 &amp;&amp; \
    apt-get update &amp;&amp; \
    apt-get install --assume-yes --no-install-recommends \
    libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 \
    libxinerama-dev:arm64 libxcursor-dev:arm64 \
    libxrender-dev:arm64  libxfixes-dev:arm64  libgl1-mesa-dev:arm64 \
    libglu1-mesa-dev:arm64 libasound2-dev:arm64 libpango1.0-dev:arm64 \
    """]
</code></pre>
<p>Then run cross:</p>
<pre><code>cross build --target=aarch64-unknown-linux-gnu
</code></pre>
<p>(This might take a while for the first time)</p>
<h2 id="using-a-cross-compiling-cc-toolchain"><a class="header" href="#using-a-cross-compiling-cc-toolchain">Using a cross-compiling C/C++ toolchain</a></h2>
<p>The idea is that you need a C/C++ cross-compiler and a Rust target installed via <code>rustup target add</code> as mentioned in the previous scenario.</p>
<p>For Windows and MacOS, the system compiler would already support targetting the supported architectures. For example, on MacOS, if you can already build fltk apps using your system compiler, you can target a different architecture using (assuming you have an intel x86_64 mac):</p>
<pre><code>rustup target add aarch64-apple-darwin
cargo build --target=arch64-apple-darwin
</code></pre>
<h3 id="linux-to-64-bit-windows"><a class="header" href="#linux-to-64-bit-windows">Linux to 64-bit Windows</a></h3>
<p>Assuming you would like to cross-compile from Linux to 64-bit Windows, and are already able to build on your host machine:</p>
<ul>
<li>You'll need to add the Rust target using:</li>
</ul>
<pre><code>rustup target add x86_64-pc-windows-gnu # depending on the arch
</code></pre>
<ul>
<li>Install a C/C++ cross-compiler like the Mingw toolchain. On Debian-based distros, you can run:</li>
</ul>
<pre><code>apt-get install mingw-w64 # or gcc-mingw-w64-x86-64
</code></pre>
<p>On RHEL-based distros:</p>
<pre><code>dnf install mingw64-gcc
</code></pre>
<p>On Arch:</p>
<pre><code>pacman -S mingw-w64-gcc
</code></pre>
<p>On Alpine:</p>
<pre><code>apk add mingw-w64-gcc
</code></pre>
<ul>
<li>Add a <code>.cargo/config.toml</code> in your project root (or HOME dir if you want the setting to be global), and specify the cross-linker and the archiver:</li>
</ul>
<pre><code class="language-toml"># .cargo/config.toml
[target.x86_64-pc-windows-gnu]
linker = "x86_64-w64-mingw32-gcc"
ar = "x86_64-w64-mingw32-gcc-ar"
</code></pre>
<ul>
<li>Run the build:</li>
</ul>
<pre><code>cargo build --target=x86_64-pc-windows-gnu
</code></pre>
<h3 id="x64-linux-gnu-to-aarch64-linux-gnu"><a class="header" href="#x64-linux-gnu-to-aarch64-linux-gnu">x64 linux-gnu to aarch64 linux-gnu</a></h3>
<p>Another example is building from x86_64 debian-based distro to arm64 debian-based distro:
Assuming you already have cmake already installed.</p>
<ul>
<li>You'll need to add the Rust target using:</li>
</ul>
<pre><code>rustup target add aarch64-unknown-linux-gnu
</code></pre>
<ul>
<li>Install a C/C++ cross-compiler like the Mingw toolchain. On Debian-based distros, you can run:</li>
</ul>
<pre><code>apt-get install g++-aarch64-linux-gnu
</code></pre>
<ul>
<li>Add the required architecture to your system:</li>
</ul>
<pre><code>sudo dpkg --add-architecture arm64
</code></pre>
<ul>
<li>You might need to add the following mirrors to /etc/apt/sources.list:</li>
</ul>
<pre><code>sudo sed -i "s/deb http/deb [arch=amd64] http/" /etc/apt/sources.list
echo "deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s) main multiverse universe" | sudo tee -a /etc/apt/sources.list
echo "deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-security main multiverse universe" | sudo tee -a /etc/apt/sources.list
echo "deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-backports main multiverse universe" | sudo tee -a /etc/apt/sources.list
echo "deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-updates main multiverse universe" | sudo tee -a /etc/apt/sources.list
</code></pre>
<p>The first command changes the current mirrors to reflect your current amd64 system. The others add the arm64 ports to your /etc/apt/sources.list file.</p>
<ul>
<li>Update your package manager's database:</li>
</ul>
<pre><code>sudo apt-get update
</code></pre>
<ul>
<li>Install the required dependencies for your target architecture:</li>
</ul>
<pre><code>sudo apt-get install libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 libxinerama-dev:arm64 libxcursor-dev:arm64 libxrender-dev:arm64 libxfixes-dev:arm64 libpango1.0-dev:arm64 libgl1-mesa-dev:arm64 libglu1-mesa-dev:arm64 libasound2-dev:arm64
</code></pre>
<p>Notice the <code>:arm64</code> suffix in the packages' name.</p>
<ul>
<li>Run the build:</li>
</ul>
<pre><code>CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc cargo build --target=aarch64-unknown-linux-gnu
</code></pre>
<p>You can specify the linker in a .cargo/config.toml file so you won't have to pass it to the build command:</p>
<pre><code class="language-toml"># .cargo/config.toml
[target.aarch64-unknown-linux-gnu]
linker = "aarch64-linux-gnu-gcc"
</code></pre>
<p>Then:</p>
<pre><code>cargo build --target=aarch64-unknown-linux-gnu
</code></pre>
<h2 id="using-docker"><a class="header" href="#using-docker">Using docker</a></h2>
<p>Using a docker image of the target platform directly can save you from the hassle of cross-compiling to a different linux target using cross.
You'll need a Dockerfile which pulls the target you want and install the Rust and C++ toolchains and the required dependencies.
For example, building for alpine linux:</p>
<pre><code class="language-dockerfile">FROM alpine:latest AS alpine_build
RUN apk add rust cargo git cmake make g++ pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev
COPY . .
RUN cargo build --release

FROM scratch AS export-stage
COPY --from=alpine_build target/release/&lt;your binary name&gt; .
</code></pre>
<p>And run using:</p>
<pre><code>DOCKER_BUILDKIT=1 docker build --file Dockerfile --output out .
</code></pre>
<p>Your binary will be in the <code>./out</code> directory.</p>
<p>Note on alpine, if you install Rust via rustup, you might have to point the musl-gcc and musl-g++ to the appropriate toolchain in your dockerfile (before running <code>cargo build</code>):</p>
<pre><code class="language-dockerfile">RUN ln -s /usr/bin/x86_64-alpine-linux-musl-gcc /usr/bin/musl-gcc
RUN ln -s /usr/bin/x86_64-alpine-linux-musl-g++ /usr/bin/musl-g++
</code></pre>
<p>You would also need to add "-C target-feature=-crt-static" to RUSTFLAGS due to this rust toolchain issue:
https://github.com/rust-lang/rust/issues/61328</p>
<p>i.e.</p>
<pre><code class="language-dockerfile">FROM alpine:latest AS alpine_build
ENV RUSTUP_HOME="/usr/local/rustup" CARGO_HOME="/usr/local/cargo" PATH="/usr/local/cargo/bin:$PATH" RUSTFLAGS="-C target-feature=-crt-static"
RUN apk add git curl cmake make g++ pango-dev fontconfig-dev libxinerama-dev libxfixes-dev libxcursor-dev

RUN ln -s /usr/bin/x86_64-alpine-linux-musl-gcc /usr/bin/musl-gcc
RUN ln -s /usr/bin/x86_64-alpine-linux-musl-g++ /usr/bin/musl-g++

RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --profile minimal --default-toolchain stable-x86_64-unknown-linux-musl

COPY . .
RUN cargo build --release

FROM scratch AS export-stage
COPY --from=alpine_build target/release/&lt;your binary name&gt; .
</code></pre>
<p>Another example to compile from amd64 linux-gnu to arm64 linux-gnu:</p>
<pre><code class="language-dockerfile">FROM ubuntu:bionic AS ubuntu_build

ENV DEBIAN_FRONTEND=noninteractive

RUN apt-get update -qq
RUN	apt-get install -y --no-install-recommends lsb-release g++-aarch64-linux-gnu g++ cmake curl tar git make
RUN apt-get install -y ca-certificates &amp;&amp; update-ca-certificates --fresh &amp;&amp; export SSL_CERT_DIR=/etc/ssl/certs
RUN	dpkg --add-architecture arm64 
RUN sed -i "s/deb http/deb [arch=amd64] http/" /etc/apt/sources.list
RUN echo "deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s) main multiverse universe" | tee -a /etc/apt/sources.list 
RUN echo "deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-security main multiverse universe" | tee -a /etc/apt/sources.list 
RUN echo "deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-backports main multiverse universe" | tee -a /etc/apt/sources.list 
RUN echo "deb [arch=arm64] http://ports.ubuntu.com/ $(lsb_release -c -s)-updates main multiverse universe" | tee -a /etc/apt/sources.list 
RUN	apt-get update -qq &amp;&amp; apt-get install -y --no-install-recommends -o APT::Immediate-Configure=0 libx11-dev:arm64 libxext-dev:arm64 libxft-dev:arm64 libxinerama-dev:arm64 libxcursor-dev:arm64 libxrender-dev:arm64 libxfixes-dev:arm64 libpango1.0-dev:arm64 libgl1-mesa-dev:arm64 libglu1-mesa-dev:arm64 libasound2-dev:arm64
RUN curl https://sh.rustup.rs -sSf | sh -s -- --default-toolchain stable --profile minimal -y

ENV PATH="/root/.cargo/bin:$PATH" \
	CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ \
	CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc \
    CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc \
    CXX_aarch64_unknown_linux_gnu=aarch64-linux-gnu-g++ \
    PKG_CONFIG_PATH="/usr/lib/aarch64-linux-gnu/pkgconfig/:${PKG_CONFIG_PATH}"

RUN rustup target add aarch64-unknown-linux-gnu

COPY . .

RUN  cargo build --release --target=aarch64-unknown-linux-gnu

FROM scratch AS export-stage
COPY --from=ubuntu_build target/aarch64-unknown-linux-gnu/release/&lt;your binary name&gt; .
</code></pre>
<h2 id="using-a-cmake-toolchain-file"><a class="header" href="#using-a-cmake-toolchain-file">Using a CMake toolchain file</a></h2>
<p>The path to the file can be passed to CFLTK_TOOLCHAIN env variable:</p>
<pre><code>CFLTK_TOOLCHAIN=$(pwd)/toolchain.cmake cargo build --target=&lt;target architecture&gt;
</code></pre>
<p>In newer versions of CMake (above 3.20), you can directly set the CMAKE_TOOLCHAIN_FILE environment variable.</p>
<p>The contents of the CMake toolchain file usually set the CMAKE_SYSTEM_NAME as well as the cross-compilers. Another thing which needs to be set on Linux/BSD is the PKG_CONFIG_EXECUTABLE and PKG_CONFIG_PATH.
A sample toolchain file:</p>
<pre><code class="language-cmake">set(CMAKE_SYSTEM_NAME Linux)
set(CMAKE_SYSTEM_PROCESSOR aarch64)

set(triplet aarch64-linux-gnu)
set(CMAKE_C_COMPILER /usr/bin/${triplet}-gcc)
set(CMAKE_CXX_COMPILER /usr/bin/${triplet}-g++)
set(ENV{PKG_CONFIG_EXECUTABLE} /usr/bin/${triplet}-pkg-config)
set(ENV{PKG_CONFIG_PATH} "$ENV{PKG_CONFIG_PATH}:/usr/lib/${triplet}/pkgconfig")

set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
</code></pre>
<p>Note the CMAKE_SYSTEM_PROCESSOR is usually the value of <code>uname -m</code> on the target platform, other possible values can be found <a href="https://stackoverflow.com/a/70498851/9698906">here</a>. We set the triplet variable in this example to aarch64-linux-gnu, which is the prefix used for the gcc/g++ compilers, as well as the cross-compiling aware pkg-config. This triplet is also equivalent to the Rust triplet aarch64-unknown-linux-gnu. The PKG_CONFIG_PATH is set to the directories containing the .pc files for our target, since these are required for the cairo and pango dependencies on Linux/BSD.
The last 4 options just tell CMake to not mix the include/library paths of both host/target.</p>
<p>Another toolchain file targetting windows (using the mingw toolchain):</p>
<pre><code class="language-cmake">set(CMAKE_SYSTEM_NAME Windows)
set(CMAKE_SYSTEM_PROCESSOR AMD64)

set(triplet x86_64-w64-mingw32)
set(CMAKE_C_COMPILER /usr/bin/${triplet}-gcc)
set(CMAKE_CXX_COMPILER /usr/bin/${triplet}-g++)

set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
</code></pre>
<h2 id="using-cargo-xwin"><a class="header" href="#using-cargo-xwin">Using cargo xwin</a></h2>
<p>If you need to target windows and the msvc compiler/abi, you can install <a href="https://github.com/rust-cross/cargo-xwin">cargo-xwin</a>:</p>
<pre><code>cargo install cargo-xwin
</code></pre>
<p>And build your project using:</p>
<pre><code>cargo xwin build --release --target x86_64-pc-windows-msvc
</code></pre>
<h2 id="using-the-fltk-config-feature"><a class="header" href="#using-the-fltk-config-feature">Using the fltk-config feature:</a></h2>
<p>FLTK provides a script called <code>fltk-config</code> which acts like pkg-config. It tracks the installed FLTK lib paths and the necessary cflags and ldflags. Since fltk-rs requires FLTK 1.4, and most distros don't provide it at the time of writing this, you would have to build FLTK from source for the target you require. However, once distros start distributing FLTK 1.4, it should as simple as (targetting arm64 gnu linux):</p>
<pre><code>dpkg --add-architecture arm64
apt-get install libfltk1.4-dev:arm64

cargo build --target=aarch64-unknown-linux-gnu --features=fltk-config
</code></pre>
<p>If you need to build FLTK for a different architecture, you would need to use a CMake toolchain file (using the one from before):</p>
<pre><code>git clone https://github.com/fltk/fltk --depth=1
cd fltk
cmake -B bin -G Ninja -DFLTK_BUILD_TEST=OFF -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=/full/path/to/toolchain/file.cmake
cmake --build bin
cmake --instal bin # might need sudo in a hosted env
# then for your proj
cargo build --target=aarch64-unknown-linux-gnu --features=fltk-config
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fluid"><a class="header" href="#fluid">Fluid</a></h1>
<p>FLTK offers a GUI WYSIWYG rapid application development tool called FLUID which allows creating GUI applications.
Currently there is a video tutorial on youtube on using it with Rust:
<a href="https://www.youtube.com/watch?v=k_P0wG3-dNk">Use FLUID (RAD tool) with Rust</a></p>
<p>The fl2rust crate translates the Fluid generated .fl files into Rust code to be compiled into your app.
For more information, you can check the project's <a href="https://github.com/MoAlyousef/fl2rust">repo</a>.</p>
<p>You can get FLUID via fltk-fluid and fl2rust crates using cargo install:</p>
<pre><code>cargo install fltk-fluid
cargo install fl2rust
</code></pre>
<p>And run using:</p>
<pre><code>fluid &amp;
</code></pre>
<p>Another option to get Fluid is to download it via your system's package manager, it comes as a separate package or part of the fltk package.</p>
<p>Currently, fl2rust, doesn't check the generated Rust code for correctness. It's also limited to constructor methods.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>To start, you can create a new Rust project using <code>cargo new app</code>.
fl2rust is added as a build-dependency to your project:</p>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
fltk = "1"

[build-dependencies]
fl2rust = "0.4"
</code></pre>
<p>Then it can be used in the build.rs file (which is run pre-build) to generate Rust code:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// build.rs
fn main() {
    use std::path::PathBuf;
    use std::env;
    println!("cargo:rerun-if-changed=src/myuifile.fl");
    let g = fl2rust::Generator::default();
    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap());
    g.in_out("src/myuifile.fl", out_path.join("myuifile.rs").to_str().unwrap()).expect("Failed to generate rust from fl file!");
}</code></pre></pre>
<p>We'll be naming our fluid file myuifile.fl. We tell cargo to rerun if that file is changed. We'll create the file in our source directory, but you can put it in its own directory if you wish. We tell the generator to take the fluid file and generate a myuifile.rs. This file is generated in the OUT_DIR, so you won't be seeing it in your src directory.
However to include it, you need to create a Rust source file, it can be the same name as our outputted file, and put it in the src directory:</p>
<pre><code>touch src/myuifile.rs
</code></pre>
<p>We'll have to import the contents from the auto-generated file using the include! macro:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/myuifile.rs
#![allow(unused_variables)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(clippy::needless_update)]

include!(concat!(env!("OUT_DIR"), "/myuifile.rs"));
<span class="boring">}</span></code></pre></pre>
<p>Then we'll be able to use the contents in main.rs:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// src/main.rs
use fltk::{prelude::*, *};
mod myuifile;

fn main() {
    let app = app::App::default();
    app.run().unwrap();
}</code></pre></pre>
<p>Now comes the gui part. Open fluid:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fltk-fluid &amp; #or just fluid if installed from a package manager
<span class="boring">}</span></code></pre></pre>
<p>The ampersand tells our shell to open it as a detached process, so we can still use our shell to compile our code.</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146925955-ac778726-1398-4ea2-8e46-a2f8fff89804.png" alt="image" /></p>
<p>We're greeted with an empty window along with a menu bar. Our first step here is to create a Class:
<img src="https://user-images.githubusercontent.com/37966791/146926284-cd9f21ce-b4b1-4009-9766-32876a08de98.png" alt="image" /></p>
<p>This will popup a dialog, we can leave the name as it is (UserInterface) by clicking Ok. Now you'll see our class listed:
<img src="https://user-images.githubusercontent.com/37966791/146926505-545f26c1-ac7d-4f10-94a9-2d0c16875d4e.png" alt="image" />
(We've expanded the window)</p>
<p>Next, press new again and we'll add a constructor function for our class:
<img src="https://user-images.githubusercontent.com/37966791/146926749-9199bd23-0346-4286-993f-bfb7588ae420.png" alt="image" />
We'll also accept the default name which is <code>make_window()</code>.</p>
<p>Next we'll add a window:
<img src="https://user-images.githubusercontent.com/37966791/146926970-769ad7a1-9d03-457a-91f7-d6a18e2ba3b0.png" alt="image" /></p>
<p>A new window pops up, we can enlarge it a bit by dragging the border:
<img src="https://user-images.githubusercontent.com/37966791/146927099-ff014e0d-8ea0-4f90-a500-882eb7b49bb2.png" alt="image" /></p>
<p>Double clicking the window pops up a dialog where we can change the window's gui properties (under the GUI tab), style (under the Style tab) and class properties (under the C++ tab).
<img src="https://user-images.githubusercontent.com/37966791/146927520-c2ee18b1-0d17-43cd-93eb-edbf725ddf6c.png" alt="image" /></p>
<p>We'll give the window a label <code>My Window</code> in the Gui tab, we'll change the color to white in the Style tab:
<img src="https://user-images.githubusercontent.com/37966791/146932899-6a4419ae-9c91-4b48-a363-d87c85b01778.png" alt="image" /></p>
<p>And under the C++ tab, we'll give it the variable name <code>my_win</code>:
<img src="https://user-images.githubusercontent.com/37966791/146932794-7e1a2819-842d-45c7-88c8-be9fb728e805.png" alt="image" /></p>
<p>Our window will now be accessible via <code>myuifile::UserInterface::my_win</code>.</p>
<p>We'll add a button by left clicking the window and adding a Button:
<img src="https://user-images.githubusercontent.com/37966791/146928089-ad0454de-252e-4e81-9079-db0ef5c67c8f.png" alt="image" /></p>
<p>This will open the same dialog as before but for the button. Under C++, we'll give it the variable name <code>btn</code>. Under style we'll change the color and label color. Then under Gui we'll give it the label "click me":
<img src="https://user-images.githubusercontent.com/37966791/146928419-a1a96e03-5b90-4aaa-8f70-9b17f76f9b9f.png" alt="image" /></p>
<p>We'll drag the border to resize and drag the button to any position we want. Fluid has a layout menu where we can modify a number of widgets (if we had multiple buttons for example) to have the same layout/size ...etc:
<img src="https://user-images.githubusercontent.com/37966791/146928654-43838e2a-aba8-4a24-8d70-1e25e1717c58.png" alt="image" /></p>
<p>We'll now save the file using <code>File/Save As...</code> as myuifile.fl in the src directory.</p>
<p>We can now run <code>cargo run</code> to check our build succeeds, but we still haven't call the <code>make_window()</code> method, so we won't see anything yet.
Now you can modify src/main.rs to show the window and add a callback to our button:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};
mod myuifile;

fn main() {
    let app = app::App::default();
    let mut ui = myuifile::UserInterface::make_window();
    let mut win = ui.my_win.clone();
    ui.btn.set_callback(move |b| {
        b.set_label("clicked");
        win.set_label("Button clicked");
        println!("Works!");
    });
    app.run().unwrap();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-app-struct"><a class="header" href="#the-app-struct">The App struct</a></h1>
<p>The crate offers an App struct in the app module. Initializing the App struct initializes all the internal styles, fonts and supported image types. It also initializes the multithreaded environment in which the app will run.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::*;

fn main() {
    let app = app::App::default();
    app.run().unwrap();
}</code></pre></pre>
<p>The run methods runs the event loop of the gui application.
To have fine grained control of events, you can use the wait() method.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::*;

fn main() {
    let app = app::App::default();
    while app.wait() {
        // handle events
    }
}</code></pre></pre>
<p>Furthermore, the App struct allows you to set the global scheme of your application using the with_scheme() initializer:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::*;

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);
    app.run().unwrap();
}</code></pre></pre>
<p>This will give your application a Gtk app appearance. There are other built-in schemes: Basic, Plastic and Gleam.</p>
<p>The App struct is also responsible for loading system fonts at the start of the application using the load_system_fonts() method.</p>
<p>A typical fltk-rs application will construct the App struct prior to creating any widgets and showing the main window.</p>
<p>Any logic added after calling the run() method, will be executed after the event loop is terminated (typically by closing the all windows of your application, or by calling the quit() method). That logic could include respawning the app if needed.</p>
<p>In addition to the App struct, the app module itself contains structs and free functions pertaining to the global state of your app. These include visuals like setting background and foreground colors and default fontface and size, screen functions, clipboard functions, global handlers, app events, channels (Sender and Receiver) and timeouts.</p>
<p>Some of these will be discussed elsewhere in the book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="windows"><a class="header" href="#windows">Windows</a></h1>
<p>FLTK calls the native window on each platform it supports, then basically does its own drawing. This means it calls an HWND on windows, NSWindow on MacOS and an XWindow on X11 systems (linux, BSD).</p>
<p>The windows themselves have the same interface as the other widgets provided by FLTK, the WidgetExt trait, which will be discussed in the next page.</p>
<p>Lets use what we've seen so far to create a window.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, "My Window");
    my_window.end();
    my_window.show();
    app.run().unwrap();
}</code></pre></pre>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/244393458-7add4afc-11ec-47dc-b62e-68488ada132f.PNG" alt="img1" /></p>
</div>
<p>The <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.WidgetBase.html#tymethod.new">new()</a> call takes 5 parameters:</p>
<ul>
<li><code>x</code> which is the horizontal distance from the left of the screen.</li>
<li><code>y</code> which is the vertical distance from the top of the screen.</li>
<li><code>width</code> which is the window's width.</li>
<li><code>height</code> which is the window's height.</li>
<li><code>title</code> which is the window's title.</li>
</ul>
<p>Next notice the call to <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.GroupExt.html#tymethod.end">end()</a>. Windows, among other types of widgets, implement the GroupExt trait. These widgets will own/parent any widget created between the call <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.GroupExt.html#tymethod.begin">begin()</a> (which is implicit here with the creation of the window) and the call end().
The next call <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.WidgetExt.html#tymethod.show">show()</a> basically raises the window so it appears on the display.</p>
<hr />
<h2 id="embedded-windows"><a class="header" href="#embedded-windows">Embedded windows</a></h2>
<p>Windows can be embedded inside other windows:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};
use crate::enums::Color;

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, "My Window");
    let mut my_window2 = window::Window::new(10, 10, 380, 280, None);
    my_window2.set_color(Color::Black);
    my_window2.end();
    my_window.end();
    my_window.show();
    app.run().unwrap();
}</code></pre></pre>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/244393452-8b8f11ef-036a-4be6-8d6f-b49418322f3c.PNG" alt="embed" /></p>
</div>
<p>Here, the 2nd window, my_window2, is embedded inside the 1st window, my_window. We've set its color to black for visibility. Note that its parent is the first window. If the 2nd window is created outside the parent, it will essentially create 2 separate windows, requiring a call to show() to display them:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, "My Window");
    my_window.end();
    my_window.show();
    let mut my_window2 = window::Window::new(10, 10, 380, 280, None);
    my_window2.end();
    my_window2.show();
    app.run().unwrap();
}</code></pre></pre>
<hr />
<h2 id="borders"><a class="header" href="#borders">Borders</a></h2>
<p>Windows can also be borderless using the my_window.set_border(false) method.</p>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/37966791/100937639-565cdd80-3504-11eb-8cf6-e135243c38b0.png" alt="image" /></p>
</div>
<p>The <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.WindowExt.html#tymethod.set_border">set_border(bool)</a> method is part of the WindowExt trait, implemented by all window types in FLTK, in addition to the WidgetExt and GroupExt traits.
The list of traits can be found in the prelude module of the crate:</p>
<p><a href="https://docs.rs/fltk/*/fltk/prelude/index.html">docs</a></p>
<hr />
<h2 id="fullscreen"><a class="header" href="#fullscreen">Fullscreen</a></h2>
<p>If you want to use fltk-rs for immersive applications, with full use of the screen, you can develop your applications by adding the <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.WindowExt.html#tymethod.fullscreen">fullscreen(bool)</a> method to the main window, setting it to true.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, "My Window");
    my_window.fullscreen(true);
    my_window.end();
    my_window.show();
    app.run().unwrap();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glutwindow"><a class="header" href="#glutwindow">GlutWindow</a></h1>
<p>The <code>GlutWindow</code> struct represents a OpenGL Glut window widget in the fltk-rs crate. Below you can look about depencendies and all the methods associated with this widget.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>To use GlutWindow you need to have Cmake and Git in your computer.</p>
<ol>
<li>
<p>Install CMake and Git: Make sure that CMake and Git are installed on your system and added to your system's PATH environment variable. You can download <a href="https://cmake.org/download/">CMake</a> from the official website and Git from the <a href="https://git-scm.com/downloads">Git</a> website.</p>
</li>
<li>
<p>Verify PATH configuration: After installing CMake and Git, check if their executables can be accessed from the command line. Open a terminal or command prompt and type <code>cmake --version</code> and <code>git --version</code> to verify that they are recognized.</p>
</li>
<li>
<p>Specify library paths: If the build process still can't find the <code>fltk_gl</code> library, you may need to specify additional library paths using the <code>-L</code> flag. Identify the location of the <code>fltk_gl</code> library on your system and add the appropriate flag to the build command. For example:</p>
</li>
</ol>
<pre><code class="language-bash">cargo build -L /path/to/fltk_gl/library
</code></pre>
<p>Replace <code>/path/to/fltk_gl/library</code> with the actual path to the <code>fltk_gl</code> library.</p>
<ol start="4">
<li>Ensure correct dependencies: Double-check that you have the correct dependencies specified in your project's <code>Cargo.toml</code> file. Make sure you have the <code>fltk</code> and <code>fltk-sys</code> dependencies included with their appropriate versions. Here's an example of how it should look:</li>
</ol>
<pre><code class="language-toml">[dependencies]
fltk = { version = "1.5.2", features = ["enable-glwindow"] }
</code></pre>
<ol start="5">
<li>Clean and rebuild: If the above steps do not resolve the issue, you can try cleaning the build artifacts and rebuilding the project. Use the following command to clean the project:</li>
</ol>
<pre><code class="language-bash">cargo clean
</code></pre>
<p>After cleaning, rebuild the project with:</p>
<pre><code class="language-bash">cargo build
</code></pre>
<p>By following these steps, you should be able to successfully build your project.</p>
<hr />
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<ul>
<li><code>default()</code>: Creates a default-initialized glut window.</li>
<li><code>get_proc_address(&amp;self, s: &amp;str)</code>: Gets an OpenGL function address.</li>
<li><code>flush(&amp;mut self)</code>: Forces the window to be drawn and calls the <code>draw()</code> method.</li>
<li><code>valid(&amp;self)</code>: Returns whether the OpenGL context is still valid.</li>
<li><code>set_valid(&amp;mut self, v: bool)</code>: Marks the OpenGL context as still valid.</li>
<li><code>context_valid(&amp;self)</code>: Returns whether the context is valid upon creation.</li>
<li><code>set_context_valid(&amp;mut self, v: bool)</code>: Marks the context as valid upon creation.</li>
<li><code>context(&amp;self)</code>: Returns the GlContext.</li>
<li><code>set_context(&amp;mut self, ctx: GlContext, destroy_flag: bool)</code>: Sets the GlContext.</li>
<li><code>swap_buffers(&amp;mut self)</code>: Swaps the back and front buffers.</li>
<li><code>ortho(&amp;mut self)</code>: Sets the projection so 0,0 is in the lower left of the window and each pixel is 1 unit wide/tall.</li>
<li><code>can_do_overlay(&amp;self)</code>: Returns whether the GlutWindow can do overlay.</li>
<li><code>redraw_overlay(&amp;mut self)</code>: Redraws the overlay.</li>
<li><code>hide_overlay(&amp;mut self)</code>: Hides the overlay.</li>
<li><code>make_overlay_current(&amp;mut self)</code>: Makes the overlay current.</li>
<li><code>pixels_per_unit(&amp;self)</code>: Returns the pixels per unit/point.</li>
<li><code>pixel_w(&amp;self)</code>: Gets the window's width in pixels.</li>
<li><code>pixel_h(&amp;self)</code>: Gets the window's height in pixels.</li>
<li><code>mode(&amp;self)</code>: Gets the Mode of the GlutWindow.</li>
<li><code>set_mode(&amp;mut self, mode: Mode)</code>: Sets the Mode of the GlutWindow.</li>
</ul>
<p>For more detailed information of GlWindow, please refer to the official documentation <a href="https://docs.rs/fltk/latest/fltk/window/struct.GlutWindow.html">here</a>.</p>
<hr />
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="opengl-triangle"><a class="header" href="#opengl-triangle">OpenGL Triangle</a></h3>
<p>The dependencies section in  your project's Cargo.toml file should be:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[dependencies]
fltk = { version = "^1.5", features = ["enable-glwindow"] }
glow = "0.16.0"
<span class="boring">}</span></code></pre></pre>
<p>main.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};
use glow::*;

fn main() {
    let app = app::App::default();
    let mut win = window::GlWindow::default().with_size(800, 600);
    win.make_resizable(true);
    win.set_mode(enums::Mode::Opengl3);
    win.end();
    win.show();

    unsafe {
        let gl = glow::Context::from_loader_function(|s| win.get_proc_address(s) as *const _);

        let vertex_array = gl
            .create_vertex_array()
            .expect("Cannot create vertex array");
        gl.bind_vertex_array(Some(vertex_array));

        let program = gl.create_program().expect("Cannot create program");

        let (vertex_shader_source, fragment_shader_source) = (
            r#"const vec2 verts[3] = vec2[3](
                vec2(0.5f, 1.0f),
                vec2(0.0f, 0.0f),
                vec2(1.0f, 0.0f)
            );
            out vec2 vert;
            void main() {
                vert = verts[gl_VertexID];
                gl_Position = vec4(vert - 0.5, 0.0, 1.0);
            }"#,
            r#"precision mediump float;
            in vec2 vert;
            out vec4 color;
            void main() {
                color = vec4(vert, 0.5, 1.0);
            }"#,
        );

        let shader_sources = [
            (glow::VERTEX_SHADER, vertex_shader_source),
            (glow::FRAGMENT_SHADER, fragment_shader_source),
        ];

        let mut shaders = Vec::with_capacity(shader_sources.len());

        for (shader_type, shader_source) in shader_sources.iter() {
            let shader = gl
                .create_shader(*shader_type)
                .expect("Cannot create shader");
            gl.shader_source(shader, &amp;format!("#version 410\n{}", shader_source));
            gl.compile_shader(shader);
            if !gl.get_shader_compile_status(shader) {
                panic!("{}", gl.get_shader_info_log(shader));
            }
            gl.attach_shader(program, shader);
            shaders.push(shader);
        }

        gl.link_program(program);
        if !gl.get_program_link_status(program) {
            panic!("{}", gl.get_program_info_log(program));
        }

        for shader in shaders {
            gl.detach_shader(program, shader);
            gl.delete_shader(shader);
        }

        gl.use_program(Some(program));
        gl.clear_color(0.1, 0.2, 0.3, 1.0);

        win.draw(move |w| {
            gl.clear(glow::COLOR_BUFFER_BIT);
            gl.draw_arrays(glow::TRIANGLES, 0, 3);
            w.swap_buffers();
        });
    }

    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://raw.githubusercontent.com/fltk-rs/demos/master/glow/ex.jpg" alt="gl-img" /></p>
<h3 id="rotate"><a class="header" href="#rotate">Rotate</a></h3>
<p>This program uses GlWindow to create an OpenGL window where a triangle is drawn and can be rotated by dragging it with the mouse. You can look the code of this example <a href="https://github.com/fltk-rs/demos/tree/master/opengl">here</a>.</p>
<div align="center">
<p><img src="https://raw.githubusercontent.com/fltk-rs/demos/master/opengl/ex.jpg" alt="rotate" /></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>FLTK offers around 80 widgets. These widgets all implement the basic set of traits WidgetBase and WidgetExt. We've already come across our first widget, the Window widget.
As we've seen with the Window widget, widgets can also implement other traits depending on their functionality.
Lets add a button to our previous example.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, "My Window");
    let mut but = button::Button::new(160, 200, 80, 40, "Click me!");
    my_window.end();
    my_window.show();
    app.run().unwrap();
}</code></pre></pre>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/245810501-0f385285-42c5-4bba-a7ce-5517e114b578.PNG" alt="widgets" /></p>
</div>
<p>Notice that the button's parent is my_window since it's created between the implicit begin() and end() calls.
Another way to add a widget is using the add(widget) method that's offered by widgets implementing the GroupExt trait:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, "My Window");
    my_window.end();
    my_window.show();

    let mut but = button::Button::new(160, 200, 80, 40, "Click me!");
    my_window.add(&amp;but);

    app.run().unwrap();
}</code></pre></pre>
<p>Another thing to notice is the initialization of the button which basically has the same constructor as the Window, that's because it's part of the WidgetBase trait. However, although the Window's x and y coordinates are relative to the screen, the button's x and y coordinates are relative to the window which contains the button. This also applies to our embedded window in the previous page if you hadn't noticed.</p>
<p>The button also implements the ButtonExt trait, which offers some helpful methods like setting shortcuts to trigger our button among other methods.</p>
<p>Constructing widgets can also be done using a builder pattern:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let but1 = Button::new(10, 10, 80, 40, "Button 1");
// OR
let but1 = Button::default()
    .with_pos(10, 10)
    .with_size(80, 40)
    .with_label("Button 1");
<span class="boring">}</span></code></pre></pre>
<p>Which basically have the same effect.</p>
<p>As it stands, our application shows a window with a button, the button is clickable but does nothing!
So lets add some action in there in the next page!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="buttons"><a class="header" href="#buttons">Buttons</a></h1>
<p>Button widgets serve multiple purposes and come in several forms:</p>
<ul>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.Button.html">Button</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.CheckButton.html">CheckButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.LightButton.html">LightButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.RadioButton.html">RadioButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.RadioLightButton.html">RadioLightButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.RadioRoundButton.html">RadioRoundButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.RepeatButton.html">RepeatButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.ReturnButton.html">ReturnButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.RoundButton.html">RoundButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.ShortcutButton.html">ShortcutButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/button/struct.ToggleButton.html">ToggleButton</a></li>
</ul>
<p>These can be found in the button module.
The simplest of which is the Button widget, which basically runs some action when clicked. This applies to all buttons as well:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, button::Button, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();
    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, "Click me!");
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label("Hello world"));

    app.run().unwrap();
}</code></pre></pre>
<p>However other buttons can have other value.
<code>CheckButton</code>, <code>ToggleButton</code>, <code>LightButton</code> for example hold their current value, i.e. whether they were toggled or not:</p>
<p>Radio buttons (<code>RadioRoundButton</code>, <code>RadioLightButton</code> and <code>RadioButton</code>) also hold their value, but only one can be toggled in the parent group (any widget implementing <code>GroupExt</code>). So they are aware of the values of other radio buttons:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    // only one can be toggled by the user at a time, the other will be automatically untoggled
    let btn1 = button::RadioRoundButton::default().with_label("Option 1");
    let btn2 = button::RadioRoundButton::default().with_label("Option 2");
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}</code></pre></pre>
<p>The focus box can be removed using the clear_visible_focus() method <code>btn1.clear_visible_focus()</code>.</p>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/37966791/145727291-8be40de6-8ec6-4e57-bb29-fa0f0ac3b251.png" alt="image" /></p>
</div>
<p>Other toggle-able buttons don't have this property.</p>
<p>You can query whether a button is toggled or not using the <code>ButtonExt::value()</code> method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    let btn1 = button::CheckButton::default().with_label("Option 1");
    let btn2 = button::CheckButton::default().with_label("Option 2");
    let mut btn3 = button::Button::default().with_label("Submit");
    flex.end();
    win.end();
    win.show();

    btn3.set_callback(move |btn3| {
        if btn1.value() {
            println!("btn1 is checked");
        }
        if btn2.value() {
            println!("btn2 is checked");
        }
    });

    a.run().unwrap();
}</code></pre></pre>
<p>CheckButton also provides a convenience method is_checked(), while radio buttons provide an is_toggled().</p>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/37966791/145727325-7e5bb45f-674e-4bb2-81c8-27d0ee391d34.png" alt="image" /></p>
</div>
<p>By default, toggle-able buttons are created untoggled, however this can be overridden using <code>set_value()</code>, or the convenience methods <code>set_checked()</code> for CheckButton and <code>set_toggled()</code> for radio buttons:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 200).column().center_of_parent();
    let mut btn1 = button::CheckButton::default().with_label("Option 1");
    btn1.set_value(true);
    // Similarly you can use btn1.set_checked(true)
    let btn2 = button::CheckButton::default().with_label("Option 2");
    let mut btn3 = button::Button::default().with_label("Submit");
    flex.end();
    win.end();
    win.show();

    btn3.set_callback(move |btn3| {
        if btn1.value() {
            println!("btn1 is checked");
        }
        if btn2.value() {
            println!("btn2 is checked");
        }
    });

    a.run().unwrap();
}</code></pre></pre>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/37966791/145727352-bf6dba5c-1a0c-4da4-8296-093e10470f0c.png" alt="image" /></p>
</div>
<hr />
<h1 id="widgets-preview"><a class="header" href="#widgets-preview">Widgets preview</a></h1>
<div align="center">
<h3 id="button"><a class="header" href="#button">Button</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810478-9bb5dd60-714c-4407-b7b5-c3ab060af70b.PNG" alt="Button" /></p>
<h3 id="checkbutton"><a class="header" href="#checkbutton">CheckButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810469-2414d2aa-8a7d-461e-ae39-768a5fe3e99d.PNG" alt="CheckButton" /></p>
<h3 id="lightbutton"><a class="header" href="#lightbutton">LightButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810476-22dda4d2-c8b4-4f24-bd0a-da672877bb9b.PNG" alt="LightButton" /></p>
<h3 id="radiobutton"><a class="header" href="#radiobutton">RadioButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810480-07a9c7b6-7578-4678-8b99-342a00dfb978.PNG" alt="RadioButton" /></p>
<h3 id="radiolightbutton"><a class="header" href="#radiolightbutton">RadioLightButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810483-f5a4602a-34dd-4312-bdd3-9773d9207854.PNG" alt="RadioLightButton" /></p>
<h3 id="radioroundbutton"><a class="header" href="#radioroundbutton">RadioRoundButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810485-e842f808-0be9-44ac-971e-4ea549cd5b23.PNG" alt="RadioRoundButton" /></p>
<h3 id="repeatbutton"><a class="header" href="#repeatbutton">RepeatButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810489-d1c29b47-c51a-46c9-9948-179bc9802a76.PNG" alt="RepeatButton" /></p>
<h3 id="roundbutton"><a class="header" href="#roundbutton">RoundButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810490-b5b9fcfd-38c8-4108-99d6-d22f50f7496e.PNG" alt="RoundButton" /></p>
<h3 id="shortcutbutton"><a class="header" href="#shortcutbutton">ShortcutButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810494-88930640-862a-4825-9592-488046da8907.PNG" alt="ShortcutButton" /></p>
<h3 id="togglebutton"><a class="header" href="#togglebutton">ToggleButton</a></h3>
<p><img src="https://user-images.githubusercontent.com/98977436/245810496-25c7b144-fb9c-44de-b1f8-02b0586eb391.PNG" alt="ToggleButton" /></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="labels"><a class="header" href="#labels">Labels</a></h1>
<p>FLTK doesn't have a Label widget. So if you would just like to show text, you can use a Frame widget and give it a label.</p>
<p>All widgets takes a label in the ::new() constructor or using with_label() or set_label():</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let btn = button::Button::new(160, 200, 80, 30, "Click");
<span class="boring">}</span></code></pre></pre>
<p>This button has a label showing the text "click".</p>
<p>Similarly we can use set_label() or with_label():</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let btn = button::Button::default().with_label("Click");
// or
let mut btn = button::Button::default();
btn.set_label("Click");
<span class="boring">}</span></code></pre></pre>
<p>However, the ::new() constructor takes in reality an optional to a static str, so the following would fail:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let label = String::from("Click"); // label is not a static str
let mut btn = button::Button::new(160, 200, 80, 30, &amp;label);
<span class="boring">}</span></code></pre></pre>
<p>You would want to use <code>btn.set_label(&amp;label);</code> in this case. The reason is that FLTK expects a <code>const char *</code> label, which is the equivalent of Rust's <code>&amp;'static str</code>. These strings live in the program's code segment. If you disassemble an application, it would show all these static strings. And since these have a static lifetime, FLTK by default doesn't store them.
While using set_label() and with_label() calls FLTK's Fl_Widget::copy_label() method which actually stores the string.</p>
<p>You are also not limited to text labels, FLTK has predefined symbols which translate into images:</p>
<div align="center">
<p><img src="https://www.fltk.org/doc-1.4/symbols.png" alt="symbols" /></p>
</div>
<p>The @ sign may also be followed by the following optional "formatting" characters, in this order:</p>
<ul>
<li>'#' forces square scaling, rather than distortion to the widget's shape.</li>
<li>+[1-9] or -[1-9] tweaks the scaling a little bigger or smaller.</li>
<li>'$' flips the symbol horizontally, '%' flips it vertically.</li>
<li>[0-9] - rotates by a multiple of 45 degrees. '5' and '6' do no rotation while the others point in the direction of that key on a numeric keypad. '0', followed by four more digits rotates the symbol by that amount in degrees.</li>
</ul>
<p>Thus, to show a very large arrow pointing downward you would use the label string "@+92-&gt;".</p>
<p>Symbols and text can be combined in a label, however the symbol must be at the beginning and/or at the end of the text. If the text spans multiple lines, the symbol or symbols will scale up to match the height of all the lines:</p>
<div align="center">
<p><img src="https://www.fltk.org/doc-1.4/symbol-examples.png" alt="ex" /></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="group-widgets"><a class="header" href="#group-widgets">Group widgets</a></h1>
<p>These are container widgets which include Window types and others found in the group module: Group, Scroll, Pack, Tile, Flex ...etc.
Widgets implementing the GroupExt trait, are characterized by having to call <code>::end()</code> method to basically close them.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    let _btn = Button::new(160, 200, 80, 30, "Click");
    win.end();
    win.show();
    a.run().unwrap();
}</code></pre></pre>
<p>In the above example, the button <code>btn</code> will be parented by the window.
After <code>end</code>ing such GroupExt widgets, any other widgets instantiated after the <code>end</code> call, will be instantiated outside.
These can still be added using the <code>::add(&amp;other_widget)</code> method (or using <code>::insert</code>):</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    win.end();
    win.show();

    let btn = Button::new(160, 200, 80, 30, "Click");
    win.add(&amp;btn);
    
    a.run().unwrap();
}</code></pre></pre>
<p>Another option is to reopen the widget:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    app,
    button::Button,
    prelude::{GroupExt, WidgetBase, WidgetExt},
    window::Window,
};

fn main() {
    let a = app::App::default();
    let mut win = Window::default().with_size(400, 300);
    win.end();
    win.show();

    win.begin();
    let _btn = Button::new(160, 200, 80, 30, "Click");
    win.end();

    a.run().unwrap();
}</code></pre></pre>
<p>While most GroupExt widgets require manual layouts, several have automatic layouting. The Flex widget was discussed in the <a href="Layouts.html">layouts page</a>. Packs require the width or height of the child widget, depending on the Pack's orientation.</p>
<p>A vertical Pack needs to know only the heights of its children:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(200, 300);
    let mut pack = group::Pack::default_fill();
    pack.set_spacing(5);
    for i in 0..2 {
        frame::Frame::default().with_size(0, 40).with_label(&amp;format!("field {}", i));
        input::Input::default().with_size(0, 40);
    }
    frame::Frame::default().with_size(0, 40); // a filler
    button::Button::default().with_size(0, 40).with_label("Submit");
    pack.end();
    wind.end();
    wind.show();

    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727469-a7181ebf-a3a3-4675-af23-ec40d847a593.png" alt="image" /></p>
<p>For a horizontal pack, we set the Pack type, then we only need to pass the widths of the children:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(300, 100);
    let mut pack = group::Pack::default_fill().with_type(group::PackType::Horizontal);
    pack.set_spacing(5);
    for i in 0..2 {
        frame::Frame::default().with_size(40, 0).with_label(&amp;format!("field {}", i));
        input::Input::default().with_size(40, 0);
    }
    frame::Frame::default().with_size(40, 0); // a filler
    button::Button::default().with_size(40, 0).with_label("Submit");
    pack.end();
    wind.end();
    wind.show();

    app.run().unwrap();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="menus"><a class="header" href="#menus">Menus</a></h1>
<p>Menus in FLTK are widgets which implement the <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.MenuExt.html">MenuExt</a> trait. To that end, there are several types:</p>
<ul>
<li><a href="https://docs.rs/fltk/latest/fltk/menu/struct.MenuBar.html">MenuBar</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/menu/struct.MenuButton.html">MenuButton</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/menu/struct.MenuItem.html">MenuItem</a></li>
<li><a href="https://docs.rs/fltk/latest/fltk/menu/struct.Choice.html">Choice</a> <em>dropdown list</em></li>
<li><a href="https://docs.rs/fltk/latest/fltk/menu/struct.SysMenuBar.html">SysMenuBar</a> <em>MacOS menu bar which appears at the top of the screen</em></li>
<li><a href="https://docs.rs/fltk/latest/fltk/menu/struct.MacAppMenu.html">MacAppMenu</a></li>
</ul>
<p>Menu types function in 2 main ways:</p>
<p><strong>1-</strong> Add choices using the <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.MenuExt.html#tymethod.add_choice">add_choice()</a> method, then handling the user's selection in the callback:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default().with_size(80, 30).center_of_parent().with_label("Select item");
    choice.add_choice("Choice 1");
    choice.add_choice("Choice 2");
    choice.add_choice("Choice 3");
    // You can also simply type choice.add_choice("Choice 1|Choice 2|Choice 3");
    wind.end();
    wind.show();

    choice.set_callback(|c| {
        match c.value() {
            0 =&gt; println!("choice 1 selected"),
            1 =&gt; println!("choice 2 selected"),
            2 =&gt; println!("choice 3 selected"),
            _ =&gt; unreachable!(),
        }
    });

    app.run().unwrap();
}</code></pre></pre>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/37966791/145727397-dd713782-9f8e-474b-b009-f2ebeb5170ea.png" alt="image" /></p>
</div>
<p>Alternatively you can query the textual value of the selected item:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default().with_size(80, 30).center_of_parent().with_label("Select item");
    choice.add_choice("Choice 1|Choice 2|Choice 3");
    wind.end();
    wind.show();

    choice.set_callback(|c| {
        if let Some(choice) = c.choice() {
            match choice.as_str() {
                "Choice 1" =&gt; println!("choice 1 selected"),
                "Choice 2" =&gt; println!("choice 2 selected"),
                "Choice 3" =&gt; println!("choice 3 selected"),
                _ =&gt; unreachable!(),
            }
        }
    });

    app.run().unwrap();
}</code></pre></pre>
<p><strong>2-</strong> Adding choices via the <a href="https://docs.rs/fltk/latest/fltk/prelude/trait.MenuExt.html#tymethod.add">add()</a> method, you pass each choice's callback distinctively.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default()
        .with_size(80, 30)
        .center_of_parent()
        .with_label("Select item");

    choice.add(
        "Choice 1",
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!("choice 1 selected"),
    );
    choice.add(
        "Choice 2",
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!("choice 2 selected"),
    );
    choice.add(
        "Choice 3",
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        |_| println!("choice 3 selected"),
    );

    wind.end();
    wind.show();

    app.run().unwrap();
}</code></pre></pre>
<p>Also as mentioned in the <a href="Events">Events section</a>, you can use a function object instead of passing closures:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{enums::*, prelude::*, *};

fn menu_cb(m: &amp;mut impl MenuExt) {
    if let Some(choice) = m.choice() {
        match choice.as_str() {
            "New\t" =&gt; println!("New"),
            "Open\t" =&gt; println!("Open"),
            "Third" =&gt; println!("Third"),
            "Quit\t" =&gt; {
                println!("Quitting");
                app::quit();
            },
            _ =&gt; println!("{}", choice),
        }
    }
}

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut menubar = menu::MenuBar::new(0, 0, 400, 40, "rew");
    menubar.add("File/New\t", Shortcut::None, menu::MenuFlag::Normal, menu_cb);
    menubar.add(
        "File/Open\t",
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    let idx = menubar.add(
        "File/Recent",
        Shortcut::None,
        menu::MenuFlag::Submenu,
        menu_cb,
    );
    menubar.add(
        "File/Recent/First\t",
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    menubar.add(
        "File/Recent/Second\t",
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    menubar.add(
        "File/Quit\t",
        Shortcut::None,
        menu::MenuFlag::Normal,
        menu_cb,
    );
    let mut btn1 = button::Button::new(160, 150, 80, 30, "Modify 1");
    let mut btn2 = button::Button::new(160, 200, 80, 30, "Modify 2");
    let mut clear = button::Button::new(160, 250, 80, 30, "Clear");
    win.end();
    win.show();

    btn1.set_callback({
        let menubar = menubar.clone();
        move |_| {
            if let Some(mut item) = menubar.find_item("File/Recent") {
                item.add(
                    "Recent/Third",
                    Shortcut::None,
                    menu::MenuFlag::Normal,
                    menu_cb,
                );
                item.add(
                    "Recent/Fourth",
                    Shortcut::None,
                    menu::MenuFlag::Normal,
                    menu_cb,
                );
            }
        }
    });

    btn2.set_callback({
        let mut menubar = menubar.clone();
        move |_| {
            menubar.add(
                "File/Recent/Fifth\t",
                Shortcut::None,
                menu::MenuFlag::Normal,
                menu_cb,
            );
            menubar.add(
                "File/Recent/Sixth\t",
                Shortcut::None,
                menu::MenuFlag::Normal,
                menu_cb,
            );
        }
    });

    clear.set_callback(move |_| {
        menubar.clear_submenu(idx).unwrap();
    });

    a.run().unwrap();
}</code></pre></pre>
<p>Alternatively, you can use the add_emit() to pass a Sender and a message instead of passing callbacks:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

#[derive(Clone)]
enum Message {
    Choice1,
    Choice2,
    Choice3,
}

fn main() {
    let a = app::App::default();
    let (s, r) = app::channel();
    let mut wind = window::Window::default().with_size(400, 300);
    let mut choice = menu::Choice::default()
        .with_size(80, 30)
        .center_of_parent()
        .with_label("Select item");

    choice.add_emit(
        "Choice 1",
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s.clone(),
        Message::Choice1,
    );
    choice.add_emit(
        "Choice 2",
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s.clone(),
        Message::Choice2,
    );
    choice.add_emit(
        "Choice 3",
        enums::Shortcut::None,
        menu::MenuFlag::Normal,
        s,
        Message::Choice3,
    );

    wind.end();
    wind.show();

    while a.wait() {
        if let Some(msg) = r.recv() {
            match msg {
                Message::Choice1 =&gt; println!("choice 1 selected"),
                Message::Choice2 =&gt; println!("choice 2 selected"),
                Message::Choice3 =&gt; println!("choice 3 selected"),
            }
        }
    }
}</code></pre></pre>
<p>You might wonder, why go from a handful of lines in the first examples to a more complex manner of doing things. Each method has it's uses.
For simple drop down widgets, go with the first method. For an application's menu bar, go with the second. It allows you to specify Shortcuts and <a href="https://docs.rs/fltk/latest/fltk/menu/struct.MenuFlag.html">MenuFlags</a>, and allows better decoupling of events, so you won't have to handle everything in the menu's callback. It's also easier to deal with submenus using the add() method, as in the <a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/editor.rs">editor example</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let mut menu = menu::SysMenuBar::default().with_size(800, 35);
        menu.set_frame(FrameType::FlatBox);
        menu.add_emit(
            "&amp;File/New...\t",
            Shortcut::Ctrl | 'n',
            menu::MenuFlag::Normal,
            *s,
            Message::New,
        );

        menu.add_emit(
            "&amp;File/Open...\t",
            Shortcut::Ctrl | 'o',
            menu::MenuFlag::Normal,
            *s,
            Message::Open,
        );

        menu.add_emit(
            "&amp;File/Save\t",
            Shortcut::Ctrl | 's',
            menu::MenuFlag::Normal,
            *s,
            Message::Save,
        );

        menu.add_emit(
            "&amp;File/Save as...\t",
            Shortcut::Ctrl | 'w',
            menu::MenuFlag::Normal,
            *s,
            Message::SaveAs,
        );

        menu.add_emit(
            "&amp;File/Print...\t",
            Shortcut::Ctrl | 'p',
            menu::MenuFlag::MenuDivider,
            *s,
            Message::Print,
        );

        menu.add_emit(
            "&amp;File/Quit\t",
            Shortcut::Ctrl | 'q',
            menu::MenuFlag::Normal,
            *s,
            Message::Quit,
        );

        menu.add_emit(
            "&amp;Edit/Cut\t",
            Shortcut::Ctrl | 'x',
            menu::MenuFlag::Normal,
            *s,
            Message::Cut,
        );

        menu.add_emit(
            "&amp;Edit/Copy\t",
            Shortcut::Ctrl | 'c',
            menu::MenuFlag::Normal,
            *s,
            Message::Copy,
        );

        menu.add_emit(
            "&amp;Edit/Paste\t",
            Shortcut::Ctrl | 'v',
            menu::MenuFlag::Normal,
            *s,
            Message::Paste,
        );

        menu.add_emit(
            "&amp;Help/About\t",
            Shortcut::None,
            menu::MenuFlag::Normal,
            *s,
            Message::About,
        );

        if let Some(mut item) = menu.find_item("&amp;File/Quit\t") {
            item.set_label_color(Color::Red);
        }
<span class="boring">}</span></code></pre></pre>
<p>Also notice the last call, which uses find_item() to find an item in the menu, and we hence set its label color to red.</p>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/37966791/145727434-d66c6d55-018d-4341-9570-7c2864b5bf29.png" alt="image" /></p>
</div>
<h2 id="system-menu-bar"><a class="header" href="#system-menu-bar">System Menu Bar</a></h2>
<p>On MacOS, you might prefer to use a system menu bar, which typically appears on the top of the screen. For that, you can use a <a href="https://docs.rs/fltk/latest/fltk/menu/struct.SysMenuBar.html#">SysMenuBar</a> widget. This has the same api as all widgets implementing MenuExt, and it translates into a normal MenuBar when the app is compiled for other targets than a MacOS.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="input--output"><a class="header" href="#input--output">Input &amp; Output</a></h1>
<p>Input and Output widgets implement the InputExt trait. These are found between the input and output modules:</p>
<ul>
<li>Input</li>
<li>IntInput</li>
<li>FloatInput</li>
<li>MultilineInput</li>
<li>SecretInput</li>
<li>FileInput</li>
<li>Output</li>
<li>MultilineOutput</li>
</ul>
<p>The hallmark of this trait is that these widgets have a textual value which can be queried using the value() method, and changed using the set_value() method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 100).column().center_of_parent();
    let label = frame::Frame::default().with_label("Enter age");
    let input = input::IntInput::default();
    let mut btn = button::Button::default().with_label("Submit");
    flex.end();
    win.end();
    win.show();

    btn.set_callback(move |btn| {
        println!("your age is {}", input.value());
    });

    a.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727249-2fa4d384-2bd3-41fd-bbae-61a3a33b12f6.png" alt="image" /></p>
<p>Notice that we used an IntInput to limit ourselves to integral values. Even though for the user they can't enter strings, the return of value() is still a String as far as the developer is concerned.</p>
<p>Output widgets don't allow the user to modify their values:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(200, 50).column().center_of_parent();
    let label = frame::Frame::default().with_label("Check this text:");
    let mut output = output::Output::default();
    output.set_value("You can't edit this!");
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727261-88ec533f-200b-4df7-a570-76ebd2ba520a.png" alt="image" /></p>
<p>Input widgets also support being made read-only using the InputExt::set_readonly(bool) method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let flex = group::Flex::default().with_size(100, 100).column().center_of_parent();
    let label = frame::Frame::default().with_label("Enter age");
    let mut input = input::IntInput::default();
    let mut btn = button::Button::default().with_label("Submit");
    flex.end();
    win.end();
    win.show();

    btn.set_callback(move |btn| {
        println!("your age is {}", input.value());
        input.set_readonly(true);
    });

    a.run().unwrap();
}</code></pre></pre>
<p>This makes our input read-only once the user hits the button.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valuators"><a class="header" href="#valuators">Valuators</a></h1>
<p>Valuator widgets implement the ValuatorExt trait. These keep track (graphically and internally) of numerical values along with steps, ranges and bounds.
Such valuators which you might be familiar with are scrollbars and sliders. The list offered by fltk is found in the valuator module:</p>
<ul>
<li>Slider</li>
<li>NiceSlider</li>
<li>ValueSlider</li>
<li>Dial</li>
<li>LineDial</li>
<li>Counter</li>
<li>Scrollbar</li>
<li>Roller</li>
<li>Adjuster</li>
<li>ValueInput</li>
<li>ValueOutput</li>
<li>FillSlider</li>
<li>FillDial</li>
<li>HorSlider (Horizontal slider)</li>
<li>HorFillSlider</li>
<li>HorNiceSlider</li>
<li>HorValueSlider</li>
</ul>
<p>Changing the valuator's value in the gui triggers its callback. The current value of the valuator can be queried using the value() method. It can also be set using set_value(). The ranges and step can also be queried and changed to your use case:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut slider = valuator::HorNiceSlider::default().with_size(400, 20).center_of_parent();
    slider.set_minimum(0.);
    slider.set_maximum(100.);
    slider.set_step(1., 1); // increment by 1.0 at each 1 step
    slider.set_value(50.); // start in the middle
    win.end();
    win.show();

    slider.set_callback(|s| {
        println!("slider at {}", s.value());
    });
    a.run().unwrap();
}</code></pre></pre>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/37966791/145727188-4ac06d45-7fd1-44f7-9adc-366d9bb79d8f.png" alt="HorNiceSlider" /></p>
</div>
<p>Below you can see the same example using different valuator widgets.</p>
<details>
<summary><b>Valuator widgets examples</b></summary>
<h2 id="adjuster-widget"><a class="header" href="#adjuster-widget">Adjuster widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242296674-1e126073-2c9f-443d-9dab-fccd66733e39.PNG" alt="Adjuster" /></p>
</div>
<h2 id="counter-widget"><a class="header" href="#counter-widget">Counter widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744205-f2729663-ed21-4e8b-a957-093c436fd00f.PNG" alt="Counter" /></p>
</div>
<h2 id="dial-widget"><a class="header" href="#dial-widget">Dial widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744149-cf050906-0be9-4212-9d0c-ae4f33bbef5a.PNG" alt="Dial" /></p>
</div>
<h2 id="filldial-widget"><a class="header" href="#filldial-widget">FillDial widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744161-7c210cc6-4869-4c17-8a8d-eb115c4a05b3.PNG" alt="FillDial" /></p>
</div>
<h2 id="fillslider-widget"><a class="header" href="#fillslider-widget">FillSlider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744164-ad6cb154-82bc-4379-988a-205c0991071e.PNG" alt="FillSlider" /></p>
</div>
<h2 id="horfillslider-widget"><a class="header" href="#horfillslider-widget">HorFillSlider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744166-34698d23-6ace-4971-8a46-5e41d9e03b7f.PNG" alt="HorFillSlider" /></p>
</div>
<h2 id="horniceslider-widget"><a class="header" href="#horniceslider-widget">HorNiceSlider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744167-4975a80b-eee9-45e9-9655-ade47ac331c2.PNG" alt="HorNiceSlider" /></p>
</div>
<h2 id="horslider-widget"><a class="header" href="#horslider-widget">HorSlider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744168-eaa87ef0-932a-48b0-9b39-1f35245e0dfe.PNG" alt="HorSlider" /></p>
</div>
<h2 id="horvalueslider-widget"><a class="header" href="#horvalueslider-widget">HorValueSlider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744171-d17f2c12-aa65-4b95-b026-a501dd9d7112.PNG" alt="HorValueSlider" /></p>
</div>
<h2 id="linedial-widget"><a class="header" href="#linedial-widget">LineDial widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744174-57e1dee1-104e-4870-99b7-cd1bf8cb82a7.PNG" alt="LineDial" /></p>
</div>
<h2 id="niceslider-widget"><a class="header" href="#niceslider-widget">NiceSlider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744175-b75f737d-5d93-4d98-9a17-700cd7d74fae.PNG" alt="NiceSlider" /></p>
</div>
<h2 id="roller-widget"><a class="header" href="#roller-widget">Roller widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744176-63fc716c-c0ac-45b2-b2ed-1ab79b62c64d.PNG" alt="Roller" /></p>
</div>
<h2 id="scrollbar-widget"><a class="header" href="#scrollbar-widget">Scrollbar widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744178-ed347599-b75a-41e9-8feb-8f87e3f65ec8.PNG" alt="Scrollbar" /></p>
</div>
<h2 id="slider-widget"><a class="header" href="#slider-widget">Slider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744188-7115f63d-cd53-412a-a603-1f606a15d644.PNG" alt="Slider" /></p>
</div>
<h2 id="valueinput-widget"><a class="header" href="#valueinput-widget">ValueInput widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744198-85708994-2123-4d24-97ef-b3e9feb4392e.PNG" alt="ValueInput" /></p>
</div>
<h2 id="valueoutput-widget"><a class="header" href="#valueoutput-widget">ValueOutput widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744199-d62b300e-3661-4d0b-9eea-fd971cedb53e.PNG" alt="ValueOutput" /></p>
</div>
<h2 id="valueslider-widget"><a class="header" href="#valueslider-widget">ValueSlider widget</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744201-739d9730-c765-434e-a37e-00b89e7d9a10.PNG" alt="ValueSlider" /></p>
</div>
</details>
<hr />
<h1 id="valuator-enums"><a class="header" href="#valuator-enums">Valuator enums</a></h1>
<p>Some valuators offer different types which can be set using the <code>set_type</code> method (or <code>with_type</code> builder function). The value passed is an enum value of <code>&lt;Widget&gt;Type</code> usually.
In the following example, we instantiate a Counter, then set its type to a Simple counter.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut counter = valuator::Counter::default().with_size(200, 50).center_of_parent();
counter.set_type(fltk::valuator::CounterType::Simple);
<span class="boring">}</span></code></pre></pre>
<p>Check below for more types associated with different valuator widgets.</p>
<details>
<summary><b>Valuator type enums examples</b></summary>
<h2 id="countertypenormal"><a class="header" href="#countertypenormal">CounterType::Normal</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744208-123e67c2-7d99-4e1e-ba18-961f6a045c3c.PNG" alt="CounterTypeNormal" /></p>
</div>
<h2 id="countertypesimple"><a class="header" href="#countertypesimple">CounterType::Simple</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744209-5a32155d-2481-420d-a4df-e65cb94c896b.PNG" alt="CounterTypeSimple" /></p>
</div>
<hr />
<h2 id="dialtypenormal"><a class="header" href="#dialtypenormal">DialType::Normal</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744158-40daa466-d0ff-4829-a59e-ea53a828316a.PNG" alt="DialTypeNormal" /></p>
</div>
<h2 id="dialtypeline"><a class="header" href="#dialtypeline">DialType::Line</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744156-81aadbdd-349f-4e8f-9a18-aa3aab192384.PNG" alt="DialTypeLine" /></p>
</div>
<h2 id="dialtypefill"><a class="header" href="#dialtypefill">DialType::Fill</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744153-86da086c-e41d-474d-93a7-1a5724c1936b.PNG" alt="DialTypeFill" /></p>
</div>
<hr />
<h2 id="scrollbartypevertical"><a class="header" href="#scrollbartypevertical">ScrollbarType::Vertical</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744185-f3d0d260-1d51-4818-8d5e-44a569de13fd.PNG" alt="ScrollbarTypeVertical" /></p>
</div>
<h2 id="scrollbartypehorizontal"><a class="header" href="#scrollbartypehorizontal">ScrollbarType::Horizontal</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744179-2c1ab7b0-3d0c-478b-8991-57e03c830cc2.PNG" alt="ScrollbarTypeHorizontal" /></p>
</div>
<h2 id="scrollbartypeverticalfill"><a class="header" href="#scrollbartypeverticalfill">ScrollbarType::VerticalFill</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744186-4e11a7a3-ead8-4662-a253-adec6f462fae.PNG" alt="ScrollbarTypeVerticalFill" /></p>
</div>
<h2 id="scrollbartypehorizontalfill"><a class="header" href="#scrollbartypehorizontalfill">ScrollbarType::HorizontalFill</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744181-a46e4e21-98b2-4ff8-82e0-2592c2bd6c36.PNG" alt="ScrollbarTypeHorizontalFill" /></p>
</div>
<h2 id="scrollbartypeverticalnice"><a class="header" href="#scrollbartypeverticalnice">ScrollbarType::VerticalNice</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744187-4cbb48c1-91e5-42e8-91c0-a207570ba02c.PNG" alt="ScrollbarTypeVerticalNice" /></p>
</div>
<h2 id="scrollbartypehorizontalnice"><a class="header" href="#scrollbartypehorizontalnice">ScrollbarType::HorizontalNice</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744183-64c40027-584a-496d-93f0-4909a3addf43.PNG" alt="ScrollbarTypeHorizontalNice" /></p>
</div>
<hr />
<h2 id="slidertypevertical"><a class="header" href="#slidertypevertical">SliderType::Vertical</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744192-ca19a6e9-1221-4253-b357-cd4cf12a0801.PNG" alt="SliderTypeVertical" /></p>
</div>
<h2 id="slidertypeverticalfill"><a class="header" href="#slidertypeverticalfill">SliderType::VerticalFill</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744194-20b3c4a9-cd42-4c07-ae44-9753d7ab4393.PNG" alt="SliderTypeVerticalFill" /></p>
</div>
<h2 id="slidertypehorizontalfill"><a class="header" href="#slidertypehorizontalfill">SliderType::HorizontalFill</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744190-11f4f4f4-137a-4d10-8beb-13514c6e8357.PNG" alt="SliderTypeHorizontalFill" /></p>
</div>
<h2 id="slidertypeverticalnice"><a class="header" href="#slidertypeverticalnice">SliderType::VerticalNice</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744196-96dac4e1-bf0d-4622-ba45-84d20985ec89.PNG" alt="SliderTypeVerticalNice" /></p>
</div>
<h2 id="slidertypehorizontalnice"><a class="header" href="#slidertypehorizontalnice">SliderType::HorizontalNice</a></h2>
<div align="center">
<p><img src="https://user-images.githubusercontent.com/98977436/242744191-83d3520d-c648-4372-8fc6-32ad29ec3162.PNG" alt="SliderTypeHorizontalNice" /></p>
</div>
</details>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">Text</a></h1>
<p>Text widgets are those that implement the DisplayExt. There are 3 and these can be found in the text module:</p>
<ul>
<li>TextDisplay</li>
<li>TextEditor</li>
<li>SimpleTerminal</li>
</ul>
<p>The main purpose of these widgets is displaying/editing text. The first 2 widgets require a TextBuffer, while the SimpleTerminal has an internal buffer:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextEditor::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf.clone());
    win.end();
    win.show();

    buf.set_text("Hello world!");
    buf.append("\n");
    buf.append("This is a text editor!");

    a.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727101-175fe355-1383-4789-ae40-2945ef0c63e2.png" alt="image" /></p>
<p>Most operations are done through the TextBuffer. Text can be appended using append() or the whole content can be set using set_text().
You can get back a clone (reference type) of the buffer using the DisplayExt::buffer() method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let buf = text::TextBuffer::default();

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextEditor::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf);
    win.end();
    win.show();

    let mut my_buf = txt.buffer().unwrap();

    my_buf.set_text("Hello world!");
    my_buf.append("\n");
    my_buf.append("This is a text editor!");

    a.run().unwrap();
}</code></pre></pre>
<p>The DisplayExt offers other methods to manage the text properties such as wrapping, cursor position, font, color, size...etc:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{enums::Color, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();
    buf.set_text("Hello world!");
    buf.append("\n");
    buf.append("This is a text editor!");

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextDisplay::default().with_size(390, 290).center_of_parent();
    txt.set_buffer(buf);
    txt.wrap_mode(text::WrapMode::AtBounds, 0); // bounds don't require the second argument, unlike AtPixel and AtColumn
    txt.set_text_color(Color::Red);
    win.end();
    win.show();

    a.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727121-8396c77e-836d-4406-abd1-92af32ff7242.png" alt="image" /></p>
<p>The TextBuffer has also a second purpose, and that's to provide a style buffer. A style buffer mirrors your text buffer and uses a style table (containing font, color and size) to add granular styling to your text, the style table itself is indexed, so to speak, using the corresponding letter:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    enums::{Color, Font},
    prelude::*,
    *,
};

const STYLES: &amp;[text::StyleTableEntry] = &amp;[
    text::StyleTableEntry {
        color: Color::Green,
        font: Font::Courier,
        size: 16,
    },
    text::StyleTableEntry {
        color: Color::Red,
        font: Font::Courier,
        size: 16,
    },
    text::StyleTableEntry {
        color: Color::from_u32(0x8000ff),
        font: Font::Courier,
        size: 16,
    },
];

fn main() {
    let a = app::App::default();
    let mut buf = text::TextBuffer::default();
    let mut sbuf = text::TextBuffer::default();
    buf.set_text("Hello world!");
    sbuf.set_text(&amp;"A".repeat("Hello world!".len())); // A represents the first entry in the table, repeated for every letter
    buf.append("\n"); 
    sbuf.append("B"); // Although a new line and the style might not apply, but it's needed to avoid messing out subsequent entries
    buf.append("This is a text editor!");
    sbuf.append(&amp;"C".repeat("This is a text editor!".len()));

    let mut win = window::Window::default().with_size(400, 300);
    let mut txt = text::TextDisplay::default()
        .with_size(390, 290)
        .center_of_parent();
    txt.set_buffer(buf);
    txt.set_highlight_data(sbuf, STYLES.to_vec());
    win.end();
    win.show();

    a.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727157-be992344-763d-41f9-b3d8-2dfa13fbaab1.png" alt="image" /></p>
<p>The terminal example uses the SimpleTerminal along with a style TextBuffer. It can be found <a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/terminal.rs">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="browsers"><a class="header" href="#browsers">Browsers</a></h1>
<p>Browser widgets implement the BrowserExt trait:</p>
<ul>
<li>Browser</li>
<li>SelectBrowser</li>
<li>HoldBrowser</li>
<li>MultiBrowser</li>
<li>FileBrowser</li>
<li>CheckBrowser</li>
</ul>
<p>These can be found in the browser module.</p>
<p>To instantiate a browser, it also needs the column widths, as well as the separator char that will be used in the add() method to separate items into columns:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default().with_size(900, 300);
    let mut b = browser::Browser::new(10, 10, 900 - 20, 300 - 20, "");
    let widths = &amp;[50, 50, 50, 70, 70, 40, 40, 70, 70, 50];
    b.set_column_widths(widths);
    b.set_column_char('\t');
    // we can now use the '\t' char in our add method.
    b.add("USER\tPID\t%CPU\t%MEM\tVSZ\tRSS\tTTY\tSTAT\tSTART\tTIME\tCOMMAND");
    b.add("root\t2888\t0.0\t0.0\t1352\t0\ttty3\tSW\tAug15\t0:00\t@b@f/sbin/mingetty tty3");
    b.add("erco\t2889\t0.0\t13.0\t221352\t0\ttty3\tR\tAug15\t1:34\t@b@f/usr/local/bin/render a35 0004");
    b.add("uucp\t2892\t0.0\t0.0\t1352\t0\tttyS0\tSW\tAug15\t0:00\t@b@f/sbin/agetty -h 19200 ttyS0 vt100");
    b.add("root\t13115\t0.0\t0.0\t1352\t0\ttty2\tSW\tAug30\t0:00\t@b@f/sbin/mingetty tty2");
    b.add(
        "root\t13464\t0.0\t0.0\t1352\t0\ttty1\tSW\tAug30\t0:00\t@b@f/sbin/mingetty tty1 --noclear",
    );
    win.end();
    win.show();
    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145733437-e3061015-12fa-4f2e-a1e3-01f59c4b189d.png" alt="image" /></p>
<p>To gain additional formatting, we can use special character <code>@</code> followed by a formatting specifier:</p>
<ul>
<li>'@.' Print rest of line, don't look for more '@' signs</li>
<li>'@@' Print rest of line starting with '@'</li>
<li>'@l' Use a LARGE (24 point) font</li>
<li>'@m' Use a medium large (18 point) font</li>
<li>'@s' Use a small (11 point) font</li>
<li>'@b' Use a bold font (adds FL_BOLD to font)</li>
<li>'@i' Use an italic font (adds FL_ITALIC to font)</li>
<li>'@f' or '@t' Use a fixed-pitch font (sets font to FL_COURIER)</li>
<li>'@c' Center the line horizontally</li>
<li>'@r' Right-justify the text</li>
<li>'@B0', '@B1', ... '@B255' Fill the backgound with fl_color(n)</li>
<li>'@C0', '@C1', ... '@C255' Use fl_color(n) to draw the text</li>
<li>'@F0', '@F1', ... Use fl_font(n) to draw the text</li>
<li>'@S1', '@S2', ... Use point size n to draw the text</li>
<li>'@u' or '@_' Underline the text.</li>
<li>'@-' draw an engraved line through the middle.</li>
</ul>
<p>In the following example, we color %CPU to red by preceding it with @C88:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default().with_size(900, 300);
    let mut b = browser::Browser::new(10, 10, 900 - 20, 300 - 20, "");
    let widths = &amp;[50, 50, 50, 70, 70, 40, 40, 70, 70, 50];
    b.set_column_widths(widths);
    b.set_column_char('\t');
    b.add("USER\tPID\t@C88%CPU\t%MEM\tVSZ\tRSS\tTTY\tSTAT\tSTART\tTIME\tCOMMAND");
    win.end();
    win.show();
    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145733713-2fe3207d-25f7-4acd-ae91-754679c5696a.png" alt="image" /></p>
<p>The colors follow FLTK's colormap, which can be indexed from 0 to 255:</p>
<p><img src="https://www.fltk.org/doc-1.4/fltk-colormap.png" alt="colormap" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trees"><a class="header" href="#trees">Trees</a></h1>
<p>Tree widgets allow showing items in a tree! There's no tree trait, all methods belong to the Tree type. Items are added using the add method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.add("Item 1");
    tree.add("Item 2");
    tree.add("Item 3");
    win.end();
    win.show();

    a.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726958-f1f2a095-39c5-496f-b772-18d024dd609d.png" alt="image" /></p>
<p>Sub-items are added by using the forward slash separator:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.add("Item 1");
    tree.add("Item 2");
    tree.add("Item 3");
    tree.add("Item 3/Subitem 1");
    tree.add("Item 3/Subitem 2");
    tree.add("Item 3/Subitem 3");
    win.end();
    win.show();

    a.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727026-bfcff44f-2b01-4679-937b-3e7d441dfdf0.png" alt="image" /></p>
<p>If you try the above code, you'll see that the root item is always indicated by the label "ROOT". This can be changed using the set_root_label() method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_root_label("My Tree");
    tree.add("Item 1");
    tree.add("Item 2");
    tree.add("Item 3");
    tree.add("Item 3/Subitem 1");
    tree.add("Item 3/Subitem 2");
    tree.add("Item 3/Subitem 3");
    win.end();
    win.show();

    a.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727045-a25be6bc-a514-4b4a-b7b9-0a7ee2e359b4.png" alt="image" /></p>
<p>Or even hidden using the set_show_root(false) method.</p>
<p>Items can be queried using the first_selected_item() method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_show_root(false);
    tree.add("Item 1");
    tree.add("Item 2");
    tree.add("Item 3");
    tree.add("Item 3/Subitem 1");
    tree.add("Item 3/Subitem 2");
    tree.add("Item 3/Subitem 3");
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(item) = t.first_selected_item() {
            println!("{} selected", item.label().unwrap());
        }
    });

    a.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727072-8596cf09-100c-4cb6-a427-0d3c66702b39.png" alt="image" /></p>
<p>Currently our tree only allow single selection, let's change it to multiple (we'll also change the connector style while we're at it):</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_select_mode(tree::TreeSelect::Multi);
    tree.set_connector_style(tree::TreeConnectorStyle::Solid);
    tree.set_connector_color(enums::Color::Red.inactive());
    tree.set_show_root(false);
    tree.add("Item 1");
    tree.add("Item 2");
    tree.add("Item 3");
    tree.add("Item 3/Subitem 1");
    tree.add("Item 3/Subitem 2");
    tree.add("Item 3/Subitem 3");
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(item) = t.first_selected_item() {
            println!("{} selected", item.label().unwrap());
        }
    });

    a.run().unwrap();
}</code></pre></pre>
<p>The problem now is that we need to get the whole selection instead only of the first selected item, so we'll use the get_selected_items() method which returns an optional Vec, and instead of just getting the label, we'll get the whole path of the item:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut tree = tree::Tree::default().with_size(390, 290).center_of_parent();
    tree.set_select_mode(tree::TreeSelect::Multi);
    tree.set_connector_style(tree::TreeConnectorStyle::Solid);
    tree.set_connector_color(enums::Color::Red.inactive());
    tree.set_show_root(false);
    tree.add("Item 1");
    tree.add("Item 2");
    tree.add("Item 3");
    tree.add("Item 3/Subitem 1");
    tree.add("Item 3/Subitem 2");
    tree.add("Item 3/Subitem 3");
    win.end();
    win.show();

    
    tree.set_callback(|t| {
        if let Some(items) = t.get_selected_items() {
            for i in items {
                println!("{} selected", t.item_pathname(&amp;i).unwrap());
            }
        }
    });

    a.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727000-4b881896-309d-465d-8305-9a7e0a92eaea.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tables"><a class="header" href="#tables">Tables</a></h1>
<p>fltk offers a table widget, the use code for which can be found in the examples. However, using the <a href="https://crates.io/crates/fltk-table">fltk-table crate</a> would require much less boilerplate code and also offers an easier and more intuitive interface:</p>
<pre><pre class="playground"><code class="language-rust edition2021">extern crate fltk_table;

use fltk::{
    app, enums,
    prelude::{GroupExt, WidgetExt},
    window,
};
use fltk_table::{SmartTable, TableOpts};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut wind = window::Window::default().with_size(800, 600);

    /// We pass the rows and columns thru the TableOpts field
    let mut table = SmartTable::default()
    .with_size(790, 590)
    .center_of_parent()
    .with_opts(TableOpts {
        rows: 30,
        cols: 15,
        editable: true,
        ..Default::default()
    });
    
    wind.end();
    wind.show();

    // Just filling the vec with some values
    for i in 0..30 {
        for j in 0..15 {
            table.set_cell_value(i, j, &amp;(i + j).to_string());
        }
    }

    // set the value at the row,column 4,5 to "another", notice that indices start at 0
    table.set_cell_value(3, 4, "another");

    assert_eq!(table.cell_value(3, 4), "another");

    // To avoid closing the window on hitting the escape key
    wind.set_callback(move |_| {
        if app::event() == enums::Event::Close {
            app.quit();
        }
    });

    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-table/raw/HEAD/screenshots/styled.jpg" alt="fltk-table" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-widgets"><a class="header" href="#custom-widgets">Custom widgets</a></h1>
<p>fltk-rs allows you to create custom widgets. We need to define a struct which extends an already existing widget and widget type. The most basic widget type being widget::Widget.
1- Define your struct and whatever other internal data needs to be stored in it.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, *};
use std::cell::RefCell;
use std::rc::Rc;

struct MyCustomButton {
    inner: widget::Widget,
    num_clicks: Rc&lt;RefCell&lt;i32&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>You'll notice 2 things, we're using an Rc RefCell for the data we're storing. This isn't necessary in the general case, however, since we need to move that data into a callback, while still having access to it after we mutate it, we'll wrap it in an Rc RefCell. We've imported the necessary modules.</p>
<p>2- Define the implementation of your struct. The most important of these being the constructor since it's how we'll initialize the internal data as well:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyCustomButton {
    // our constructor
    pub fn new(radius: i32, label: &amp;str) -&gt; Self {
        let mut inner = widget::Widget::default()
            .with_size(radius * 2, radius * 2)
            .with_label(label)
            .center_of_parent();
        inner.set_frame(enums::FrameType::OFlatBox);
        let num_clicks = 0;
        let num_clicks = Rc::from(RefCell::from(num_clicks));
        let clicks = num_clicks.clone();
        inner.draw(|i| { // we need a draw implementation
            draw::draw_box(i.frame(), i.x(), i.y(), i.w(), i.h(), i.color());
            draw::set_draw_color(enums::Color::Black); // for the text
            draw::set_font(enums::Font::Helvetica, app::font_size());
            draw::draw_text2(&amp;i.label(), i.x(), i.y(), i.w(), i.h(), i.align());
        });
        inner.handle(move |i, ev| match ev {
            enums::Event::Push =&gt; {
                *clicks.borrow_mut() += 1; // increment num_clicks
                i.do_callback(); // do the callback which we'll set using set_callback().
                true
            }
            _ =&gt; false,
        });
        Self {
            inner,
            num_clicks,
        }
    }

    // get the times our button was clicked
    pub fn num_clicks(&amp;self) -&gt; i32 {
        *self.num_clicks.borrow()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>3- Apply the widget_extends! macro to our struct, the macro requires the base type, and the member via which our custom type is extended. This is done via implementing the Deref and DerefMut traits. The macro also adds other convenience constructors and anchoring methods:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Extend widget::Widget via the member `inner` and add other initializers and constructors
widget_extends!(MyCustomButton, widget::Widget, inner);
<span class="boring">}</span></code></pre></pre>
<p>Now we're ready to try out our struct:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    app::background(255, 255, 255); // make the background white
    let mut wind = window::Window::new(100, 100, 400, 300, "Hello from rust");
    
    let mut btn = MyCustomButton::new(50, "Click");
    // notice that set_color and set_callback are automatically implemented for us!
    btn.set_color(enums::Color::Cyan);
    btn.set_callback(|_| println!("Clicked"));
    
    wind.end();
    wind.show();

    app.run().unwrap();
    
    // print the number our button was clicked on exit
    println!("Our button was clicked {} times", btn.num_clicks());
}</code></pre></pre>
<p>Full code:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};
use std::cell::RefCell;
use std::rc::Rc;

struct MyCustomButton {
    inner: widget::Widget,
    num_clicks: Rc&lt;RefCell&lt;i32&gt;&gt;,
}

impl MyCustomButton {
    // our constructor
    pub fn new(radius: i32, label: &amp;str) -&gt; Self {
        let mut inner = widget::Widget::default()
            .with_size(radius * 2, radius * 2)
            .with_label(label)
            .center_of_parent();
        inner.set_frame(enums::FrameType::OFlatBox);
        let num_clicks = 0;
        let num_clicks = Rc::from(RefCell::from(num_clicks));
        let clicks = num_clicks.clone();
        inner.draw(|i| { // we need a draw implementation
            draw::draw_box(i.frame(), i.x(), i.y(), i.w(), i.h(), i.color());
            draw::set_draw_color(enums::Color::Black); // for the text
            draw::set_font(enums::Font::Helvetica, app::font_size());
            draw::draw_text2(&amp;i.label(), i.x(), i.y(), i.w(), i.h(), i.align());
        });
        inner.handle(move |i, ev| match ev {
            enums::Event::Push =&gt; {
                *clicks.borrow_mut() += 1; // increment num_clicks
                i.do_callback(); // do the callback which we'll set using set_callback().
                true
            }
            _ =&gt; false,
        });
        Self {
            inner,
            num_clicks,
        }
    }

    // get the times our button was clicked
    pub fn num_clicks(&amp;self) -&gt; i32 {
        *self.num_clicks.borrow()
    }
}

// Extend widget::Widget via the member `inner` and add other initializers and constructors
widget_extends!(MyCustomButton, widget::Widget, inner);

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    app::background(255, 255, 255); // make the background white
    let mut wind = window::Window::new(100, 100, 400, 300, "Hello from rust");
    let mut btn = MyCustomButton::new(50, "Click");
    btn.set_color(enums::Color::Cyan);
    btn.set_callback(|_| println!("Clicked"));
    wind.end();
    wind.show();

    app.run().unwrap();
    
    // print the number our button was clicked on exit
    println!("Our button was clicked {} times", btn.num_clicks());
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727718-fd0ee71f-f0c2-4438-a038-9b6950638a35.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dialogs"><a class="header" href="#dialogs">Dialogs</a></h1>
<p>fltk offers several dialog types including file dialogs and others.</p>
<h2 id="file-dialogs"><a class="header" href="#file-dialogs">File dialogs</a></h2>
<p>There are 2 types, the native file dialog and FLTK's own file dialog. Native dialogs just show a the OS's own dialog. For windows, that's the win32 dialog, for MacOS, that's the Cocoa dialog, and for other posix systems, it depends on what you're running. On GNOME and other gtk-based desktops, it shows the gtk dialog and on KDE it shows kdialog.</p>
<h3 id="native-dialogs"><a class="header" href="#native-dialogs">Native dialogs</a></h3>
<p>To spawn a native dialog:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(80, 30)
        .with_label("Select file")
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseFile);
        dialog.show();
        println!("{:?}", dialog.filename());
    });

    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/146625105-94b11a5d-0938-4962-96d1-aaff5424ffe8.png" alt="image" /></p>
<p>This prints the Path of the chosen file. There are several types which can be passed as NativeFileChooserType, here we browse files, you can choose to BrowseDir instead, also enable mutli file/dir selection. If you select multiple files, you can get a Vec using the filenames() method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label("Select files")
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseMultiFile);
        dialog.show();
        println!("{:?}", dialog.filenames());
    });

    app.run().unwrap();
}</code></pre></pre>
<p>You can also add filter the files to show:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    btn.set_callback(|_| {
        let mut dialog = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseMultiFile);
        dialog.set_filter("*.{txt,rs,toml}");
        dialog.show();
        println!("{:?}", dialog.filenames());
    });
<span class="boring">}</span></code></pre></pre>
<p>This will only show .txt, .rs and .toml files.</p>
<h3 id="fltks-own-file-chooser"><a class="header" href="#fltks-own-file-chooser">FLTK's own file chooser</a></h3>
<p>FLTK also offers its own file chooser:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label("Select file")
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut dialog = dialog::FileChooser::new(
            /*start dir*/ ".",
            /*pattern*/ "*.{txt,rs,toml}",
            /*type*/ dialog::FileChooserType::Multi,
            /*title*/ "Select file:",
        );
        dialog.show();
        while dialog.shown() {
            app::wait();
        }
        if dialog.count() &gt; 1 {
            for i in 1..=dialog.count() { // values start at 1
                println!(" VALUE[{}]: '{}'", i, dialog.value(i).unwrap());
            }
        }
    });

    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726912-600e4c58-32b7-4a1b-8e6a-44e640549722.png" alt="image" /></p>
<p>A convenience function is also provided using file_chooser() and dir_chooser() functions:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label("Select file")
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let file = dialog::file_chooser(
            "Choose File",
            "*.rs",
            /*start dir*/ ".",
            /*relative*/ true,
        );
        if let Some(file) = file {
            println!("{}", file);
        }
    });

    app.run().unwrap();
}</code></pre></pre>
<h3 id="help-dialog"><a class="header" href="#help-dialog">Help dialog</a></h3>
<p>FLTK offers a help dialog which can show html 2 documents:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label("Show dialog")
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let mut help = dialog::HelpDialog::new(100, 100, 400, 300);
        help.set_value("&lt;h2&gt;Hello world&lt;/h2&gt;"); // this takes html
        help.show();
        while help.shown() {
            app::wait();
        }
    });

    app.run().unwrap();
}</code></pre></pre>
<p>The html can also be loaded using the HelpDialog::load(path_to_html_file) method.</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145726889-442d0453-e1d0-4b41-8717-f121fdf860fa.png" alt="image" /></p>
<h3 id="alert-dialogs"><a class="header" href="#alert-dialogs">Alert dialogs</a></h3>
<p>FLTK also offers several dialog types which can be conveniently shown using free functions:</p>
<ul>
<li>message</li>
<li>alert</li>
<li>choice</li>
<li>input</li>
<li>password (like input but doesn't show the inputted data)</li>
</ul>
<p>To show up a simple message dialog:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label("Show dialog")
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        dialog::message_default("Message");
    });

    app.run().unwrap();
}</code></pre></pre>
<p>This shows a message at a default location (basically near the pointer). If you would like to enter coordinates manually, you can use the message() function:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    btn.set_callback(|_| {
        dialog::message(100, 100, "Message");
    });
<span class="boring">}</span></code></pre></pre>
<p>All the previously mentioned functions have 2 variants, one with _default() suffix which doesn't require coordinates, and the other without which requires coordinates.
Some dialogs return a value, like choice, input, and password. Input and password return the inputted text, while choice returns an index of the chosen value:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label("Show dialog")
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        // password and input also takes a second arg which is the default value
        let pass = dialog::password_default("Enter password:", "");
        if let Some(pass) = pass {
            println!("{}", pass);
        }
    });

    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726850-61fc17e4-cd6e-4821-a9b5-396203806066.png" alt="image" /></p>
<p>An example with choice:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label("Show dialog")
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let choice = dialog::choice_default("Would you like to save", "No", "Yes", "Cancel");
        println!("{}", choice);
    });

    app.run().unwrap();
}</code></pre></pre>
<p>This will print the index, i.e. choosing No will print 0, Yes will print 1 and Cancel will print 2.</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145726775-d000a807-8bf5-439b-a991-8bf25fcd5049.png" alt="image" /></p>
<p>You have noticed that all of these dialogs didn't have a title. You can add a title also using a free function called before the dialog:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        dialog::message_title("Exit!");
        let choice = dialog::choice_default("Would you like to save", "No", "Yes", "Cancel");
<span class="boring">}</span></code></pre></pre>
<p>You can also set the default title of all these dialog boxes using dialog::message_title_default(), you'll want to do this in the start of your app:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    dialog::message_title_default("My App!");
    let mut wind = window::Window::default().with_size(400, 300);

    let mut btn = button::Button::default()
        .with_size(100, 30)
        .with_label("Show dialog")
        .center_of_parent();

    wind.end();
    wind.show();

    btn.set_callback(|_| {
        let choice = dialog::choice_default("Would you like to save", "No", "Yes", "Cancel");
        println!("{}", choice);
    });

    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726685-f086bde2-db63-4fa8-a579-954dbacbe44d.png" alt="image" /></p>
<h2 id="custom-dialogs"><a class="header" href="#custom-dialogs">Custom dialogs</a></h2>
<p>All these dialogs make assumptions about your app that might not be correct, especially regarding colors and fonts. If you have a heavily customized app you would probably also want custom dialogs. A dialog is basically a modal window which is spawned during the application. This can have the same styling as the rest of your app:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    app, button,
    enums::{Color, Font, FrameType},
    frame, group, input,
    prelude::*,
    window,
};

fn style_button(btn: &amp;mut button::Button) {
    btn.set_color(Color::Cyan);
    btn.set_frame(FrameType::RFlatBox);
    btn.clear_visible_focus();
}

pub fn show_dialog() -&gt; MyDialog {
    MyDialog::default()
}

pub struct MyDialog {
    inp: input::Input,
}

impl MyDialog {
    pub fn default() -&gt; Self {
        let mut win = window::Window::default()
            .with_size(400, 100)
            .with_label("My Dialog");
        win.set_color(Color::from_rgb(240, 240, 240));
        let mut pack = group::Pack::default()
            .with_size(300, 30)
            .center_of_parent()
            .with_type(group::PackType::Horizontal);
        pack.set_spacing(20);
        frame::Frame::default()
            .with_size(80, 0)
            .with_label("Enter name:");
        let mut inp = input::Input::default().with_size(100, 0);
        inp.set_frame(FrameType::FlatBox);
        let mut ok = button::Button::default().with_size(80, 0).with_label("Ok");
        style_button(&amp;mut ok);
        pack.end();
        win.end();
        win.make_modal(true);
        win.show();
        ok.set_callback({
            let mut win = win.clone();
            move |_| {
                win.hide();
            }
        });
        while win.shown() {
            app::wait();
        }
        Self { inp }
    }
    pub fn value(&amp;self) -&gt; String {
        self.inp.value()
    }
}

fn main() {
    let a = app::App::default();
    app::set_font(Font::Times);
    let mut win = window::Window::default().with_size(600, 400);
    win.set_color(Color::from_rgb(240, 240, 240));
    let mut btn = button::Button::default()
        .with_size(80, 30)
        .with_label("Click")
        .center_of_parent();
    style_button(&amp;mut btn);
    let mut frame = frame::Frame::new(btn.x() - 40, btn.y() - 100, btn.w() + 80, 30, None);
    frame.set_frame(FrameType::BorderBox);
    frame.set_color(Color::Red.inactive());
    win.end();
    win.show();
    btn.set_callback(move |_| {
        let d = show_dialog();
        frame.set_label(&amp;d.value());
    });
    a.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145726727-a0018457-1d87-4519-9d6e-08d8f8030d1a.png" alt="image" /></p>
<h2 id="printer-dialog"><a class="header" href="#printer-dialog">Printer dialog</a></h2>
<p>FLTK also offers a printer dialog which uses your platform's native printer dialog:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, *};
let mut but = button::Button::default();
but.set_callback(|widget| {
    let mut printer = printer::Printer::default();
    if printer.begin_job(1).is_ok() {
        printer.begin_page().ok();
        let (width, height) = printer.printable_rect();
        draw::set_draw_color(enums::Color::Black);
        draw::set_line_style(draw::LineStyle::Solid, 2);
        draw::draw_rect(0, 0, width, height);
        draw::set_font(enums::Font::Courier, 12);
        printer.set_origin(width / 2, height / 2);
        printer.print_widget(widget, -widget.width() / 2, -widget.height() / 2);
        printer.end_page().ok();
        printer.end_job();
    }
});
<span class="boring">}</span></code></pre></pre>
<p>Here it's just printing the button's image and specifying where it shows on the paper. You can pass any widget (mostly like a TextEditor widget) as the printed widget.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="images"><a class="header" href="#images">Images</a></h1>
<p>FLTK supports vector and raster graphics, and out of the box offers several image types, namely:</p>
<ul>
<li>BmpImage</li>
<li>JpegImage</li>
<li>GifImage</li>
<li>PngImage</li>
<li>SvgImage</li>
<li>Pixmap</li>
<li>RgbImage</li>
<li>XpmImage</li>
<li>XbmImage</li>
<li>PnmImage</li>
</ul>
<p>It also defines 2 more helper types:</p>
<ul>
<li>SharedImage: which wraps all the previous types so you don't need to specify the image type.</li>
<li>TiledImage: which offers a tiled image of any of the concrete types.</li>
</ul>
<p>Image types implement the ImageExt trait which offers methods to allow scaling, and retrieving image metadata.
Images can be constructed by passing a path to the image's load() constructor, or for some types, by using a from_data() constructor which accepts image data.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Takes a path
let image = image::SvgImage::load("screenshots/RustLogo.svg").unwrap();

/// Takes data
let image= image::SvgImage::from_data(&amp;data).unwrap();
<span class="boring">}</span></code></pre></pre>
<p>Images can be used with widgets either via the WidgetExt::set_image()/set_image_scaled() or set_deimage()/set_deimage_scaled() (for deactivated/grayed image):</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, "Hello from rust");

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load("screenshots/RustLogo.svg").unwrap();
    image.scale(200, 200, true, true);
    frame.set_image(Some(image));

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}</code></pre></pre>
<p>Or via WidgetExt::draw() method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, "Hello from rust");

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load("screenshots/RustLogo.svg").unwrap();
    frame.draw(move |f| {
        image.scale(f.w(), f.h(), true, true);
        image.draw(f.x() + 40, f.y(), f.w(), f.h());
    });

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/hello.jpg" alt="svg" /></p>
<p>Using images in your app for icons and backgrounds also helps in giving your app its style.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>In the previously mentioned examples, you have seen callbacks mostly, and although that is one way of handling events, FLTK offers multiple ways to handle events:</p>
<ul>
<li>We can use the set_callback() method, which is automatically triggered with a click to our button.</li>
<li>We can use the handle() method for fine-grained event handling.</li>
<li>We can use the emit() method which takes a sender and a message, this allows us to handle events in the event loop.</li>
<li>We can define our own event, which can be handled within another widget's handle method.</li>
</ul>
<h3 id="setting-the-callback"><a class="header" href="#setting-the-callback">Setting the callback</a></h3>
<p>Part of the WidgetExt trait is the set_callback method:</p>
<h4 id="using-closures"><a class="header" href="#using-closures">Using closures</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, "My Window");
    let mut but = button::Button::new(160, 200, 80, 40, "Click me!");
    my_window.end();
    my_window.show();
    but.set_callback(|_| println!("The button was clicked!"));
    app.run().unwrap();
}</code></pre></pre>
<p>The capture argument is the <code>&amp;mut Self</code> of the widget for which the callback is set:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, "My Window");
    let mut but = button::Button::new(160, 200, 80, 40, "Click me!");
    my_window.end();
    my_window.show();
    but.set_callback(|b| b.set_label("Clicked!"));
    app.run().unwrap();
}</code></pre></pre>
<p>The set_callback() methods have default triggers varying by the type of the widget. For buttons it's clicking or pressing enter when the button has focus.
This can be changed using the set_trigger() method. For buttons this might not make much sense, however for input widgets, the trigger can be set to "CallbackTrigger::Changed" and this will cause changes in the input widget to trigger the callback.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    let mut inp = input::Input::default()
        .with_size(160, 30)
        .center_of_parent();
    win.end();
    win.show();
    inp.set_trigger(enums::CallbackTrigger::Changed);
    inp.set_callback(|i| println!("{}", i.value()));
    a.run().unwrap();
}</code></pre></pre>
<p>This will print on every character input by the user.</p>
<p>The advanatage of using closures is the ability to "close" on scope arguments, i.e. you can also pass variables from the surrounding scope into the closure:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, "My Window");
    let mut but = button::Button::new(160, 200, 80, 40, "Click me!");
    my_window.end();
    my_window.show();
    but.set_callback(move |_| {
        my_window.set_label("button was pressed");
    });
    app.run().unwrap();
}</code></pre></pre>
<p>You will notice in the <a href="Menus">Menus section</a> that the handling is done on a per MenuItem basis.</p>
<h4 id="using-function-objects"><a class="header" href="#using-function-objects">Using function objects</a></h4>
<p>You can also use function objects directly if you prefer:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn button_cb(w: &amp;mut impl WidgetExt) {
    w.set_label("Clicked");
}

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, "My Window");
    let mut but = button::Button::new(160, 200, 80, 40, "Click me!");
    my_window.end();
    my_window.show();
    but.set_callback(button_cb);
    app.run().unwrap();
}</code></pre></pre>
<p>We use <code>&amp;mut impl WidgetExt</code> to be able to reuse the function object with multiple different widget types, otherwise, you can use <code>&amp;mut button::Button</code> for the button.
A disadvantage to this approach, is that to handle state, you would have to manage global state.</p>
<pre><pre class="playground"><code class="language-rust edition2021">extern crate lazy_static;

use fltk::{prelude::*, *};
use std::sync::Mutex;

#[derive(Default)]
struct State {
    count: i32,
}

impl State {
    fn increment(&amp;mut self) {
        self.count += 1;
    }
}

lazy_static::lazy_static! {
    static ref STATE: Mutex&lt;State&gt; = Mutex::new(State::default());
}


fn button_cb(_w: &amp;mut button::Button) {
    let mut state = STATE.lock().unwrap();
    state.increment();
}

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, "My Window");
    let mut but = button::Button::new(160, 200, 80, 40, "Increment!");
    my_window.end();
    my_window.show();
    
    but.set_callback(button_cb);
    
    app.run().unwrap();
}</code></pre></pre>
<p>Here we use lazy_static, there are also other crates to facilitate state management.</p>
<p>Similary for menus, we can use <code>&amp;mut impl MenuExt</code> to be able to set the callback for menu widgets and menu items, in the <code>MenuExt::add()/insert()</code> or <code>MenuItem::add()/insert()</code> methods.</p>
<h3 id="using-the-handle-method"><a class="header" href="#using-the-handle-method">Using the handle method</a></h3>
<p>The handle method takes a closure whose parameter is an Event, and returns a bool for handled events. The bool lets FLTK know whether the event was handled or not.
The call looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut my_window = window::Window::new(100, 100, 400, 300, "My Window");
    let mut but = button::Button::new(160, 200, 80, 40, "Click me!");
    my_window.end();
    my_window.show();

    but.handle(|_, event| {
        println!("The event: {:?}", event);
        false
    });
    
    app.run().unwrap();
}</code></pre></pre>
<p>This prints the event, and doesn't handle it since we return false. Obviously we would like to do something useful, so change the handle call to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    but.handle(|_, event| match event {
        Event::Push =&gt; {
            println!("I was pushed!");
            true
        },
        _ =&gt; false,
    });
<span class="boring">}</span></code></pre></pre>
<p>Here we handle the Push event by doing something useful then  returning true, all other events are ignored and we return false.</p>
<p>Another example:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    but.handle(|b, event| match event {
        Event::Push =&gt; {
            b.set_label("Pushed");
            true
        },
        _ =&gt; false,
    });
<span class="boring">}</span></code></pre></pre>
<h3 id="using-messages"><a class="header" href="#using-messages">Using messages</a></h3>
<p>This allows us to create channels and a Sender and Receiver structs, we can then emit messages (which have to be Send + Sync safe) to be handled in our event loop. The advantage is that we avoid having to wrap our types in smart pointers when we need to pass them into closures or into spawned threads.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::new(100, 100, 400, 300, "My Window");
    let mut but = button::Button::new(160, 200, 80, 40, "Click me!");
    my_window.end();
    my_window.show();

    let (s, r) = app::channel();
    
    but.emit(s, true);
    // This is equivalent to calling but.set_callback(move |_| s.send(true)); 

    while app.wait() {
        if let Some(msg) = r.recv() {
            match msg {
                true =&gt; println!("Clicked"),
                false =&gt; (), // Here we basically do nothing
            }
        }
    }
}</code></pre></pre>
<p>Messages can be received in the event loop like in the previous example, otherwise you can receive messages in a background thread or in app::add_idle()' s callback:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    app::add_idle(move || {
        if let Some(msg) = r.recv() {
            match msg {
                true =&gt; println!("Clicked"),
                false =&gt; (), // Here we basically do nothing
            }
        }
    });
<span class="boring">}</span></code></pre></pre>
<p>You're also not limited to using fltk channels, you can use any channel. For example, this uses the std channel:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (s, r) = std::sync::mpsc::channel::&lt;Message&gt;();
btn.set_callback(move |_| {
    s.send(Message::SomeMessage).unwrap();
});
<span class="boring">}</span></code></pre></pre>
<p>You can also define a method which applies to all widgets, similar to the emit() method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use std::sync::mpsc::Sender;

pub trait SenderWidget&lt;W, T&gt;
where
    W: WidgetExt,
    T: Send + Sync + Clone + 'static,
{
    fn send(&amp;mut self, sender: Sender&lt;T&gt;, msg: T);
}

impl&lt;W, T&gt; SenderWidget&lt;W, T&gt; for W
where
    W: WidgetExt,
    T: Send + Sync + Clone + 'static,
{
    fn send(&amp;mut self, sender: Sender&lt;T&gt;, msg: T) {
        self.set_callback(move |_| {
            sender.send(msg.clone()).unwrap();
        });
    }
}

fn main() {
    let btn = button::Button::default();
    let (s, r) = std::sync::mpsc::channel::&lt;Message&gt;();
    btn.send(s.clone(), Message::SomeMessage);
}</code></pre></pre>
<h3 id="creating-our-own-events"><a class="header" href="#creating-our-own-events">Creating our own events</a></h3>
<p>FLTK recognizes 29 events which are listed in enums::Event. However it allows us to create our own events using the app::handle(impl Into<i32>, window) call. The handle function takes an arbitrary i32 (&gt; 30) value as a signal, ideally the values should be predefined, which can be handled within another widget's handle() method, the other widget needs to be within the window that was passed to app::handle.
In the following example, we create a window with a frame and a button. The button's callback sends a CHANGED Event through the app::handle_main function. The CHANGED signal is queried in the frame's handle method.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, button::*, enums::*, frame::*, group::*, prelude::*, window::*};
use std::cell::RefCell;
use std::rc::Rc;

pub struct MyEvent;

impl MyEvent {
    const CHANGED: i32 = 40;
}

#[derive(Clone)]
pub struct Counter {
    count: Rc&lt;RefCell&lt;i32&gt;&gt;,
}

impl Counter {
    pub fn new(val: i32) -&gt; Self {
        Counter {
            count: Rc::from(RefCell::from(val)),
        }
    }

    pub fn increment(&amp;mut self) {
        *self.count.borrow_mut() += 1;
        app::handle_main(MyEvent::CHANGED).unwrap();
    }

    pub fn decrement(&amp;mut self) {
        *self.count.borrow_mut() -= 1;
        app::handle_main(MyEvent::CHANGED).unwrap();
    }

    pub fn value(&amp;self) -&gt; i32 {
        *self.count.borrow()
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = app::App::default();
    let counter = Counter::new(0);
    let mut wind = Window::default().with_size(160, 200).with_label("Counter");
    let mut pack = Pack::default().with_size(120, 140).center_of(&amp;wind);
    pack.set_spacing(10);
    let mut but_inc = Button::default().with_size(0, 40).with_label("+");
    let mut frame = Frame::default()
        .with_size(0, 40)
        .with_label(&amp;counter.clone().value().to_string());
    let mut but_dec = Button::default().with_size(0, 40).with_label("-");
    pack.end();
    wind.end();
    wind.show();

    but_inc.set_callback({
        let mut c = counter.clone();
        move |_| c.increment()
    });

    but_dec.set_callback({
        let mut c = counter.clone();
        move |_| c.decrement()
    });
    
    frame.handle(move |f, ev| {
        if ev == MyEvent::CHANGED.into() {
            f.set_label(&amp;counter.clone().value().to_string());
            true
        } else {
            false
        }
    });

    Ok(app.run()?)
}</code></pre></pre>
<p>The sent i32 signal can be created on the fly, or added to a const local or global, or within an enum.</p>
<h4 id="advantages"><a class="header" href="#advantages">Advantages:</a></h4>
<ul>
<li>No overhead.</li>
<li>The signal is dealt with like any fltk event.</li>
<li>the app::handle function returns a bool which indicates whether the event was handled or not.</li>
<li>Allows handling of custom signals/events outside the event loop.</li>
<li>Allows an MVC or SVU architecture to your application.</li>
</ul>
<h4 id="disadvantages"><a class="header" href="#disadvantages">Disadvantages:</a></h4>
<ul>
<li>The signal can only be handled in a widget's handle method.</li>
<li>The signal is inaccessible within the event loop (for that, you might want to use WidgetExt::emit or channels described previously in this page).</li>
</ul>
<h2 id="handling-top-level-events"><a class="header" href="#handling-top-level-events">Handling top-level events</a></h2>
<p>Lets say our app wants to deal with certain key strokes, we can either handle it in our event-loop or as part of our app window's handle method:</p>
<p>Lets write our handler function:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// handler.rs
use fltk::enums::Key;

pub(crate) fn handle_key(key: Key) {
    match key {
        Key::Left =&gt; println!("ArrowLeft"),
        Key::Up =&gt; println!("ArrowUp"),
        Key::Right =&gt; println!("ArrowRight"),
        Key::Down =&gt; println!("ArrowDown"),
        Key::Escape =&gt; println!("Escape"),
        Key::Tab =&gt; println!("Tab"),
        Key::BackSpace =&gt; println!("Backspace"),
        Key::Insert =&gt; println!("Insert"),
        Key::Home =&gt; println!("Home"),
        Key::Delete =&gt; println!("Delete"),
        Key::End =&gt; println!("End"),
        Key::PageDown =&gt; println!("PageDown"),
        Key::PageUp =&gt; println!("PageUp"),
        Key::Enter =&gt; println!("Enter"),
        _ =&gt; {
            if let Some(k) = key.to_char() {
                match k {
                    ' ' =&gt; println!("Space"),
                    'a' =&gt; println!("A"),
                    'b' =&gt; println!("B"),
                    'c' =&gt; println!("C"),
                    'd' =&gt; println!("D"),
                    'e' =&gt; println!("E"),
                    'f' =&gt; println!("F"),
                    'g' =&gt; println!("G"),
                    'h' =&gt; println!("H"),
                    'i' =&gt; println!("I"),
                    'j' =&gt; println!("J"),
                    'k' =&gt; println!("K"),
                    'l' =&gt; println!("L"),
                    'm' =&gt; println!("M"),
                    'n' =&gt; println!("N"),
                    'o' =&gt; println!("O"),
                    'p' =&gt; println!("P"),
                    'q' =&gt; println!("Q"),
                    'r' =&gt; println!("R"),
                    's' =&gt; println!("S"),
                    't' =&gt; println!("T"),
                    'u' =&gt; println!("U"),
                    'v' =&gt; println!("V"),
                    'w' =&gt; println!("W"),
                    'x' =&gt; println!("X"),
                    'y' =&gt; println!("Y"),
                    'z' =&gt; println!("Z"),
                    '0' =&gt; println!("Num0"),
                    '1' =&gt; println!("Num1"),
                    '2' =&gt; println!("Num2"),
                    '3' =&gt; println!("Num3"),
                    '4' =&gt; println!("Num4"),
                    '5' =&gt; println!("Num5"),
                    '6' =&gt; println!("Num6"),
                    '7' =&gt; println!("Num7"),
                    '8' =&gt; println!("Num8"),
                    '9' =&gt; println!("Num9"),
                    _ =&gt; println!("Ignored char!"),
                }
            } else {
                println!("Ignored key!");
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Notice how fltk-rs doesn't have an enum for all character keys, instead we use key.to_char() when we have already matched the keys we're interested in.</p>
<p>Now lets use our handle_key(). As stated previously, it can be used as part of the event-loop:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// main.rs
use fltk::{
    *,
    prelude::*,
    enums::*,
};

mod handler;
use handler::handle_key;

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = window::Window::default().with_size(400, 300);
    wind.set_color(Color::White);
    wind.end();
    wind.show();

    while a.wait() {
        if app::event() == Event::KeyUp {
            let key = app::event_key();
            handle_key(key);
        }
    }
}</code></pre></pre>
<p>Otherwise we can use our main window's handle method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">// main.rs
use fltk::{
    *,
    prelude::*,
    enums::*,
};

mod handler;
use handler::handle_key;

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = window::Window::default().with_size(400, 300);
    wind.set_color(Color::White);
    wind.end();
    wind.show();
    
    wind.handle(|w, event| {
        match event {
            Event::KeyUp =&gt; {
                handle_key(app::event_key());
                true
            }
            _ =&gt; false,
        }
    });

    a.run().unwrap();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drag--drop"><a class="header" href="#drag--drop">Drag &amp; Drop</a></h1>
<p>Drag and Drop are Event types supported by FLTK. You can drag widgets around if you implement these events, and you can drag outside files into an FLTK application. You might also want to implement drawing over widgets which would require handling Event::Drag at least.</p>
<h2 id="dragging-widgets"><a class="header" href="#dragging-widgets">Dragging widgets</a></h2>
<p>Here we'll implement dragging for the window itself. We'll create a window without a border. Normally you can drag windows around using the border:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default().with_size(400, 400);
    wind.set_color(enums::Color::White);
    wind.set_border(false);
    wind.end();
    wind.show();

    wind.handle({
        let mut x = 0;
        let mut y = 0;
        move |w, ev| match ev {
            enums::Event::Push =&gt; {
                let coords = app::event_coords();
                x = coords.0;
                y = coords.1;
                true
            }
            enums::Event::Drag =&gt; {
                w.set_pos(app::event_x_root() - x, app::event_y_root() - y);
                true
            }
            _ =&gt; false,
        }
    });

    app.run().unwrap();
}</code></pre></pre>
<h2 id="dragging-files"><a class="header" href="#dragging-files">Dragging Files</a></h2>
<p>Dragging a file into an application basically invokes the Paste event, and fills the app::event_text() with the path of the file. So when we handle dragging, we want to capture the path in Event::Paste, check if the file exists, read its content and fill our text widget:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, enums::Event, *};

fn main() {
    let app = app::App::default();
    let buf = text::TextBuffer::default();
    let mut wind = window::Window::default().with_size(400, 400);
    let mut disp = text::TextDisplay::default_fill();
    wind.end();
    wind.show();

    disp.set_buffer(buf.clone());
    disp.handle({
        let mut dnd = false;
        let mut released = false;
        let buf = buf.clone();
        move |_, ev| match ev {
            Event::DndEnter =&gt; {
                dnd = true;
                true
            }
            Event::DndDrag =&gt; true,
            Event::DndRelease =&gt; {
                released = true;
                true
            }
            Event::Paste =&gt; {
                if dnd &amp;&amp; released {
                    let path = app::event_text();
                    let path = path.trim();
                    let path = path.replace("file://", "");
                    let path = std::path::PathBuf::from(&amp;path);
                    if path.exists() {
                        // we use a timeout to avoid pasting the path into the buffer
                        app::add_timeout3(0.0, {
                            let mut buf = buf.clone();
                            move |_| {
                                buf.load_file(&amp;path).unwrap();
                            }
                        });
                    }
                    dnd = false;
                    released = false;
                    true
                } else {
                    false
                }
            }
            Event::DndLeave =&gt; {
                dnd = false;
                released = false;
                true
            }
            _ =&gt; false,
        }
    });
    app.run().unwrap();
}</code></pre></pre>
<p>If you're not interested in the contents of the file, you can just take the path and show it to the user:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, enums::Event, *};

fn main() {
    let app = app::App::default();
    let buf = text::TextBuffer::default();
    let mut wind = window::Window::default().with_size(400, 400);
    let mut disp = text::TextDisplay::default_fill();
    wind.end();
    wind.show();

    disp.set_buffer(buf.clone());
    disp.handle({
        let mut dnd = false;
        let mut released = false;
        let mut buf = buf.clone();
        move |_, ev| match ev {
            Event::DndEnter =&gt; {
                dnd = true;
                true
            }
            Event::DndDrag =&gt; true,
            Event::DndRelease =&gt; {
                released = true;
                true
            }
            Event::Paste =&gt; {
                if dnd &amp;&amp; released {
                    let path = app::event_text();
                    buf.append(&amp;path);
                    dnd = false;
                    released = false;
                    true
                } else {
                    false
                }
            }
            Event::DndLeave =&gt; {
                dnd = false;
                released = false;
                true
            }
            _ =&gt; false,
        }
    });
    app.run().unwrap();
}</code></pre></pre>
<h2 id="dragging-to-draw"><a class="header" href="#dragging-to-draw">Dragging to draw</a></h2>
<p>You can draw inside events, but you'll want to use offscreen drawing. In the widgets draw method, you just copy the offscreen content into the widget. A more detailed example can be seen here in the Offscreen drawing section in the <a href="Drawing.html#offscreen-drawing">Drawing page</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-management"><a class="header" href="#state-management">State management</a></h1>
<p>FLTK doesn't impose a certain form of state management or app architecture. This is left to the user. All the examples in the fltk-rs repo and this book already use either callbacks or messages, you'll find many examples of both methods.
Those were discussed in the <a href="Events.html">events page</a>.</p>
<p>Also all the examples might appear to handle everything in the main function, this is only for simplicity. You can create your own App struct, include the main window in it and the state of your app:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

#[derive(Copy, Clone)]
enum Message {
    Inc,
    Dec,
}

struct MyApp {
    app: app::App,
    main_win: window::Window,
    frame: frame::Frame,
    count: i32,
    receiver: app::Receiver&lt;Message&gt;,
}

impl MyApp {
    pub fn new() -&gt; Self {
        let count = 0;
        let app = app::App::default();
        let (s, receiver) = app::channel();
        let mut main_win = window::Window::default().with_size(400, 300);
        let col = group::Flex::default()
            .with_size(100, 200)
            .column()
            .center_of_parent();
        let mut inc = button::Button::default().with_label("+");
        inc.emit(s, Message::Inc);
        let frame = frame::Frame::default().with_label(&amp;count.to_string());
        let mut dec = button::Button::default().with_label("-");
        dec.emit(s, Message::Dec);
        col.end();
        main_win.end();
        main_win.show();
        Self {
            app,
            main_win,
            frame,
            count,
            receiver,
        }
    }

    pub fn run(mut self) {
        while self.app.wait() {
            if let Some(msg) = self.receiver.recv() {
                match msg {
                    Message::Inc =&gt; self.count += 1,
                    Message::Dec =&gt; self.count -= 1,
                }
                self.frame.set_label(&amp;self.count.to_string());
            }
        }
    }
}

fn main() {
    let a = MyApp::new();
    a.run();
}</code></pre></pre>
<h2 id="helper-crates"><a class="header" href="#helper-crates">Helper crates</a></h2>
<p>The crates ecosystem offers many crates which provide state management. Also there are 2 crates under the fltk-rs org which offer means of architecting your app and managing its state:</p>
<ul>
<li><a href="https://github.com/fltk-rs/flemish">flemish</a>:</li>
</ul>
<p>Offers an Elm like SVU architecture. This is reactive, immutable in essence, and tears down the view which each Message.</p>
<ul>
<li><a href="https://github.com/fltk-rs/fltk-evented">fltk-evented</a>:</li>
</ul>
<p>This resembles immediate-mode guis in that all events are handled in the event loop. In reality it's also reactive but mutable and stateless. This doesn't cause a redraw with triggers.</p>
<p>Both crates avoid the use of callbacks since these can be a pain in Rust in terms of lifetimes and borrowing. You need to use shared smart pointers with interior mutability to be able to borrow into a callback.</p>
<p>You can take a look at both crates for inspiration.</p>
<p>A sample counter in both:</p>
<h2 id="flemish"><a class="header" href="#flemish">Flemish</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use flemish::{
    button::Button, color_themes, frame::Frame, group::Flex, prelude::*, OnEvent, Sandbox, Settings,
};

pub fn main() {
    Counter::new().run(Settings {
        size: (300, 100),
        resizable: true,
        color_map: Some(color_themes::BLACK_THEME),
        ..Default::default()
    })
}

#[derive(Default)]
struct Counter {
    value: i32,
}

#[derive(Debug, Clone, Copy)]
enum Message {
    IncrementPressed,
    DecrementPressed,
}

impl Sandbox for Counter {
    type Message = Message;

    fn new() -&gt; Self {
        Self::default()
    }

    fn title(&amp;self) -&gt; String {
        String::from("Counter - fltk-rs")
    }

    fn update(&amp;mut self, message: Message) {
        match message {
            Message::IncrementPressed =&gt; {
                self.value += 1;
            }
            Message::DecrementPressed =&gt; {
                self.value -= 1;
            }
        }
    }

    fn view(&amp;mut self) {
        let col = Flex::default_fill().column();
        Button::default()
            .with_label("Increment")
            .on_event(Message::IncrementPressed);
        Frame::default().with_label(&amp;self.value.to_string());
        Button::default()
            .with_label("Decrement")
            .on_event(Message::DecrementPressed);
        col.end();
    }
}</code></pre></pre>
<h2 id="fltk-evented"><a class="header" href="#fltk-evented">fltk-evented</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, button::Button, frame::Frame, group::Flex, prelude::*, window::Window};
use fltk_evented::Listener;

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    app::set_font_size(20);

    let mut wind = Window::default()
        .with_size(160, 200)
        .center_screen()
        .with_label("Counter");
    let flex = Flex::default()
        .with_size(120, 160)
        .center_of_parent()
        .column();
    let but_inc: Listener&lt;_&gt; = Button::default().with_label("+").into();
    let mut frame = Frame::default();
    let but_dec: Listener&lt;_&gt; = Button::default().with_label("-").into();
    flex.end();
    wind.end();
    wind.show();

    let mut val = 0;
    frame.set_label(&amp;val.to_string());

    while a.wait() {
        if but_inc.triggered() {
            val += 1;
            frame.set_label(&amp;val.to_string());
        }

        if but_dec.triggered() {
            val -= 1;
            frame.set_label(&amp;val.to_string());
        }
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layouts"><a class="header" href="#layouts">Layouts</a></h1>
<p>Out of the box, fltk-rs offers:</p>
<ul>
<li>A Flex widget</li>
<li>Pack</li>
<li>Grid</li>
<li>Widget relative positioning.</li>
</ul>
<h3 id="flex"><a class="header" href="#flex">Flex</a></h3>
<p>The Flex widget allows flexbox layouts. It's in group module and implements the GroupExt trait. There are 2 forms of Flex widgets, which can be specified using the set_type or with_type methods. These are the column and row:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut win = window::Window::default().with_size(400, 300);
    let mut flex = group::Flex::new(0, 0, 400, 300, None);
    flex.set_type(group::FlexType::Column);
    let expanding = button::Button::default().with_label("Expanding");
    let normal = button::Button::default().with_label("Normal");
    flex.fixed(&amp;normal, 30);
    flex.end();
    win.end();
    win.show();
    a.run().unwrap();
}</code></pre></pre>
<p>The <code>fixed</code> (and <code>set_size</code> in fltk &lt; 1.4.6) method takes another widget and fixes its size to the value passed, in the example it's 30. Since this is a column, the 30 represents the height of the widget to be set.
The other widget will be expandable since no size is set for it. A full example can be found here:</p>
<p><a href="https://github.com/fltk-rs/fltk-rs/blob/master/fltk/examples/flex.rs">Flex example</a></p>
<p><img src="https://github.com/osen/FL_Flex/raw/main/doc/login.png" alt="image" /></p>
<h3 id="packs"><a class="header" href="#packs">Packs</a></h3>
<p>The Pack widget (in the group module) also implement the GroupExt trait. There are 2 forms of packs, Vertical and Horizontal packs, Vertical being the default. Vertical packs only require the height of its children widgets, while horizontal packs only require the width of its children widgets, like in the example below:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::default().with_size(400, 300);
    let mut hpack = group::Pack::default().with_size(190, 40).center_of(&amp;my_window);
    hpack.set_type(group::PackType::Horizontal);
    hpack.set_spacing(30);
    let _but1 = button::Button::default().with_size(80, 0).with_label("Button1");
    let _but2 = button::Button::default().with_size(80, 0).with_label("Button2");
    hpack.end();
    my_window.end();
    my_window.show();

    app.run().unwrap();
}</code></pre></pre>
<p>This creates a pack widget inside the window, and fills it with 2 buttons. Notice that the x and y coordinates are no longer needed for the buttons. You can also embed packs inside packs like in the calculator example in the repo.
You can also use the Pack::auto_layout() method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    
    let mut my_window = window::Window::default().with_size(400, 300);
    let mut hpack = group::Pack::new(0, 200, 400, 100, "");
    hpack.set_type(group::PackType::Horizontal);
    hpack.set_spacing(30);
    let _but1 = button::Button::default().with_label("Button1");
    let _but2 = button::Button::default().with_label("Button2");
    hpack.end();
    hpack.auto_layout();
    my_window.end();
    my_window.show();

    app.run().unwrap();
}</code></pre></pre>
<p>In which case we don't even need the size of the buttons.</p>
<p><img src="https://user-images.githubusercontent.com/37966791/100937983-ef8bf400-3504-11eb-9da1-09c5ac1aade4.png" alt="image" /></p>
<h3 id="grid"><a class="header" href="#grid">Grid</a></h3>
<p><a href="https://github.com/fltk-rs/fltk-grid">Grid</a> is implemented currently in an external crate. It requires a layout which is set using <code>Grid::set_layout(&amp;mut self, rows, columns)</code>. Then widgets are inserted via the <code>Grid::insert(&amp;mut self, row, column)</code> or <code>Grid::insert_ext(&amp;mut self, row, column, row_span, column_span)</code> methods:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};
use fltk_grid::Grid;

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Gtk);
    let mut win = window::Window::default().with_size(500, 300);
    let mut grid = Grid::default_fill();
    // set to true to show cell outlines and numbers
    grid.debug(false); 
    // 5 rows, 5 columns
    grid.set_layout(5, 5); 
    // widget, row, col
    grid.insert(&amp;mut button::Button::default().with_label("Click"), 0, 1); 
    // widget, row, col, row_span, col_span
    grid.insert_ext(&amp;mut button::Button::default().with_label("Button 2"), 2, 1, 3, 1); 
    win.end();
    win.show();
    a.run().unwrap();
}</code></pre></pre>
<p><a href="https://github.com/fltk-rs/fltk-grid/blob/main/examples/form.rs">Grid example</a></p>
<p><img src="https://user-images.githubusercontent.com/37966791/160347418-b8b54408-3dc9-4fc4-93e8-fb6c1c0282e9.png" alt="image" /></p>
<h3 id="relative-positioning"><a class="header" href="#relative-positioning">Relative positioning</a></h3>
<p>The WidgetExt trait offers several constructor methods which allow us to construct widgets relative to other widgets size and position. This is similar to Qml's anchoring.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default();
    let mut wind = window::Window::default()
        .with_size(160, 200)
        .center_screen()
        .with_label("Counter");
    let mut frame = frame::Frame::default()
        .with_size(100, 40)
        .center_of(&amp;wind)
        .with_label("0");
    let mut but_inc = button::Button::default()
        .size_of(&amp;frame)
        .above_of(&amp;frame, 0)
        .with_label("+");
    let mut but_dec = button::Button::default()
        .size_of(&amp;frame)
        .below_of(&amp;frame, 0)
        .with_label("-");
    wind.end();
    wind.show();
    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/counter.jpg" alt="counter" /></p>
<p>(With some skipped theming)</p>
<p>These methods are namely:</p>
<ul>
<li><code>above_of(&amp;widget, padding)</code>: places the widget above the passed widget</li>
<li><code>below_of(&amp;widget, padding)</code>: places the widget below the passed widget</li>
<li><code>right_of(&amp;widget, padding)</code>: places the widget right of the passed widget</li>
<li><code>left_of(&amp;widget, padding)</code>: places the widget left of the passed widget</li>
<li><code>center_of(&amp;widget)</code>: places the widget at the center (both x and y axes) of the passed widget.</li>
<li><code>center_of_parent()</code>: places the widget at the center (both x and y axes) of the parent.</li>
<li><code>center_x(&amp;widget)</code>: places the widget at the center (x-axis) of the passed widget.</li>
<li><code>center_y(&amp;widget)</code>: places the widget at the center (y-axis) of the passed widget.</li>
<li><code>size_of(&amp;widget)</code>: constructs the widget with the same size of the passed widget.</li>
<li><code>size_of_parent()</code>: constructs the widget with the same size of its parent.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="style"><a class="header" href="#style">Style</a></h1>
<p>FLTK offers extensive custom styling options for your application, from changing the app's general scheme, to customizing colors, fonts, frame types, custom drawing...etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="colors"><a class="header" href="#colors">Colors</a></h1>
<p>FLTK can handle <a href="https://en.wikipedia.org/wiki/Color_depth#True_color_(24-bit)">true color</a>. Some convenience colors are made available in the enums::Color enum:</p>
<ul>
<li>Black</li>
<li>White</li>
<li>Red</li>
<li>Blue</li>
<li>Cyan
...etc.</li>
</ul>
<p>You can also construct your colors using Color methods:</p>
<ul>
<li>by_index(). This uses fltk's colormap. Values range from 0 to 255:</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let red = Color::by_index(88);
<span class="boring">}</span></code></pre></pre>
<p><img src="https://www.fltk.org/doc-1.3/fltk-colormap.png" alt="colormap" /></p>
<ul>
<li>from_hex(). This takes a 24-bit hex value in the form RGB:</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RED: Color = Color::from_hex(0xff0000); // notice it's a const functions
<span class="boring">}</span></code></pre></pre>
<ul>
<li>from_rgb(). This takes 3 values r, g, b:</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const RED: Color = Color::from_rgb(255, 0, 0); // notice it's a const functions
<span class="boring">}</span></code></pre></pre>
<p>The Color enum also offers some convenience methods to generate different shades of the chosen color, using .darker(), .lighter(), .inactive() methods and others:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let col = Color::from_rgb(176, 100, 50).lighter();
<span class="boring">}</span></code></pre></pre>
<p>If you prefer html hex string colors, you can use the from_hex_str() method:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let col = Color::from_hex_str("#ff0000");
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frametypes"><a class="header" href="#frametypes">FrameTypes</a></h1>
<p>FLTK has a wide range of frame types. These can be found under the enums module:
<img src="https://github.com/fltk-rs/fltk-rs/raw/master/screenshots/frames.jpg" alt="image" /></p>
<p>These can be set using WidgetExt::set_frame(). Some widgets/traits also support set_down_frame():</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, enums::FrameType, frame::Frame, image::SvgImage, prelude::*, window::Window};

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gleam);
    let mut wind = Window::new(100, 100, 400, 300, "Hello from rust");

    let mut frame = Frame::default().with_size(360, 260).center_of(&amp;wind);
    frame.set_frame(FrameType::EngravedBox);
    let mut image = SvgImage::load("screenshots/RustLogo.svg").unwrap();
    image.scale(200, 200, true, true);
    frame.set_image(Some(image));

    wind.make_resizable(true);
    wind.end();
    wind.show();

    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-rs/raw/master/screenshots/hello.jpg" alt="image" />
Here we set the frame's FrameType to EngravedBox, which you can see around the image.</p>
<p>ButtonExt supports set_down_frame():</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>btn1.set_frame(enums::FrameType::RFlatBox);
btn1.set_down_frame(enums::FrameType::RFlatBox);
<span class="boring">}</span></code></pre></pre>
<p>Furthermore, we can change the draw routine for our FrameTypes using app::set_frame_type_cb():</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    enums::{Color, FrameType},
    prelude::*,
    *
};

fn down_box(x: i32, y: i32, w: i32, h: i32, c: Color) {
    draw::draw_box(FrameType::RFlatBox, x, y, w, h, Color::BackGround2);
    draw::draw_box(FrameType::RoundedFrame, x - 10, y, w + 20, h, c);
}

fn main() {
    let app = app::App::default();
    app::set_frame_type_cb(FrameType::DownBox, down_box, 0, 0, 0, 0);
    let mut w = window::Window::default().with_size(480, 230).with_label("Gui");
    w.set_color(Color::from_u32(0xf5f5f5));

    let mut txf = input::Input::default().with_size(160, 30).center_of_parent();    
    txf.set_color(Color::Cyan.darker());

    w.show();

    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/146932070-ae63fd63-3f37-4d97-978e-4604d2bc0e4b.png" alt="image" /></p>
<p>This changes the default DownBox with a custom down_box routine. We can also ImageExt::draw() inside our draw routines to draw images (Like svg images to get scalable rounded borders).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fonts"><a class="header" href="#fonts">Fonts</a></h1>
<p>FLTK has already 16 fonts which can be found in enums::Font:</p>
<ul>
<li>Helvetica</li>
<li>HelveticaBold</li>
<li>HelveticaItalic</li>
<li>HelveticaBoldItalic</li>
<li>Courier</li>
<li>CourierBold</li>
<li>CourierItalic</li>
<li>CourierBoldItalic</li>
<li>Times</li>
<li>TimesBold</li>
<li>TimesItalic</li>
<li>TimesBoldItalic</li>
<li>Symbol</li>
<li>Screen</li>
<li>ScreenBold</li>
<li>Zapfdingbats</li>
</ul>
<p>It also allows loading system and bundled fonts.</p>
<p>System fonts depend on the system, and are not loaded by default. These can be loaded using the App::load_system_fonts() method.
The fonts can then be acquired using the app::fonts() function or be queried using the app::font_count(), app::font_name() and app::font_index() functions.
And then can be used using the Font::by_index() or Font::by_name() methods.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};

fn main() {
    let app = app::App::default().load_system_fonts();
    // To load a font by path, check the App::load_font() method
    let fonts = app::fonts();
    // println!("{:?}", fonts);
    let mut wind = window::Window::default().with_size(400, 300);
    let mut frame = frame::Frame::default().size_of(&amp;wind);
    frame.set_label_size(30);
    wind.set_color(enums::Color::White);
    wind.end();
    wind.show();
    println!("The system has {} fonts!\nStarting slideshow!", fonts.len());
    let mut i = 0;
    while app.wait() {
        if i == fonts.len() {
            i = 0;
        }
        frame.set_label(&amp;format!("[{}]", fonts[i]));
        frame.set_label_font(enums::Font::by_index(i));
        app::sleep(0.5);
        i += 1;
    }
}</code></pre></pre>
<p>If you would like to load a bundled font without it being in the system, you can alternatively use Font::load_font() and Font::set_font(), this allows you to replace one of FLTK's predefined fonts with a custom font:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, enums::Font, button::Button, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();

    let font = Font::load_font("angelina.ttf").unwrap();
    Font::set_font(Font::Helvetica, &amp;font);
    app::set_font_size(24);

    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, "Click me!");
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label("Hello world"));

    app.run().unwrap();
}</code></pre></pre>
<p>load_font() loads the font from the .ttf file, set_font() replaces Font::Helvetica (FLTK's default font) with our loaded font.</p>
<p><img src="https://user-images.githubusercontent.com/37966791/145735197-130f7dd6-a31f-4bc6-a362-90a13493a556.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drawing-things"><a class="header" href="#drawing-things">Drawing things</a></h1>
<p>fltk-rs provides free functions in the draw module which allow you to draw custom elements. The drawing works only if the calls are done in a context which allows drawing, such as in the WidgetBase::draw() method or in an Offscreen context:</p>
<h2 id="drawing-in-widgets"><a class="header" href="#drawing-in-widgets">Drawing in widgets</a></h2>
<p>Notice we use the draw calls inside our widget's draw method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{enums, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.end();
    win.show();

    win.draw(|w| {
        use draw::*;
        // fill the window white
        draw_rect_fill(0, 0, w.w(), w.h(), enums::Color::White);
        // draw a blue pie
        set_draw_color(enums::Color::Blue.inactive());
        draw_pie(w.w() / 2 - 50, w.h() / 2 - 50, 100, 100, 0.0, 360.0);
        // draw angled red text
        set_draw_color(enums::Color::Red);
        set_font(enums::Font::Courier, 16);
        draw_text_angled(45, "Hello World", w.w() / 2, w.h() / 2);
    });

    a.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145693473-defb2298-fc6b-4d2f-8a0c-3d4902b39dd3.jpg" alt="draw" /></p>
<p>We've used the whole window as our canvas, but it can be any widget as well. Other available functions allow drawing lines, rects, arcs, pies, loops, polygons, even images.</p>
<h2 id="offscreen-drawing"><a class="header" href="#offscreen-drawing">Offscreen drawing</a></h2>
<p>Sometimes you would like to draw things in response to events, such as when the patients pushes and drags the cursor. In this case, you can use a draw::Offscreen to do that. In that case, we use the widget's draw method to just copy the Offscreen contents, while we do our drawing in the widget's handle method:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    app,
    draw::{
        draw_line, draw_point, draw_rect_fill, set_draw_color, set_line_style, LineStyle, Offscreen,
    },
    enums::{Color, Event, FrameType},
    frame::Frame,
    prelude::*,
    window::Window,
};
use std::cell::RefCell;
use std::rc::Rc;

const WIDTH: i32 = 800;
const HEIGHT: i32 = 600;

fn main() {
    let app = app::App::default().with_scheme(app::Scheme::Gtk);

    let mut wind = Window::default()
        .with_size(WIDTH, HEIGHT)
        .with_label("RustyPainter");
    let mut frame = Frame::default()
        .with_size(WIDTH - 10, HEIGHT - 10)
        .center_of(&amp;wind);
    frame.set_color(Color::White);
    frame.set_frame(FrameType::DownBox);

    wind.end();
    wind.show();

    // We fill our offscreen with white
    let offs = Offscreen::new(frame.width(), frame.height()).unwrap();
    #[cfg(not(target_os = "macos"))]
    {
        offs.begin();
        draw_rect_fill(0, 0, WIDTH - 10, HEIGHT - 10, Color::White);
        offs.end();
    }

    let offs = Rc::from(RefCell::from(offs));

    frame.draw({
        let offs = offs.clone();
        move |_| {
            let mut offs = offs.borrow_mut();
            if offs.is_valid() {
                offs.rescale();
                offs.copy(5, 5, WIDTH - 10, HEIGHT - 10, 0, 0);
            } else {
                offs.begin();
                draw_rect_fill(0, 0, WIDTH - 10, HEIGHT - 10, Color::White);
                offs.copy(5, 5, WIDTH - 10, HEIGHT - 10, 0, 0);
                offs.end();
            }
        }
    });

    frame.handle({
        let mut x = 0;
        let mut y = 0;
        move |f, ev| {
            // println!("{}", ev);
            // println!("coords {:?}", app::event_coords());
            // println!("get mouse {:?}", app::get_mouse());
            let offs = offs.borrow_mut();
            match ev {
                Event::Push =&gt; {
                    offs.begin();
                    set_draw_color(Color::Red);
                    set_line_style(LineStyle::Solid, 3);
                    let coords = app::event_coords();
                    x = coords.0;
                    y = coords.1;
                    draw_point(x, y);
                    offs.end();
                    f.redraw();
                    set_line_style(LineStyle::Solid, 0);
                    true
                }
                Event::Drag =&gt; {
                    offs.begin();
                    set_draw_color(Color::Red);
                    set_line_style(LineStyle::Solid, 3);
                    let coords = app::event_coords();
                    draw_line(x, y, coords.0, coords.1);
                    x = coords.0;
                    y = coords.1;
                    offs.end();
                    f.redraw();
                    set_line_style(LineStyle::Solid, 0);
                    true
                }
                _ =&gt; false,
            }
        }
    });

    app.run().unwrap();
}</code></pre></pre>
<p>Notice how we open an Offscreen context using offs.begin() then close it with offs.end(). This allows us to call drawing functions inside the Offscreen.</p>
<p><img src="https://user-images.githubusercontent.com/37966791/146173813-67038a94-7739-480e-a181-29498aac842a.png" alt="image" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="styling"><a class="header" href="#styling">Styling</a></h1>
<p>FLTK has a lot to offer in terms of styling applications. We have already seen that we can use true color and different fonts, in addition to draw custom things. Styling is making use of all that. It can be done per widget leveraging the methods in WidgetExt, or globally using functions in the app module.</p>
<h2 id="widgetext"><a class="header" href="#widgetext">WidgetExt</a></h2>
<p>Most of the WidgetExt trait is related to modifying the frame type, label type, widget color, text color, text font and text size.
These all have setters and getters which can be found <a href="https://docs.rs/fltk/*/fltk/prelude/trait.WidgetExt.html">here</a>.</p>
<p>An example of this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{
    enums::{Align, Color, Font, FrameType},
    prelude::*,
    *,
};

const BLUE: Color = Color::from_hex(0x42A5F5);
const SEL_BLUE: Color = Color::from_hex(0x2196F3);
const GRAY: Color = Color::from_hex(0x757575);
const WIDTH: i32 = 600;
const HEIGHT: i32 = 400;

fn main() {
    let app = app::App::default();
    let mut win = window::Window::default()
        .with_size(WIDTH, HEIGHT)
        .with_label("Flutter-like!");
    let mut bar =
        frame::Frame::new(0, 0, WIDTH, 60, "  FLTK App!").with_align(Align::Left | Align::Inside);
    let mut text = frame::Frame::default()
        .with_size(100, 40)
        .center_of(&amp;win)
        .with_label("You have pushed the button this many times:");
    let mut count = frame::Frame::default()
        .size_of(&amp;text)
        .below_of(&amp;text, 0)
        .with_label("0");
    let mut but = button::Button::new(WIDTH - 100, HEIGHT - 100, 60, 60, "@+6plus");
    win.end();
    win.make_resizable(true);
    win.show();

    // Theming
    app::background(255, 255, 255);
    app::set_visible_focus(false);

    bar.set_frame(FrameType::FlatBox);
    bar.set_label_size(22);
    bar.set_label_color(Color::White);
    bar.set_color(BLUE);
    bar.draw(|b| {
        draw::set_draw_rgb_color(211, 211, 211);
        draw::draw_rectf(0, b.height(), b.width(), 3);
    });

    text.set_label_size(18);
    text.set_label_font(Font::Times);

    count.set_label_size(36);
    count.set_label_color(GRAY);

    but.set_color(BLUE);
    but.set_selection_color(SEL_BLUE);
    but.set_label_color(Color::White);
    but.set_frame(FrameType::OFlatFrame);
    // End theming

    but.set_callback(move |_| {
        let label = (count.label().parse::&lt;i32&gt;().unwrap() + 1).to_string();
        count.set_label(&amp;label);
    });

    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://github.com/MoAlyousef/fltk-rs/raw/master/screenshots/flutter_like.jpg" alt="counter" /></p>
<p>Widgets also support showing images within them, which is discussed more in the Images section.</p>
<h2 id="global-styling"><a class="header" href="#global-styling">Global styling</a></h2>
<p>These can be found in the app module. Starting from changing the app's scheme:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, enums::*, *};
let app = app::App::default().with_scheme(app::Scheme::Plastic);
<span class="boring">}</span></code></pre></pre>
<p>There are four schemes:</p>
<ul>
<li>Base</li>
<li>Gtk</li>
<li>Gleam</li>
<li>Plastic</li>
</ul>
<p>To setting the app's colors, default font, default frame type and whether to show focus on widgets.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{app, button::Button, enums, frame::Frame, prelude::*, window::Window};

fn main() {
    let app = app::App::default();
    app::set_background_color(170, 189, 206);
    app::set_background2_color(255, 255, 255);
    app::set_foreground_color(0, 0, 0);
    app::set_selection_color(255, 160,  63);
    app::set_inactive_color(130, 149, 166);
    app::set_font(enums::Font::Times);
    
    let mut wind = Window::default().with_size(400, 300);
    let mut frame = Frame::default().with_size(200, 100).center_of(&amp;wind);
    let mut but = Button::new(160, 210, 80, 40, "Click me!");
    wind.end();
    wind.show();

    but.set_callback(move |_| frame.set_label("Hello world"));

    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/145727821-5923fcd4-3a57-4a15-b36f-574b3e5321ea.png" alt="image" /></p>
<h3 id="custom-drawing"><a class="header" href="#custom-drawing">Custom Drawing</a></h3>
<p>FLTK also offers drawing primitives which makes giving a widget a custom appearance quite easy. This is done using the draw() method which takes a closure. Lets draw our own button, even though FLTK offers a ShadowFrame FrameType, let's create our own:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, enums::*, *};

fn main() {
    let app = app::App::default();
    app::set_color(255, 255, 255); // white
    let mut my_window = window::Window::new(100, 100, 400, 300, "My Window");

    let mut but = button::Button::default()
        .with_pos(160, 210)
        .with_size(80, 40)
        .with_label("Button1");

    but.draw2(|b| {
        draw::set_draw_color(Color::Gray0);
        draw::draw_rectf(b.x() + 2, b.y() + 2, b.width(), b.height());
        draw::set_draw_color(Color::from_u32(0xF5F5DC));
        draw::draw_rectf(b.x(), b.y(), b.width(), b.height());
        draw::set_draw_color(Color::Black);
        draw::draw_text2(
            &amp;b.label(),
            b.x(),
            b.y(),
            b.width(),
            b.height(),
            Align::Center,
        );
    });

    my_window.end();
    my_window.show();

    app.run().unwrap();
}</code></pre></pre>
<p><img src="https://user-images.githubusercontent.com/37966791/100938232-62956a80-3505-11eb-888f-ffe655e7aadc.jpg" alt="draw" /></p>
<p>The draw() method also supports drawing images inside of widgets as will be seen in the next section.</p>
<h2 id="fltk-theme"><a class="header" href="#fltk-theme">fltk-theme</a></h2>
<p>This is a <a href="https://github.com/fltk-rs/fltk-theme">crate</a> which provides several predefined themes which can be used by just loading the theme:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{prelude::*, *};
use fltk_theme::{widget_themes, WidgetTheme, ThemeType};

fn main() {
    let a = app::App::default();
    let widget_theme = WidgetTheme::new(ThemeType::Aero);
    widget_theme.apply();
    let mut win = window::Window::default().with_size(400, 300);
    let mut btn = button::Button::new(160, 200, 80, 30, "Hello");
    btn.set_frame(widget_themes::OS_DEFAULT_BUTTON_UP_BOX);
    win.end();
    win.show();
    a.run().unwrap();
}</code></pre></pre>
<p><img src="https://github.com/fltk-rs/fltk-theme/raw/main/screenshots/aqua_classic.jpg" alt="aqua-classic" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animations"><a class="header" href="#animations">Animations</a></h1>
<p>Animations can be shown in fltk-rs using several mechanism:</p>
<ul>
<li>Leveraging the event loop</li>
<li>Spawning threads</li>
<li>Timeouts</li>
</ul>
<h2 id="leveraging-the-event-loop"><a class="header" href="#leveraging-the-event-loop">Leveraging the event loop</a></h2>
<p>fltk offers app::wait() and app::check() which allow updating the ui during a blocking operation:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{enums::*, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    // our button takes the whole left side of the window
    let mut sliding_btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut sliding_btn);
    win.end();
    win.show();

    sliding_btn.set_callback(|btn| {
        if btn.w() &gt; 0 &amp;&amp; btn.w() &lt; 100 {
            return; // we're still animating
        }
        while btn.w() != 0 {
            btn.set_size(btn.w() - 2, btn.h());
            app::sleep(0.016);
            btn.parent().unwrap().redraw();
            app::wait(); // or app::check();
        }
    });
    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}</code></pre></pre>
<h2 id="spawning-threads"><a class="header" href="#spawning-threads">Spawning threads</a></h2>
<p>This ensures we don't block the main/ui thread:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{enums::*, prelude::*, *};

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    // our button takes the whole left side of the window
    let mut sliding_btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut sliding_btn);
    win.end();
    win.show();

    sliding_btn.set_callback(|btn| {
        if btn.w() &gt; 0 &amp;&amp; btn.w() &lt; 100 {
            return; // we're still animating
        }
        std::thread::spawn({
            let mut btn = btn.clone();
            move || {
                while btn.w() != 0 {
                    btn.set_size(btn.w() - 2, btn.h());
                    app::sleep(0.016);
                    app::awake(); // to awaken the ui thread
                    btn.parent().unwrap().redraw();
                }
            }
        });
    });
    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}</code></pre></pre>
<h2 id="timeouts"><a class="header" href="#timeouts">Timeouts</a></h2>
<p>fltk offers timeouts for recurring operations. We can add a timeout, repeat it and remove it:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use fltk::{enums::*, prelude::*, *};

fn move_button(mut btn: button::Button, handle: app::TimeoutHandle) {
    btn.set_size(btn.w() - 2, btn.h());
    btn.parent().unwrap().redraw();
    if btn.w() == 20 {
        app::remove_timeout3(handle);
    } else {
        app::repeat_timeout3(0.016, handle);
    }
}

fn main() {
    let a = app::App::default();
    let mut win = window::Window::default().with_size(400, 300);
    win.set_color(Color::White);
    let mut btn = button::Button::new(0, 0, 100, 300, None);
    style_btn(&amp;mut btn);
    btn.clear_visible_focus();
    win.end();
    win.show();

    btn.set_callback(|b| {
        let btn = b.clone();
        app::add_timeout3(0.016, move |handle| {
            let btn = btn.clone();
            move_button(btn, handle)
        });
    });

    a.run().unwrap();
}

fn style_btn(btn: &amp;mut button::Button) {
    btn.set_color(Color::from_hex(0x42A5F5));
    btn.set_selection_color(Color::from_hex(0x42A5F5));
    btn.set_frame(FrameType::FlatBox);
}</code></pre></pre>
<p>We basically add the timeout when the user clicks the button, and depending on the size of the button we either repeat it or remove it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accessibility"><a class="header" href="#accessibility">Accessibility</a></h1>
<p>FLTK offers several accessibility features out of the box:</p>
<h2 id="keyboard-navigation-among-and-within-ui-elements"><a class="header" href="#keyboard-navigation-among-and-within-ui-elements">Keyboard navigation among and within ui elements</a></h2>
<p>This is automatically enabled by FLTK.
Depending on the order of widget creation, and whether a widget receives focus, you can use the arrow keys or the tab and shift-tab keys to navigate to the next/previous widget.
Similarly for menu items, you can navigate using the keyboard.</p>
<h2 id="keyboard-shortcuts"><a class="header" href="#keyboard-shortcuts">Keyboard shortcuts</a></h2>
<p>Button widgets and Menu widgets provide a method which allows setting the keyboard shortcut:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, *};

let mut menu = menu::MenuBar::default().with_size(800, 35);
menu.add(
    "&amp;File/New...\t",
    Shortcut::Ctrl | 'n',
    menu::MenuFlag::Normal,
    |_m| {},
);

let mut btn = button::Button::new(100, 100, 80, 30, "Click me");
btn.set_shortcut(enums::Shortcut::Ctrl | 'b');
<span class="boring">}</span></code></pre></pre>
<h2 id="keyboard-alternatives-to-pointer-actions"><a class="header" href="#keyboard-alternatives-to-pointer-actions">Keyboard alternatives to pointer actions</a></h2>
<p>This is automatically enabled by FLTK.
Depending on whether an item has a by default CallbackTrigger::EnterKey trigger, or the trigger is set using <code>set_trigger</code>, it should fire the callback when the enter key is pressed.
Buttons, for example, respond to the enter key automatically if they have focus. To change the trigger for a widget:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, *};

let mut inp = input::Input::new(10, 10, 160, 30, None);
inp.set_trigger(enums::CallbackTrigger::EnterKey);
inp.set_callback(|i| println!("You clicked enter, and the input's current text is: {}", i.value()));
<span class="boring">}</span></code></pre></pre>
<h2 id="ime-support"><a class="header" href="#ime-support">IME support</a></h2>
<p>The input method editor is automatically enabled for languages which require it like Chinese, Japanese and Korean. FLTK uses the OS provided IME in this case.</p>
<h2 id="keyboard-screen-scaling"><a class="header" href="#keyboard-screen-scaling">Keyboard screen scaling</a></h2>
<p>Similar to many web browsers, FLTK has 3 default global shortcuts (Ctrl/+/-/0/ [Cmd/+/-/0/ under macOS]) that change the value of the GUI scaling factor. Ctrl+ zooms-in all app windows of the focussed display (all displays under macOS); Ctrl- zooms-out these windows; Ctrl 0 restores the initial value of the scaling factor.</p>
<h2 id="the-ability-to-customize-key-events-for-your-widgets-even-custom-widgets"><a class="header" href="#the-ability-to-customize-key-events-for-your-widgets-even-custom-widgets">The ability to customize key events for your widgets, even custom widgets</a></h2>
<p>Using the WidgetExt::handle method, you can customize how widgets handle events, including key events.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use fltk::{prelude::*, *};

let mut win = window::Window::default().with_size(400, 300);
win.handle(|w, ev| {
    enums::Event::KeyUp =&gt; {
        let key = app::event_key();
        match key {
            enums::Key::End =&gt; app::quit(), // just an example
            _ =&gt; {
                if let Some(k) = key.to_char() {
                    match k {
                        'q' =&gt; app::quit(),
                        _ =&gt; (),
                    }
                }
            },
        }
        true
    }, 
    _ =&gt; false,
});
<span class="boring">}</span></code></pre></pre>
<h2 id="screen-reader-support"><a class="header" href="#screen-reader-support">Screen reader support</a></h2>
<p>Screen reader support is currently implemented as an external crate:</p>
<ul>
<li><a href="https://github.com/fltk-rs/fltk-accesskit">fltk-accesskit</a></li>
</ul>
<p>This uses the accesskit crate to complete the accessibility story for FLTK.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">#![windows_subsystem = "windows"]
use fltk::{prelude::*, *};
use fltk_accesskit::{AccessibilityContext, AccessibleApp};

fn main() {
    let a = app::App::default().with_scheme(app::Scheme::Oxy);
    let mut w = window::Window::default()
        .with_size(400, 300)
        .with_label("Hello fltk-accesskit");
    let col = group::Flex::default()
        .with_size(200, 100)
        .center_of_parent()
        .column();
    let inp = input::Input::default().with_id("inp").with_label("Enter name:");
    let mut btn = button::Button::default().with_label("Greet");
    let out = output::Output::default().with_id("out");
    col.end();
    w.end();
    w.make_resizable(true);
    w.show();

    btn.set_callback(btn_callback);

    let ac = AccessibilityContext::new(
        w,
        vec![Box::new(inp), Box::new(btn), Box::new(out)],
    );

    a.run_with_accessibility(ac).unwrap();
}

fn btn_callback(_btn: &amp;mut button::Button) {
    let inp: input::Input = app::widget_from_id("inp").unwrap();
    let mut out: output::Output = app::widget_from_id("out").unwrap();
    let name = inp.value();
    if name.is_empty() {
        return;
    }
    out.set_value(&amp;format!("Hello {}", name));
}</code></pre></pre>
<p>The Accessible trait is implemented for several FLTK widgets.
The example requires instantiating an fltk_accesskit::AccessibilityContext, in which you pass the root (main window) and the widgets you want recognized by the screen-reader.
Then you would run the App struct using the special method <code>run_with_accessibility</code>.</p>
<p>A demonstration video can be found <a href="https://www.youtube.com/watch?v=x53Rxjg8IF8">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="build-issues"><a class="header" href="#build-issues">Build issues</a></h2>
<h3 id="why-does-the-build-fails-when-i-follow-one-of-the-tutorials"><a class="header" href="#why-does-the-build-fails-when-i-follow-one-of-the-tutorials">Why does the build fails when I follow one of the tutorials?</a></h3>
<p>The first tutorial uses the fltk-bundled feature flag, which is only supported for certain platforms since these are built using the Github Actions CI, namely:</p>
<ul>
<li>Windows 10 x64 (msvc and gnu).</li>
<li>MacOS 12 x64 and aarch64.</li>
<li>Ubuntu 20.04 or later, x64 and aarch64.</li>
</ul>
<p>If you're not running one of the aforementioned platforms, you'll have to remove the fltk-bundled feature flag in your Cargo.toml file:</p>
<pre><code class="language-toml">[dependencies]
fltk = "^1.4"
</code></pre>
<p>Furthermore, the fltk-bundled flag assumes you have curl and tar installed (for Windows, they're available in the Native Tools Command Prompt).</p>
<h3 id="build-fails-on-windows-why-cant-cmake-find-my-toolchain"><a class="header" href="#build-fails-on-windows-why-cant-cmake-find-my-toolchain">Build fails on windows, why can't CMake find my toolchain?</a></h3>
<p>If you're building using the MSVC toolchain, make sure you run your build (at least your initial build) using the Native Tools Command Prompt, which should appear once you start typing "native" in the start menu, choose the version corresponding to your installed Rust toolchain (x86 or x64). The Native Tools Command Prompt has all the environment variables set correctly for native development. <a href="https://github.com/alexcrichton/cmake-rs">cmake-rs</a> which the bindings use might not be able to find the Visual Studio 2022 generator, in which case, you can try to use the fltk-bundled feature, or use ninja via the use-ninja feature. This requires installing <a href="https://github.com/ninja-build/ninja/wiki/Pre-built-Ninja-packages">Ninja</a> which can be installed with Chocolatey, Scoop or manually.</p>
<p>If you're building for the GNU toolchain, make sure that Make is also installed, which usually comes installed in mingw64 toolchain.</p>
<h3 id="build-fails-on-macos-11-with-an-apple-m1-chip-what-can-i-do"><a class="header" href="#build-fails-on-macos-11-with-an-apple-m1-chip-what-can-i-do">Build fails on MacOS 11 with an Apple M1 chip, what can I do?</a></h3>
<p>If you're getting "file too small to be an archive" error, you might be hitting this <a href="https://github.com/rust-lang/cargo/issues/8875">issues</a> or this <a href="https://github.com/rust-lang/rust/issues/50220">issue</a>. MacOS's native C/C++ toolchain shouldn't have this issue, and can be installed by running <code>xcode-select --install</code> or by installing XCode. Make sure the corresponding Rust toolchain (aarch64-apple-darwin) is installed as well. You can uninstall other Rust apple-darwin toolchains or use cargo-lipo instead if you need universal/fat binaries.</p>
<h3 id="why-do-i-get-a-link-error-while-using-the-mingw-toolchain-on-windows"><a class="header" href="#why-do-i-get-a-link-error-while-using-the-mingw-toolchain-on-windows">Why do I get a Link error while using the mingw toolchain on windows?</a></h3>
<p>If the linking fails because of this <a href="https://github.com/rust-lang/rust/issues/47048">issue</a> with older toolchains, it should work by using the fltk-shared feature (an issue with older compilers). Which would also generate a dynamic library which would need to be deployed with your application.</p>
<pre><code class="language-toml">[dependencies]
fltk = { version = "^1.4", features = ["fltk-shared"] }
</code></pre>
<h3 id="why-does-my-msys2-mingw-built-fltk-app-using-fltk-bundled-isnt-self-contained-and-requires-several-dlls"><a class="header" href="#why-does-my-msys2-mingw-built-fltk-app-using-fltk-bundled-isnt-self-contained-and-requires-several-dlls">Why does my msys2 mingw built fltk app using, fltk-bundled, isn't self-contained and requires several dlls?</a></h3>
<p>If you have installed libgdiplus via pacman, it would require those dependencies on other systems. If you're using the windows sdk-provided libgdiplus, it shouldn't require extra dlls. You can either uninstall libgdiplus that was installed via pacman, or or you can build using the feature flag: <code>no-gdiplus</code>.</p>
<h3 id="why-do-i-get-link-errors-when-i-use-the-system-fltk-feature"><a class="header" href="#why-do-i-get-link-errors-when-i-use-the-system-fltk-feature">Why do I get link errors when I use the system-fltk feature?</a></h3>
<p>This crate targets FLTK 1.4, while currently most distros distribute an older version of FLTK (1.3.5). You can try to install FLTK (C++) by building from source.</p>
<h3 id="build-fails-on-arch-linux-because-of-pango-or-cairo"><a class="header" href="#build-fails-on-arch-linux-because-of-pango-or-cairo">Build fails on Arch linux because of pango or cairo?</a></h3>
<p>Pango changed its include paths which caused build failures across many projects. There are 2 solutions:</p>
<ul>
<li>Use the no-pango feature. Downsides: loss of rtl and cjk language support.</li>
<li>Set the CFLAGS and CXXFLAGS to correct the global include paths.</li>
</ul>
<pre><code>export CFLAGS="-isystem /usr/include/harfbuzz -isystem /usr/include/cairo"
export CXXFLAGS="-isystem /usr/include/harfbuzz -isystem /usr/include/cairo"
</code></pre>
<h3 id="how-do-i-force-cmake-to-use-a-certain-c-compiler"><a class="header" href="#how-do-i-force-cmake-to-use-a-certain-c-compiler">How do I force CMake to use a certain C++ compiler?</a></h3>
<p>FLTK works with all 3 major compilers. If you would like to change the C++ compiler that's chosen by default by CMake, you can change the CXX environment variable before running the build:</p>
<pre><code>export CXX=/usr/bin/clang++
cargo run
</code></pre>
<p>CMake caches the C++ compiler variable after it's first run, so if the above failed because of a previous run, you would have to run <code>cargo clean</code> or you can manually delete the CMakeCache.txt file in the build directory.</p>
<h3 id="can-i-accelerate-the-build-speed"><a class="header" href="#can-i-accelerate-the-build-speed">Can I accelerate the build speed?</a></h3>
<p>You can use the "use-ninja" feature flag if you have ninja installed.</p>
<h3 id="can-i-cache-a-previous-build-of-the-fltk-library"><a class="header" href="#can-i-cache-a-previous-build-of-the-fltk-library">Can I cache a previous build of the FLTK library?</a></h3>
<p>You can use the fltk-bundled feature and use either the CFLTK_BUNDLE_DIR or CFLTK_BUNDLE_URL to point to the location of your cached cfltk and fltk libraries.</p>
<h2 id="deployment"><a class="header" href="#deployment">Deployment</a></h2>
<h3 id="how-do-i-deploy-my-application"><a class="header" href="#how-do-i-deploy-my-application">How do I deploy my application?</a></h3>
<p>Rust, by default, statically links your application. FLTK is built also for static linking. That means that the resulting executable can be directly deployed without the need to deploy other files along with it. If you want to create a WIN32 application, Mac OS Bundle or Linux AppImage, please check the question just below!</p>
<h3 id="why-do-i-get-a-console-window-whenever-i-start-my-gui-app"><a class="header" href="#why-do-i-get-a-console-window-whenever-i-start-my-gui-app">Why do I get a console window whenever I start my GUI app?</a></h3>
<p>This is the default behavior of the toolchain, and is helpful for debugging purposes. It can be turned off easily by adding <code>#![windows_subsystem = "windows"]</code> at the beginning of your main.rs file if you're on windows.
If you would like to keep the console window on debug builds, but not on release builds, you can use <code>#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]</code> instead.</p>
<p>For Mac OS and Linux, this is done by a post-build process to create a Mac OS Bundle or Linux AppImage respectively.</p>
<p>See <a href="https://github.com/burtonageo/cargo-bundle">cargo-bundle</a> for an automated tool for creating Mac OS app bundles.</p>
<p>See <a href="https://docs.appimage.org/packaging-guide/overview.html#converting-existing-binary-packages">here</a> for directions on creating an AppImage for Linux.</p>
<h3 id="why-is-the-size-of-my-resulting-executable-larger-than-i-had-expected"><a class="header" href="#why-is-the-size-of-my-resulting-executable-larger-than-i-had-expected">Why is the size of my resulting executable larger than I had expected?</a></h3>
<p>FLTK is known for it's small applications. Make sure you're building in release, and make sure symbols are stripped using the strip command in Unix-like systems. On Windows it's unnecessary since symbols would end up in the pdb file (which shouldn't be deployed).</p>
<p>If you need an even smaller size, try using opt-level="z":</p>
<pre><code class="language-toml">[profile.release]
opt-level = "z"
lto = true
codegen-units = 1
panic = "abort"
</code></pre>
<p>Newer versions of cargo (&gt;1.55) support automatically stripping binaries in the post-build phase:</p>
<pre><code class="language-toml">cargo-features = ["strip"]

[profile.release]
strip = true
opt-level = "z"
lto = true
codegen-units = 1
panic = "abort"
</code></pre>
<p>Furthermore, you can build Rust's stdlib optimized for size (it comes optimized for speed by default). More info on that <a href="https://github.com/johnthagen/min-sized-rust">here</a></p>
<h3 id="can-i-cross-compile-my-application-to-a-mobile-platform-or-wasm"><a class="header" href="#can-i-cross-compile-my-application-to-a-mobile-platform-or-wasm">Can I cross-compile my application to a mobile platform or WASM?</a></h3>
<p>FLTK currently doesn't support WASM nor iOS. It has experimental support for Android (YMMV). It is focused on desktop applications.</p>
<h2 id="licensing"><a class="header" href="#licensing">Licensing</a></h2>
<h3 id="can-i-use-this-crate-in-a-commercial-application"><a class="header" href="#can-i-use-this-crate-in-a-commercial-application">Can I use this crate in a commercial application?</a></h3>
<p>Yes. This crate has an MIT license which requires acknowledgment. FLTK (the C++ library) is licensed under the LGPL license with an exception allowing static linking for commercial/closed-source use. You can find the full terms of both licenses here:</p>
<ul>
<li><a href="https://github.com/fltk/fltk/blob/master/COPYING">COPYING</a></li>
<li><a href="https://github.com/fltk-rs/fltk-rs/blob/master/LICENSE">LICENSE</a></li>
</ul>
<h2 id="alignment"><a class="header" href="#alignment">Alignment</a></h2>
<h3 id="why-cant-i-align-input-or-output-text-to-the-right"><a class="header" href="#why-cant-i-align-input-or-output-text-to-the-right">Why can't I align input or output text to the right?</a></h3>
<p>FLTK has some known issues with text alignment.</p>
<h2 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h2>
<h3 id="do-you-plan-on-supporting-multithreading-or-asyncawait"><a class="header" href="#do-you-plan-on-supporting-multithreading-or-asyncawait">Do you plan on supporting multithreading or async/await?</a></h3>
<p>FLTK supports multithreaded and concurrent applications. See the examples dir and the <a href="https://github.com/fltk-rs/demos">fltk-rs demos repo</a> for examples on usage with threads, messages, async_std and tokio (web-todo examples).</p>
<h3 id="should-i-explicitly-call-applock-and-appunlock"><a class="header" href="#should-i-explicitly-call-applock-and-appunlock">Should I explicitly call app::lock() and app::unlock()?</a></h3>
<p>fltk-rs surrounds all mutating calls to widgets with a lock on the C++ wrapper side. Normally you wouldn't have to call app::lock() and app::unlock().
This depends however on the support of recursive mutexes in your system.
If you notice haning in multithreaded applications, you might have to initialize threads (like xlib threads) by calling app::lock() once in your main thread.
In that case, you can wrap widgets in an Arc<Mutex> or surround widget-mutating functions/methods with an app::lock and app::unlock.
But that should rarely be required.</p>
<h2 id="windowing"><a class="header" href="#windowing">Windowing</a></h2>
<h3 id="why-does-fltk-exit-when-i-hit-the-escape-key"><a class="header" href="#why-does-fltk-exit-when-i-hit-the-escape-key">Why does FLTK exit when I hit the escape key?</a></h3>
<p>This is the default behavior in FLTK. You can easily override it by setting a callback for your main window:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    wind.set_callback(|_| {
        if fltk::app::event() == fltk::enums::Event::Close {
            app::quit(); // Which would close using the close button. You can also assign other keys to close the application
        }
    });
<span class="boring">}</span></code></pre></pre>
<h2 id="panicscrashes"><a class="header" href="#panicscrashes">Panics/Crashes</a></h2>
<h3 id="my-app-panics-when-i-try-to-handle-events-how-can-i-fix-it"><a class="header" href="#my-app-panics-when-i-try-to-handle-events-how-can-i-fix-it">My app panics when I try to handle events, how can I fix it?</a></h3>
<p>This is due to a debug_assert which checks that the involved widget and the window are capable of handling events. Although most events would be handled correctly, some events require that the aforementioned conditions be met. Thus it is advisable to place your event handling code after the main drawing is done, i.e after calling your main window's show() method. Another point is that event handling and drawing should be done in the main thread. Panics accross FFI boundaries are undefined behavior, as such, the wrapper never throws. Furthermore, all panics which might arise in callbacks are caught on the Rust side using catch_unwind.</p>
<h2 id="memory-and-unsafety"><a class="header" href="#memory-and-unsafety">Memory and unsafety</a></h2>
<h3 id="how-memory-safe-is-fltk-rs"><a class="header" href="#how-memory-safe-is-fltk-rs">How memory-safe is fltk-rs?</a></h3>
<p>The callback mechanism consists of a closure as a void pointer with a shim which dereferences the void pointer into a function pointer and calls the function. This is technically undefined behavior, however most implementations permit it and it's the method used by most wrappers to handle callbacks across FFI boundaries. <a href="https://rust-lang.github.io/unsafe-code-guidelines/layout/function-pointers.html#representation">link</a></p>
<p>As stated before, panics accross FFI boundaries are undefined behavior, as such, the C++ wrapper never throws. Furthermore, all panics which might arise in callbacks are caught on the Rust side using catch_unwind.</p>
<p>FLTK manages it's own memory. Any widget is automatically owned by a parent which does the book-keeping as well and deletion, this is the enclosing widget implementing GroupExt such as windws etc. This is done in the C++ FLTK library itself. Any constructed widget calls the current() method which detects the enclosing group widget, and calls its add() method rending ownership to the group widget. Upon destruction of the group widget, all owned widgets are freed. Also all widgets are wrapped in a mutex for all mutating methods, and their lifetimes are tracked using an Fl_Widget_Tracker, That means widgets have interior mutability as if wrapped in an Arc&lt;Mutex<widget>&gt; and have a tracking pointer to detect deletion. Cloning a widget performs a memcpy of the underlying pointer and allows for interior mutability; it does not create a new widget.
Images are reference-counted. All mutating methods are wrapped in locks.
This locking might lead to some performance degradation as compared to the original FLTK library, it does allow for multithreaded applications, and is necessary in an FLTK (C++) application if it also required threading.</p>
<p>Overriding drawing methods will box data to be sent to the C++ library, so the data should optimally be limited to widgets or plain old data types to avoid unnecessary leaks if a custom drawn widget might be deleted during the lifetime of the program.</p>
<h3 id="can-i-get-memory-leaks-with-fltk-rs"><a class="header" href="#can-i-get-memory-leaks-with-fltk-rs">Can I get memory leaks with fltk-rs?</a></h3>
<p>Non-parented widgets that can no longer be accessed are a memory leak. Otherwise, as mentioned in the previous section all parented widgets lifetimes' are managed by the parent.
An example of a leaking widget:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = app::App::default();
    let mut win = window::Window::default();
    win.end();
    win.show();

    {
        button::Button::default(); // this leaks since it's not parented by the window, and has no handle in main
    }
}</code></pre></pre>
<p>A more subtle cause of leaks, is removing a widget from a group, then the scope ends without it being added to another group or deleted:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let a = app::App::default();
    let mut win = window::Window::default();
    {
        button::Button::default(); // This doesn't leak since the parent is the window
    }
    win.end();
    win.show();

    {
        win.remove_by_index(0); // the button leaks here since it's removed and we no longer have access to it
    }
}</code></pre></pre>
<h3 id="why-is-fltk-rs-using-so-much-unsafe-code"><a class="header" href="#why-is-fltk-rs-using-so-much-unsafe-code">Why is fltk-rs using so much unsafe code?</a></h3>
<p>Interfacing with C++ or C code can't be reasoned about by the Rust compiler, so the unsafe keyword is needed.</p>
<h3 id="is-fltk-rs-panicexception-safe"><a class="header" href="#is-fltk-rs-panicexception-safe">Is fltk-rs panic/exception-safe?</a></h3>
<p>FLTK (C++) doesn't throw exceptions, neither do the C wrapper (cfltk) nor the fltk-sys crate. The higher level fltk crate, which wraps fltk-sys, is not exception-safe since it uses asserts internally after various operations to ensure memory-safety. An example is a widget constructor which checks that the returned pointer (from the C++ side) is not null from allocation failure. It also asserts all widget reads/writes are happening on valid (not deleted) widgets.
Also any function sending a string across FFI is checked for interal null bytes. For such functions, the developer can perform a sanity check on passed strings to make sure they're valid UTF-8 strings, or check that a widget was not deleted prior to accessing a widget. That said, all functions passed as callbacks to be handled by the C++ side are exception-safe.</p>
<h3 id="are-there-any-environment-variables-which-can-affect-the-build-or-behavior"><a class="header" href="#are-there-any-environment-variables-which-can-affect-the-build-or-behavior">Are there any environment variables which can affect the build or behavior?</a></h3>
<ul>
<li><code>CFLTK_TOOLCHAIN=&lt;path&gt;</code> allows passing the path to a CMake file acting as a CMAKE_TOOLCHAIN_FILE, this allows passing extra info to cmake if needed.</li>
<li><code>CFLTK_WAYLAND_ONLY=&lt;1 or 0&gt;</code> allows building for wayland only without directly linking X11 libs nor relying on their headers for the build process. This only works with the <code>use-wayland</code> feature flag.</li>
<li><code>CFLTK_BUNDLE_DIR=&lt;path&gt;</code> allows passing a path of prebuilt cfltk and fltk static libs, useful for when a customized build of fltk is needed, or for targetting other arches when building with the <code>fltk-bundled</code> flag.</li>
<li><code>CFLTK_BUNDLE_URL=&lt;url&gt;</code> similar to above but allows passing a url which will directs the build script to download from the passed url.</li>
<li><code>FLTK_BACKEND=&lt;x11 or wayland&gt;</code> allows choosing the backend of your hybrid X11/wayland FLTK app. This only works for apps built with <code>use-wayland</code> feature flag.</li>
</ul>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>Please refer to the <a href="https://github.com/fltk-rs/fltk-rs/blob/master/CONTRIBUTING.md">CONTRIBUTING</a> page for further information.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
